{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/standalone/common/monarch/monarchLexer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/standalone/common/monarch/monarchLexer.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/editor/common/core/token\", \"vs/editor/common/modes\", \"vs/editor/common/modes/nullMode\", \"vs/editor/standalone/common/monarch/monarchCommon\"], function (require, exports, token_1, modes, nullMode_1, monarchCommon) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const CACHE_STACK_DEPTH = 5;\n    /**\n     * Reuse the same stack elements up to a certain depth.\n     */\n    class MonarchStackElementFactory {\n        constructor(maxCacheDepth) {\n            this._maxCacheDepth = maxCacheDepth;\n            this._entries = Object.create(null);\n        }\n        static create(parent, state) {\n            return this._INSTANCE.create(parent, state);\n        }\n        create(parent, state) {\n            if (parent !== null && parent.depth >= this._maxCacheDepth) {\n                // no caching above a certain depth\n                return new MonarchStackElement(parent, state);\n            }\n            let stackElementId = MonarchStackElement.getStackElementId(parent);\n            if (stackElementId.length > 0) {\n                stackElementId += '|';\n            }\n            stackElementId += state;\n            let result = this._entries[stackElementId];\n            if (result) {\n                return result;\n            }\n            result = new MonarchStackElement(parent, state);\n            this._entries[stackElementId] = result;\n            return result;\n        }\n    }\n    MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n    class MonarchStackElement {\n        constructor(parent, state) {\n            this.parent = parent;\n            this.state = state;\n            this.depth = (this.parent ? this.parent.depth : 0) + 1;\n        }\n        static getStackElementId(element) {\n            let result = '';\n            while (element !== null) {\n                if (result.length > 0) {\n                    result += '|';\n                }\n                result += element.state;\n                element = element.parent;\n            }\n            return result;\n        }\n        static _equals(a, b) {\n            while (a !== null && b !== null) {\n                if (a === b) {\n                    return true;\n                }\n                if (a.state !== b.state) {\n                    return false;\n                }\n                a = a.parent;\n                b = b.parent;\n            }\n            if (a === null && b === null) {\n                return true;\n            }\n            return false;\n        }\n        equals(other) {\n            return MonarchStackElement._equals(this, other);\n        }\n        push(state) {\n            return MonarchStackElementFactory.create(this, state);\n        }\n        pop() {\n            return this.parent;\n        }\n        popall() {\n            let result = this;\n            while (result.parent) {\n                result = result.parent;\n            }\n            return result;\n        }\n        switchTo(state) {\n            return MonarchStackElementFactory.create(this.parent, state);\n        }\n    }\n    class EmbeddedModeData {\n        constructor(modeId, state) {\n            this.modeId = modeId;\n            this.state = state;\n        }\n        equals(other) {\n            return (this.modeId === other.modeId\n                && this.state.equals(other.state));\n        }\n        clone() {\n            let stateClone = this.state.clone();\n            // save an object\n            if (stateClone === this.state) {\n                return this;\n            }\n            return new EmbeddedModeData(this.modeId, this.state);\n        }\n    }\n    /**\n     * Reuse the same line states up to a certain depth.\n     */\n    class MonarchLineStateFactory {\n        constructor(maxCacheDepth) {\n            this._maxCacheDepth = maxCacheDepth;\n            this._entries = Object.create(null);\n        }\n        static create(stack, embeddedModeData) {\n            return this._INSTANCE.create(stack, embeddedModeData);\n        }\n        create(stack, embeddedModeData) {\n            if (embeddedModeData !== null) {\n                // no caching when embedding\n                return new MonarchLineState(stack, embeddedModeData);\n            }\n            if (stack !== null && stack.depth >= this._maxCacheDepth) {\n                // no caching above a certain depth\n                return new MonarchLineState(stack, embeddedModeData);\n            }\n            let stackElementId = MonarchStackElement.getStackElementId(stack);\n            let result = this._entries[stackElementId];\n            if (result) {\n                return result;\n            }\n            result = new MonarchLineState(stack, null);\n            this._entries[stackElementId] = result;\n            return result;\n        }\n    }\n    MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n    class MonarchLineState {\n        constructor(stack, embeddedModeData) {\n            this.stack = stack;\n            this.embeddedModeData = embeddedModeData;\n        }\n        clone() {\n            let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\n            // save an object\n            if (embeddedModeDataClone === this.embeddedModeData) {\n                return this;\n            }\n            return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n        }\n        equals(other) {\n            if (!(other instanceof MonarchLineState)) {\n                return false;\n            }\n            if (!this.stack.equals(other.stack)) {\n                return false;\n            }\n            if (this.embeddedModeData === null && other.embeddedModeData === null) {\n                return true;\n            }\n            if (this.embeddedModeData === null || other.embeddedModeData === null) {\n                return false;\n            }\n            return this.embeddedModeData.equals(other.embeddedModeData);\n        }\n    }\n    const hasOwnProperty = Object.hasOwnProperty;\n    class MonarchClassicTokensCollector {\n        constructor() {\n            this._tokens = [];\n            this._language = null;\n            this._lastTokenType = null;\n            this._lastTokenLanguage = null;\n        }\n        enterMode(startOffset, modeId) {\n            this._language = modeId;\n        }\n        emit(startOffset, type) {\n            if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\n                return;\n            }\n            this._lastTokenType = type;\n            this._lastTokenLanguage = this._language;\n            this._tokens.push(new token_1.Token(startOffset, type, this._language));\n        }\n        nestedModeTokenize(embeddedModeLine, embeddedModeData, offsetDelta) {\n            const nestedModeId = embeddedModeData.modeId;\n            const embeddedModeState = embeddedModeData.state;\n            const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n            if (!nestedModeTokenizationSupport) {\n                this.enterMode(offsetDelta, nestedModeId);\n                this.emit(offsetDelta, '');\n                return embeddedModeState;\n            }\n            let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);\n            this._tokens = this._tokens.concat(nestedResult.tokens);\n            this._lastTokenType = null;\n            this._lastTokenLanguage = null;\n            this._language = null;\n            return nestedResult.endState;\n        }\n        finalize(endState) {\n            return new token_1.TokenizationResult(this._tokens, endState);\n        }\n    }\n    class MonarchModernTokensCollector {\n        constructor(modeService, theme) {\n            this._modeService = modeService;\n            this._theme = theme;\n            this._prependTokens = null;\n            this._tokens = [];\n            this._currentLanguageId = modes.LanguageId.Null;\n            this._lastTokenMetadata = 0;\n        }\n        enterMode(startOffset, modeId) {\n            this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\n        }\n        emit(startOffset, type) {\n            let metadata = this._theme.match(this._currentLanguageId, type);\n            if (this._lastTokenMetadata === metadata) {\n                return;\n            }\n            this._lastTokenMetadata = metadata;\n            this._tokens.push(startOffset);\n            this._tokens.push(metadata);\n        }\n        static _merge(a, b, c) {\n            let aLen = (a !== null ? a.length : 0);\n            let bLen = b.length;\n            let cLen = (c !== null ? c.length : 0);\n            if (aLen === 0 && bLen === 0 && cLen === 0) {\n                return new Uint32Array(0);\n            }\n            if (aLen === 0 && bLen === 0) {\n                return c;\n            }\n            if (bLen === 0 && cLen === 0) {\n                return a;\n            }\n            let result = new Uint32Array(aLen + bLen + cLen);\n            if (a !== null) {\n                result.set(a);\n            }\n            for (let i = 0; i < bLen; i++) {\n                result[aLen + i] = b[i];\n            }\n            if (c !== null) {\n                result.set(c, aLen + bLen);\n            }\n            return result;\n        }\n        nestedModeTokenize(embeddedModeLine, embeddedModeData, offsetDelta) {\n            const nestedModeId = embeddedModeData.modeId;\n            const embeddedModeState = embeddedModeData.state;\n            const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n            if (!nestedModeTokenizationSupport) {\n                this.enterMode(offsetDelta, nestedModeId);\n                this.emit(offsetDelta, '');\n                return embeddedModeState;\n            }\n            let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);\n            this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n            this._tokens = [];\n            this._currentLanguageId = 0;\n            this._lastTokenMetadata = 0;\n            return nestedResult.endState;\n        }\n        finalize(endState) {\n            return new token_1.TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n        }\n    }\n    class MonarchTokenizer {\n        constructor(modeService, standaloneThemeService, modeId, lexer) {\n            this._modeService = modeService;\n            this._standaloneThemeService = standaloneThemeService;\n            this._modeId = modeId;\n            this._lexer = lexer;\n            this._embeddedModes = Object.create(null);\n            this.embeddedLoaded = Promise.resolve(undefined);\n            // Set up listening for embedded modes\n            let emitting = false;\n            this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange((e) => {\n                if (emitting) {\n                    return;\n                }\n                let isOneOfMyEmbeddedModes = false;\n                for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\n                    let language = e.changedLanguages[i];\n                    if (this._embeddedModes[language]) {\n                        isOneOfMyEmbeddedModes = true;\n                        break;\n                    }\n                }\n                if (isOneOfMyEmbeddedModes) {\n                    emitting = true;\n                    modes.TokenizationRegistry.fire([this._modeId]);\n                    emitting = false;\n                }\n            });\n        }\n        dispose() {\n            this._tokenizationRegistryListener.dispose();\n        }\n        getLoadStatus() {\n            let promises = [];\n            for (let nestedModeId in this._embeddedModes) {\n                const tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n                if (tokenizationSupport) {\n                    // The nested mode is already loaded\n                    if (tokenizationSupport instanceof MonarchTokenizer) {\n                        const nestedModeStatus = tokenizationSupport.getLoadStatus();\n                        if (nestedModeStatus.loaded === false) {\n                            promises.push(nestedModeStatus.promise);\n                        }\n                    }\n                    continue;\n                }\n                const tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n                if (tokenizationSupportPromise) {\n                    // The nested mode is in the process of being loaded\n                    promises.push(tokenizationSupportPromise);\n                }\n            }\n            if (promises.length === 0) {\n                return {\n                    loaded: true\n                };\n            }\n            return {\n                loaded: false,\n                promise: Promise.all(promises).then(_ => undefined)\n            };\n        }\n        getInitialState() {\n            let rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n            return MonarchLineStateFactory.create(rootState, null);\n        }\n        tokenize(line, lineState, offsetDelta) {\n            let tokensCollector = new MonarchClassicTokensCollector();\n            let endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n            return tokensCollector.finalize(endLineState);\n        }\n        tokenize2(line, lineState, offsetDelta) {\n            let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getTheme().tokenTheme);\n            let endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);\n            return tokensCollector.finalize(endLineState);\n        }\n        _tokenize(line, lineState, offsetDelta, collector) {\n            if (lineState.embeddedModeData) {\n                return this._nestedTokenize(line, lineState, offsetDelta, collector);\n            }\n            else {\n                return this._myTokenize(line, lineState, offsetDelta, collector);\n            }\n        }\n        _findLeavingNestedModeOffset(line, state) {\n            let rules = this._lexer.tokenizer[state.stack.state];\n            if (!rules) {\n                rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n                if (!rules) {\n                    throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n                }\n            }\n            let popOffset = -1;\n            let hasEmbeddedPopRule = false;\n            for (let idx in rules) {\n                if (!hasOwnProperty.call(rules, idx)) {\n                    continue;\n                }\n                let rule = rules[idx];\n                if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n                    continue;\n                }\n                hasEmbeddedPopRule = true;\n                let regex = rule.regex;\n                let regexSource = rule.regex.source;\n                if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n                    regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');\n                }\n                let result = line.search(regex);\n                if (result === -1) {\n                    continue;\n                }\n                if (popOffset === -1 || result < popOffset) {\n                    popOffset = result;\n                }\n            }\n            if (!hasEmbeddedPopRule) {\n                throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n            }\n            return popOffset;\n        }\n        _nestedTokenize(line, lineState, offsetDelta, tokensCollector) {\n            let popOffset = this._findLeavingNestedModeOffset(line, lineState);\n            if (popOffset === -1) {\n                // tokenization will not leave nested mode\n                let nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);\n                return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\n            }\n            let nestedModeLine = line.substring(0, popOffset);\n            if (nestedModeLine.length > 0) {\n                // tokenize with the nested mode\n                tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);\n            }\n            let restOfTheLine = line.substring(popOffset);\n            return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);\n        }\n        _safeRuleName(rule) {\n            if (rule) {\n                return rule.name;\n            }\n            return '(unknown)';\n        }\n        _myTokenize(line, lineState, offsetDelta, tokensCollector) {\n            tokensCollector.enterMode(offsetDelta, this._modeId);\n            const lineLength = line.length;\n            let embeddedModeData = lineState.embeddedModeData;\n            let stack = lineState.stack;\n            let pos = 0;\n            let groupMatching = null;\n            // See https://github.com/Microsoft/monaco-editor/issues/1235:\n            // Evaluate rules at least once for an empty line\n            let forceEvaluation = true;\n            while (forceEvaluation || pos < lineLength) {\n                const pos0 = pos;\n                const stackLen0 = stack.depth;\n                const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n                const state = stack.state;\n                let matches = null;\n                let matched = null;\n                let action = null;\n                let rule = null;\n                let enteringEmbeddedMode = null;\n                // check if we need to process group matches first\n                if (groupMatching) {\n                    matches = groupMatching.matches;\n                    const groupEntry = groupMatching.groups.shift();\n                    matched = groupEntry.matched;\n                    action = groupEntry.action;\n                    rule = groupMatching.rule;\n                    // cleanup if necessary\n                    if (groupMatching.groups.length === 0) {\n                        groupMatching = null;\n                    }\n                }\n                else {\n                    // otherwise we match on the token stream\n                    if (!forceEvaluation && pos >= lineLength) {\n                        // nothing to do\n                        break;\n                    }\n                    forceEvaluation = false;\n                    // get the rules for this state\n                    let rules = this._lexer.tokenizer[state];\n                    if (!rules) {\n                        rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n                        if (!rules) {\n                            throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n                        }\n                    }\n                    // try each rule until we match\n                    let restOfLine = line.substr(pos);\n                    for (let idx in rules) {\n                        if (hasOwnProperty.call(rules, idx)) {\n                            let rule = rules[idx];\n                            if (pos === 0 || !rule.matchOnlyAtLineStart) {\n                                matches = restOfLine.match(rule.regex);\n                                if (matches) {\n                                    matched = matches[0];\n                                    action = rule.action;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                // We matched 'rule' with 'matches' and 'action'\n                if (!matches) {\n                    matches = [''];\n                    matched = '';\n                }\n                if (!action) {\n                    // bad: we didn't match anything, and there is no action to take\n                    // we need to advance the stream or we get progress trouble\n                    if (pos < lineLength) {\n                        matches = [line.charAt(pos)];\n                        matched = matches[0];\n                    }\n                    action = this._lexer.defaultToken;\n                }\n                if (matched === null) {\n                    // should never happen, needed for strict null checking\n                    break;\n                }\n                // advance stream\n                pos += matched.length;\n                // maybe call action function (used for 'cases')\n                while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n                    action = action.test(matched, matches, state, pos === lineLength);\n                }\n                let result = null;\n                // set the result: either a string or an array of actions\n                if (typeof action === 'string' || Array.isArray(action)) {\n                    result = action;\n                }\n                else if (action.group) {\n                    result = action.group;\n                }\n                else if (action.token !== null && action.token !== undefined) {\n                    // do $n replacements?\n                    if (action.tokenSubst) {\n                        result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n                    }\n                    else {\n                        result = action.token;\n                    }\n                    // enter embedded mode?\n                    if (action.nextEmbedded) {\n                        if (action.nextEmbedded === '@pop') {\n                            if (!embeddedModeData) {\n                                throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n                            }\n                            embeddedModeData = null;\n                        }\n                        else if (embeddedModeData) {\n                            throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n                        }\n                        else {\n                            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n                        }\n                    }\n                    // state transformations\n                    if (action.goBack) { // back up the stream..\n                        pos = Math.max(0, pos - action.goBack);\n                    }\n                    if (action.switchTo && typeof action.switchTo === 'string') {\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n                        if (nextState[0] === '@') {\n                            nextState = nextState.substr(1); // peel off starting '@'\n                        }\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\n                            throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                        }\n                        else {\n                            stack = stack.switchTo(nextState);\n                        }\n                    }\n                    else if (action.transform && typeof action.transform === 'function') {\n                        throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n                    }\n                    else if (action.next) {\n                        if (action.next === '@push') {\n                            if (stack.depth >= this._lexer.maxStack) {\n                                throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\n                                    stack.state + ',' + stack.parent.state + ',...]');\n                            }\n                            else {\n                                stack = stack.push(state);\n                            }\n                        }\n                        else if (action.next === '@pop') {\n                            if (stack.depth <= 1) {\n                                throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n                            }\n                            else {\n                                stack = stack.pop();\n                            }\n                        }\n                        else if (action.next === '@popall') {\n                            stack = stack.popall();\n                        }\n                        else {\n                            let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n                            if (nextState[0] === '@') {\n                                nextState = nextState.substr(1); // peel off starting '@'\n                            }\n                            if (!monarchCommon.findRules(this._lexer, nextState)) {\n                                throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n                            }\n                            else {\n                                stack = stack.push(nextState);\n                            }\n                        }\n                    }\n                    if (action.log && typeof (action.log) === 'string') {\n                        monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n                    }\n                }\n                // check result\n                if (result === null) {\n                    throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n                }\n                // is the result a group match?\n                if (Array.isArray(result)) {\n                    if (groupMatching && groupMatching.groups.length > 0) {\n                        throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n                    }\n                    if (matches.length !== result.length + 1) {\n                        throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n                    }\n                    let totalLen = 0;\n                    for (let i = 1; i < matches.length; i++) {\n                        totalLen += matches[i].length;\n                    }\n                    if (totalLen !== matched.length) {\n                        throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n                    }\n                    groupMatching = {\n                        rule: rule,\n                        matches: matches,\n                        groups: []\n                    };\n                    for (let i = 0; i < result.length; i++) {\n                        groupMatching.groups[i] = {\n                            action: result[i],\n                            matched: matches[i + 1]\n                        };\n                    }\n                    pos -= matched.length;\n                    // call recursively to initiate first result match\n                    continue;\n                }\n                else {\n                    // regular result\n                    // check for '@rematch'\n                    if (result === '@rematch') {\n                        pos -= matched.length;\n                        matched = ''; // better set the next state too..\n                        matches = null;\n                        result = '';\n                    }\n                    // check progress\n                    if (matched.length === 0) {\n                        if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n                            continue;\n                        }\n                        else {\n                            throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n                        }\n                    }\n                    // return the result (and check for brace matching)\n                    // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n                    let tokenType = null;\n                    if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n                        let rest = result.substr('@brackets'.length);\n                        let bracket = findBracket(this._lexer, matched);\n                        if (!bracket) {\n                            throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n                        }\n                        tokenType = monarchCommon.sanitize(bracket.token + rest);\n                    }\n                    else {\n                        let token = (result === '' ? '' : result + this._lexer.tokenPostfix);\n                        tokenType = monarchCommon.sanitize(token);\n                    }\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\n                }\n                if (enteringEmbeddedMode !== null) {\n                    // substitute language alias to known modes to support syntax highlighting\n                    let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n                    if (enteringEmbeddedModeId) {\n                        enteringEmbeddedMode = enteringEmbeddedModeId;\n                    }\n                    let embeddedModeData = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\n                    if (pos < lineLength) {\n                        // there is content from the embedded mode on this line\n                        let restOfLine = line.substr(pos);\n                        return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\n                    }\n                    else {\n                        return MonarchLineStateFactory.create(stack, embeddedModeData);\n                    }\n                }\n            }\n            return MonarchLineStateFactory.create(stack, embeddedModeData);\n        }\n        _getNestedEmbeddedModeData(mimetypeOrModeId) {\n            let nestedModeId = this._locateMode(mimetypeOrModeId);\n            if (nestedModeId) {\n                let tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n                if (tokenizationSupport) {\n                    return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n                }\n            }\n            return new EmbeddedModeData(nestedModeId || nullMode_1.NULL_MODE_ID, nullMode_1.NULL_STATE);\n        }\n        _locateMode(mimetypeOrModeId) {\n            if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n                return null;\n            }\n            let modeId = this._modeService.getModeId(mimetypeOrModeId);\n            if (modeId) {\n                // Fire mode loading event\n                this._modeService.triggerMode(modeId);\n                this._embeddedModes[modeId] = true;\n            }\n            return modeId;\n        }\n    }\n    exports.MonarchTokenizer = MonarchTokenizer;\n    /**\n     * Searches for a bracket in the 'brackets' attribute that matches the input.\n     */\n    function findBracket(lexer, matched) {\n        if (!matched) {\n            return null;\n        }\n        matched = monarchCommon.fixCase(lexer, matched);\n        let brackets = lexer.brackets;\n        for (const bracket of brackets) {\n            if (bracket.open === matched) {\n                return { token: bracket.token, bracketType: monarchCommon.MonarchBracket.Open };\n            }\n            else if (bracket.close === matched) {\n                return { token: bracket.token, bracketType: monarchCommon.MonarchBracket.Close };\n            }\n        }\n        return null;\n    }\n    function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\n        return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\n    }\n    exports.createTokenizationSupport = createTokenizationSupport;\n});\n",null]}