{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/terminalProcess.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/terminal/node/terminalProcess.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"os\", \"vs/base/common/path\", \"vs/base/common/platform\", \"node-pty\", \"fs\", \"vs/base/common/event\", \"vs/workbench/contrib/terminal/node/terminal\", \"child_process\"], function (require, exports, os, path, platform, pty, fs, event_1, terminal_1, child_process_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TerminalProcess {\n        constructor(shellLaunchConfig, cwd, cols, rows, env, windowsEnableConpty) {\n            this._currentTitle = '';\n            this._isDisposed = false;\n            this._titleInterval = null;\n            this._onProcessData = new event_1.Emitter();\n            this._onProcessExit = new event_1.Emitter();\n            this._onProcessIdReady = new event_1.Emitter();\n            this._onProcessTitleChanged = new event_1.Emitter();\n            let shellName;\n            if (os.platform() === 'win32') {\n                shellName = path.basename(shellLaunchConfig.executable || '');\n            }\n            else {\n                // Using 'xterm-256color' here helps ensure that the majority of Linux distributions will use a\n                // color prompt as defined in the default ~/.bashrc file.\n                shellName = 'xterm-256color';\n            }\n            this._initialCwd = cwd;\n            const useConpty = windowsEnableConpty && process.platform === 'win32' && terminal_1.getWindowsBuildNumber() >= 18309;\n            const options = {\n                name: shellName,\n                cwd,\n                env,\n                cols,\n                rows,\n                experimentalUseConpty: useConpty\n            };\n            try {\n                this._ptyProcess = pty.spawn(shellLaunchConfig.executable, shellLaunchConfig.args || [], options);\n                this._processStartupComplete = new Promise(c => {\n                    this.onProcessIdReady((pid) => {\n                        c();\n                    });\n                });\n            }\n            catch (error) {\n                // The only time this is expected to happen is when the file specified to launch with does not exist.\n                this._exitCode = 2;\n                this._queueProcessExit();\n                this._processStartupComplete = Promise.resolve(undefined);\n                return;\n            }\n            this._ptyProcess.on('data', (data) => {\n                this._onProcessData.fire(data);\n                if (this._closeTimeout) {\n                    clearTimeout(this._closeTimeout);\n                    this._queueProcessExit();\n                }\n            });\n            this._ptyProcess.on('exit', (code) => {\n                this._exitCode = code;\n                this._queueProcessExit();\n            });\n            // TODO: We should no longer need to delay this since pty.spawn is sync\n            setTimeout(() => {\n                this._sendProcessId();\n            }, 500);\n            this._setupTitlePolling();\n        }\n        get onProcessData() { return this._onProcessData.event; }\n        get onProcessExit() { return this._onProcessExit.event; }\n        get onProcessIdReady() { return this._onProcessIdReady.event; }\n        get onProcessTitleChanged() { return this._onProcessTitleChanged.event; }\n        dispose() {\n            this._isDisposed = true;\n            if (this._titleInterval) {\n                clearInterval(this._titleInterval);\n            }\n            this._titleInterval = null;\n            this._onProcessData.dispose();\n            this._onProcessExit.dispose();\n            this._onProcessIdReady.dispose();\n            this._onProcessTitleChanged.dispose();\n        }\n        _setupTitlePolling() {\n            // Send initial timeout async to give event listeners a chance to init\n            setTimeout(() => {\n                this._sendProcessTitle();\n            }, 0);\n            // Setup polling\n            this._titleInterval = setInterval(() => {\n                if (this._currentTitle !== this._ptyProcess.process) {\n                    this._sendProcessTitle();\n                }\n            }, 200);\n        }\n        // Allow any trailing data events to be sent before the exit event is sent.\n        // See https://github.com/Tyriar/node-pty/issues/72\n        _queueProcessExit() {\n            if (this._closeTimeout) {\n                clearTimeout(this._closeTimeout);\n            }\n            this._closeTimeout = setTimeout(() => this._kill(), 250);\n        }\n        _kill() {\n            // Wait to kill to process until the start up code has run. This prevents us from firing a process exit before a\n            // process start.\n            this._processStartupComplete.then(() => {\n                if (this._isDisposed) {\n                    return;\n                }\n                // Attempt to kill the pty, it may have already been killed at this\n                // point but we want to make sure\n                try {\n                    this._ptyProcess.kill();\n                }\n                catch (ex) {\n                    // Swallow, the pty has already been killed\n                }\n                this._onProcessExit.fire(this._exitCode);\n                this.dispose();\n            });\n        }\n        _sendProcessId() {\n            this._onProcessIdReady.fire(this._ptyProcess.pid);\n        }\n        _sendProcessTitle() {\n            if (this._isDisposed) {\n                return;\n            }\n            this._currentTitle = this._ptyProcess.process;\n            this._onProcessTitleChanged.fire(this._currentTitle);\n        }\n        shutdown(immediate) {\n            if (immediate) {\n                this._kill();\n            }\n            else {\n                this._queueProcessExit();\n            }\n        }\n        input(data) {\n            if (this._isDisposed) {\n                return;\n            }\n            this._ptyProcess.write(data);\n        }\n        resize(cols, rows) {\n            if (this._isDisposed) {\n                return;\n            }\n            // Ensure that cols and rows are always >= 1, this prevents a native\n            // exception in winpty.\n            this._ptyProcess.resize(Math.max(cols, 1), Math.max(rows, 1));\n        }\n        getInitialCwd() {\n            return Promise.resolve(this._initialCwd);\n        }\n        getCwd() {\n            if (platform.isMacintosh) {\n                return new Promise(resolve => {\n                    child_process_1.exec('lsof -p ' + this._ptyProcess.pid + ' | grep cwd', (error, stdout, stderr) => {\n                        if (stdout !== '') {\n                            resolve(stdout.substring(stdout.indexOf('/'), stdout.length - 1));\n                        }\n                    });\n                });\n            }\n            if (platform.isLinux) {\n                return new Promise(resolve => {\n                    fs.readlink('/proc/' + this._ptyProcess.pid + '/cwd', (err, linkedstr) => {\n                        if (err) {\n                            resolve(this._initialCwd);\n                        }\n                        resolve(linkedstr);\n                    });\n                });\n            }\n            return new Promise(resolve => {\n                resolve(this._initialCwd);\n            });\n        }\n        getLatency() {\n            return Promise.resolve(0);\n        }\n    }\n    exports.TerminalProcess = TerminalProcess;\n});\n",null]}