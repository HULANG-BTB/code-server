{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replacePattern.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/find/replacePattern.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\"], function (require, exports, charCode_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ReplacePatternKind;\n    (function (ReplacePatternKind) {\n        ReplacePatternKind[ReplacePatternKind[\"StaticValue\"] = 0] = \"StaticValue\";\n        ReplacePatternKind[ReplacePatternKind[\"DynamicPieces\"] = 1] = \"DynamicPieces\";\n    })(ReplacePatternKind || (ReplacePatternKind = {}));\n    /**\n     * Assigned when the replace pattern is entirely static.\n     */\n    class StaticValueReplacePattern {\n        constructor(staticValue) {\n            this.staticValue = staticValue;\n            this.kind = ReplacePatternKind.StaticValue;\n        }\n    }\n    /**\n     * Assigned when the replace pattern has replacemend patterns.\n     */\n    class DynamicPiecesReplacePattern {\n        constructor(pieces) {\n            this.pieces = pieces;\n            this.kind = ReplacePatternKind.DynamicPieces;\n        }\n    }\n    class ReplacePattern {\n        static fromStaticValue(value) {\n            return new ReplacePattern([ReplacePiece.staticValue(value)]);\n        }\n        get hasReplacementPatterns() {\n            return (this._state.kind === ReplacePatternKind.DynamicPieces);\n        }\n        constructor(pieces) {\n            if (!pieces || pieces.length === 0) {\n                this._state = new StaticValueReplacePattern('');\n            }\n            else if (pieces.length === 1 && pieces[0].staticValue !== null) {\n                this._state = new StaticValueReplacePattern(pieces[0].staticValue);\n            }\n            else {\n                this._state = new DynamicPiecesReplacePattern(pieces);\n            }\n        }\n        buildReplaceString(matches) {\n            if (this._state.kind === ReplacePatternKind.StaticValue) {\n                return this._state.staticValue;\n            }\n            let result = '';\n            for (let i = 0, len = this._state.pieces.length; i < len; i++) {\n                let piece = this._state.pieces[i];\n                if (piece.staticValue !== null) {\n                    // static value ReplacePiece\n                    result += piece.staticValue;\n                    continue;\n                }\n                // match index ReplacePiece\n                result += ReplacePattern._substitute(piece.matchIndex, matches);\n            }\n            return result;\n        }\n        static _substitute(matchIndex, matches) {\n            if (matches === null) {\n                return '';\n            }\n            if (matchIndex === 0) {\n                return matches[0];\n            }\n            let remainder = '';\n            while (matchIndex > 0) {\n                if (matchIndex < matches.length) {\n                    // A match can be undefined\n                    let match = (matches[matchIndex] || '');\n                    return match + remainder;\n                }\n                remainder = String(matchIndex % 10) + remainder;\n                matchIndex = Math.floor(matchIndex / 10);\n            }\n            return '$' + remainder;\n        }\n    }\n    exports.ReplacePattern = ReplacePattern;\n    /**\n     * A replace piece can either be a static string or an index to a specific match.\n     */\n    class ReplacePiece {\n        static staticValue(value) {\n            return new ReplacePiece(value, -1);\n        }\n        static matchIndex(index) {\n            return new ReplacePiece(null, index);\n        }\n        constructor(staticValue, matchIndex) {\n            this.staticValue = staticValue;\n            this.matchIndex = matchIndex;\n        }\n    }\n    exports.ReplacePiece = ReplacePiece;\n    class ReplacePieceBuilder {\n        constructor(source) {\n            this._source = source;\n            this._lastCharIndex = 0;\n            this._result = [];\n            this._resultLen = 0;\n            this._currentStaticPiece = '';\n        }\n        emitUnchanged(toCharIndex) {\n            this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));\n            this._lastCharIndex = toCharIndex;\n        }\n        emitStatic(value, toCharIndex) {\n            this._emitStatic(value);\n            this._lastCharIndex = toCharIndex;\n        }\n        _emitStatic(value) {\n            if (value.length === 0) {\n                return;\n            }\n            this._currentStaticPiece += value;\n        }\n        emitMatchIndex(index, toCharIndex) {\n            if (this._currentStaticPiece.length !== 0) {\n                this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n                this._currentStaticPiece = '';\n            }\n            this._result[this._resultLen++] = ReplacePiece.matchIndex(index);\n            this._lastCharIndex = toCharIndex;\n        }\n        finalize() {\n            this.emitUnchanged(this._source.length);\n            if (this._currentStaticPiece.length !== 0) {\n                this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);\n                this._currentStaticPiece = '';\n            }\n            return new ReplacePattern(this._result);\n        }\n    }\n    /**\n     * \\n\t\t\t=> inserts a LF\n     * \\t\t\t\t=> inserts a TAB\n     * \\\\\t\t\t=> inserts a \"\\\".\n     * $$\t\t\t=> inserts a \"$\".\n     * $& and $0\t=> inserts the matched substring.\n     * $n\t\t\t=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string\n     * everything else stays untouched\n     *\n     * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter\n     */\n    function parseReplaceString(replaceString) {\n        if (!replaceString || replaceString.length === 0) {\n            return new ReplacePattern(null);\n        }\n        let result = new ReplacePieceBuilder(replaceString);\n        for (let i = 0, len = replaceString.length; i < len; i++) {\n            let chCode = replaceString.charCodeAt(i);\n            if (chCode === charCode_1.CharCode.Backslash) {\n                // move to next char\n                i++;\n                if (i >= len) {\n                    // string ends with a \\\n                    break;\n                }\n                let nextChCode = replaceString.charCodeAt(i);\n                // let replaceWithCharacter: string | null = null;\n                switch (nextChCode) {\n                    case charCode_1.CharCode.Backslash:\n                        // \\\\ => inserts a \"\\\"\n                        result.emitUnchanged(i - 1);\n                        result.emitStatic('\\\\', i + 1);\n                        break;\n                    case charCode_1.CharCode.n:\n                        // \\n => inserts a LF\n                        result.emitUnchanged(i - 1);\n                        result.emitStatic('\\n', i + 1);\n                        break;\n                    case charCode_1.CharCode.t:\n                        // \\t => inserts a TAB\n                        result.emitUnchanged(i - 1);\n                        result.emitStatic('\\t', i + 1);\n                        break;\n                }\n                continue;\n            }\n            if (chCode === charCode_1.CharCode.DollarSign) {\n                // move to next char\n                i++;\n                if (i >= len) {\n                    // string ends with a $\n                    break;\n                }\n                let nextChCode = replaceString.charCodeAt(i);\n                if (nextChCode === charCode_1.CharCode.DollarSign) {\n                    // $$ => inserts a \"$\"\n                    result.emitUnchanged(i - 1);\n                    result.emitStatic('$', i + 1);\n                    continue;\n                }\n                if (nextChCode === charCode_1.CharCode.Digit0 || nextChCode === charCode_1.CharCode.Ampersand) {\n                    // $& and $0 => inserts the matched substring.\n                    result.emitUnchanged(i - 1);\n                    result.emitMatchIndex(0, i + 1);\n                    continue;\n                }\n                if (charCode_1.CharCode.Digit1 <= nextChCode && nextChCode <= charCode_1.CharCode.Digit9) {\n                    // $n\n                    let matchIndex = nextChCode - charCode_1.CharCode.Digit0;\n                    // peek next char to probe for $nn\n                    if (i + 1 < len) {\n                        let nextNextChCode = replaceString.charCodeAt(i + 1);\n                        if (charCode_1.CharCode.Digit0 <= nextNextChCode && nextNextChCode <= charCode_1.CharCode.Digit9) {\n                            // $nn\n                            // move to next char\n                            i++;\n                            matchIndex = matchIndex * 10 + (nextNextChCode - charCode_1.CharCode.Digit0);\n                            result.emitUnchanged(i - 2);\n                            result.emitMatchIndex(matchIndex, i + 1);\n                            continue;\n                        }\n                    }\n                    result.emitUnchanged(i - 1);\n                    result.emitMatchIndex(matchIndex, i + 1);\n                    continue;\n                }\n            }\n        }\n        return result.finalize();\n    }\n    exports.parseReplaceString = parseReplaceString;\n});\n",null]}