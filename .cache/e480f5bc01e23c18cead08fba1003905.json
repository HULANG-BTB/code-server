{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/common/extensionsUtils.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/extensions/common/extensionsUtils.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/nls\", \"vs/base/common/event\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/notification/common/notification\"], function (require, exports, arrays, nls_1, event_1, errors_1, lifecycle_1, telemetry_1, extensionManagement_1, lifecycle_2, instantiation_1, extensionManagementUtil_1, notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let KeymapExtensions = class KeymapExtensions {\n        constructor(instantiationService, extensionEnablementService, tipsService, lifecycleService, notificationService, telemetryService) {\n            this.instantiationService = instantiationService;\n            this.extensionEnablementService = extensionEnablementService;\n            this.tipsService = tipsService;\n            this.notificationService = notificationService;\n            this.telemetryService = telemetryService;\n            this.disposables = [];\n            this.disposables.push(lifecycleService.onShutdown(() => this.dispose()), instantiationService.invokeFunction(onExtensionChanged)((identifiers => {\n                Promise.all(identifiers.map(identifier => this.checkForOtherKeymaps(identifier)))\n                    .then(undefined, errors_1.onUnexpectedError);\n            })));\n        }\n        checkForOtherKeymaps(extensionIdentifier) {\n            return this.instantiationService.invokeFunction(getInstalledExtensions).then(extensions => {\n                const keymaps = extensions.filter(extension => isKeymapExtension(this.tipsService, extension));\n                const extension = arrays.first(keymaps, extension => extensionManagementUtil_1.areSameExtensions(extension.identifier, extensionIdentifier));\n                if (extension && extension.globallyEnabled) {\n                    const otherKeymaps = keymaps.filter(extension => !extensionManagementUtil_1.areSameExtensions(extension.identifier, extensionIdentifier) && extension.globallyEnabled);\n                    if (otherKeymaps.length) {\n                        return this.promptForDisablingOtherKeymaps(extension, otherKeymaps);\n                    }\n                }\n                return undefined;\n            });\n        }\n        promptForDisablingOtherKeymaps(newKeymap, oldKeymaps) {\n            const onPrompt = (confirmed) => {\n                const telemetryData = {\n                    newKeymap: newKeymap.identifier,\n                    oldKeymaps: oldKeymaps.map(k => k.identifier),\n                    confirmed\n                };\n                /* __GDPR__\n                    \"disableOtherKeymaps\" : {\n                        \"newKeymap\": { \"${inline}\": [ \"${ExtensionIdentifier}\" ] },\n                        \"oldKeymaps\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                        \"confirmed\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                    }\n                */\n                this.telemetryService.publicLog('disableOtherKeymaps', telemetryData);\n                if (confirmed) {\n                    this.extensionEnablementService.setEnablement(oldKeymaps.map(keymap => keymap.local), extensionManagement_1.EnablementState.Disabled);\n                }\n            };\n            this.notificationService.prompt(notification_1.Severity.Info, nls_1.localize('disableOtherKeymapsConfirmation', \"Disable other keymaps ({0}) to avoid conflicts between keybindings?\", oldKeymaps.map(k => `'${k.local.manifest.displayName}'`).join(', ')), [{\n                    label: nls_1.localize('yes', \"Yes\"),\n                    run: () => onPrompt(true)\n                }, {\n                    label: nls_1.localize('no', \"No\"),\n                    run: () => onPrompt(false)\n                }]);\n        }\n        dispose() {\n            this.disposables = lifecycle_1.dispose(this.disposables);\n        }\n    };\n    KeymapExtensions = __decorate([\n        __param(0, instantiation_1.IInstantiationService),\n        __param(1, extensionManagement_1.IExtensionEnablementService),\n        __param(2, extensionManagement_1.IExtensionTipsService),\n        __param(3, lifecycle_2.ILifecycleService),\n        __param(4, notification_1.INotificationService),\n        __param(5, telemetry_1.ITelemetryService)\n    ], KeymapExtensions);\n    exports.KeymapExtensions = KeymapExtensions;\n    function onExtensionChanged(accessor) {\n        const extensionService = accessor.get(extensionManagement_1.IExtensionManagementService);\n        const extensionEnablementService = accessor.get(extensionManagement_1.IExtensionEnablementService);\n        const onDidInstallExtension = event_1.Event.chain(extensionService.onDidInstallExtension)\n            .filter(e => e.operation === extensionManagement_1.InstallOperation.Install)\n            .event;\n        return event_1.Event.debounce(event_1.Event.any(event_1.Event.chain(event_1.Event.any(onDidInstallExtension, extensionService.onDidUninstallExtension))\n            .map(e => [e.identifier])\n            .event, event_1.Event.map(extensionEnablementService.onEnablementChanged, extensions => extensions.map(e => e.identifier))), (result, identifiers) => {\n            result = result || [];\n            for (const identifier of identifiers) {\n                if (result.some(l => !extensionManagementUtil_1.areSameExtensions(l, identifier))) {\n                    result.push(identifier);\n                }\n            }\n            return result;\n        });\n    }\n    exports.onExtensionChanged = onExtensionChanged;\n    function getInstalledExtensions(accessor) {\n        const extensionService = accessor.get(extensionManagement_1.IExtensionManagementService);\n        const extensionEnablementService = accessor.get(extensionManagement_1.IExtensionEnablementService);\n        return extensionService.getInstalled().then(extensions => {\n            return extensionEnablementService.getDisabledExtensions()\n                .then(disabledExtensions => {\n                return extensions.map(extension => {\n                    return {\n                        identifier: extension.identifier,\n                        local: extension,\n                        globallyEnabled: disabledExtensions.every(disabled => !extensionManagementUtil_1.areSameExtensions(disabled, extension.identifier))\n                    };\n                });\n            });\n        });\n    }\n    exports.getInstalledExtensions = getInstalledExtensions;\n    function isKeymapExtension(tipsService, extension) {\n        const cats = extension.local.manifest.categories;\n        return cats && cats.indexOf('Keymaps') !== -1 || tipsService.getKeymapRecommendations().some(({ extensionId }) => extensionManagementUtil_1.areSameExtensions({ id: extensionId }, extension.local.identifier));\n    }\n    exports.isKeymapExtension = isKeymapExtension;\n});\n",null]}