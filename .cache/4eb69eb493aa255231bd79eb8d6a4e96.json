{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/whitespaceComputer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewLayout/whitespaceComputer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represent whitespaces in between lines and provide fast CRUD management methods.\n     * The whitespaces are sorted ascending by `afterLineNumber`.\n     */\n    class WhitespaceComputer {\n        constructor() {\n            this._heights = [];\n            this._minWidths = [];\n            this._ids = [];\n            this._afterLineNumbers = [];\n            this._ordinals = [];\n            this._prefixSum = [];\n            this._prefixSumValidIndex = -1;\n            this._whitespaceId2Index = {};\n            this._lastWhitespaceId = 0;\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        /**\n         * Find the insertion index for a new value inside a sorted array of values.\n         * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n         */\n        static findInsertionIndex(sortedArray, value, ordinals, valueOrdinal) {\n            let low = 0;\n            let high = sortedArray.length;\n            while (low < high) {\n                let mid = ((low + high) >>> 1);\n                if (value === sortedArray[mid]) {\n                    if (valueOrdinal < ordinals[mid]) {\n                        high = mid;\n                    }\n                    else {\n                        low = mid + 1;\n                    }\n                }\n                else if (value < sortedArray[mid]) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            return low;\n        }\n        /**\n         * Insert a new whitespace of a certain height after a line number.\n         * The whitespace has a \"sticky\" characteristic.\n         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.\n         *\n         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.\n         * @param heightInPx The height of the whitespace, in pixels.\n         * @return An id that can be used later to mutate or delete the whitespace\n         */\n        insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth) {\n            afterLineNumber = afterLineNumber | 0;\n            ordinal = ordinal | 0;\n            heightInPx = heightInPx | 0;\n            minWidth = minWidth | 0;\n            let id = (++this._lastWhitespaceId);\n            let insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, afterLineNumber, this._ordinals, ordinal);\n            this._insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx, minWidth);\n            this._minWidth = -1; /* marker for not being computed */\n            return id;\n        }\n        _insertWhitespaceAtIndex(id, insertIndex, afterLineNumber, ordinal, heightInPx, minWidth) {\n            id = id | 0;\n            insertIndex = insertIndex | 0;\n            afterLineNumber = afterLineNumber | 0;\n            ordinal = ordinal | 0;\n            heightInPx = heightInPx | 0;\n            minWidth = minWidth | 0;\n            this._heights.splice(insertIndex, 0, heightInPx);\n            this._minWidths.splice(insertIndex, 0, minWidth);\n            this._ids.splice(insertIndex, 0, id);\n            this._afterLineNumbers.splice(insertIndex, 0, afterLineNumber);\n            this._ordinals.splice(insertIndex, 0, ordinal);\n            this._prefixSum.splice(insertIndex, 0, 0);\n            let keys = Object.keys(this._whitespaceId2Index);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                let sid = keys[i];\n                let oldIndex = this._whitespaceId2Index[sid];\n                if (oldIndex >= insertIndex) {\n                    this._whitespaceId2Index[sid] = oldIndex + 1;\n                }\n            }\n            this._whitespaceId2Index[id.toString()] = insertIndex;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n        }\n        /**\n         * Change properties associated with a certain whitespace.\n         */\n        changeWhitespace(id, newAfterLineNumber, newHeight) {\n            id = id | 0;\n            newAfterLineNumber = newAfterLineNumber | 0;\n            newHeight = newHeight | 0;\n            let hasChanges = false;\n            hasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;\n            hasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;\n            return hasChanges;\n        }\n        /**\n         * Change the height of an existing whitespace\n         *\n         * @param id The whitespace to change\n         * @param newHeightInPx The new height of the whitespace, in pixels\n         * @return Returns true if the whitespace is found and if the new height is different than the old height\n         */\n        changeWhitespaceHeight(id, newHeightInPx) {\n            id = id | 0;\n            newHeightInPx = newHeightInPx | 0;\n            let sid = id.toString();\n            if (this._whitespaceId2Index.hasOwnProperty(sid)) {\n                let index = this._whitespaceId2Index[sid];\n                if (this._heights[index] !== newHeightInPx) {\n                    this._heights[index] = newHeightInPx;\n                    this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Change the line number after which an existing whitespace flows.\n         *\n         * @param id The whitespace to change\n         * @param newAfterLineNumber The new line number the whitespace will follow\n         * @return Returns true if the whitespace is found and if the new line number is different than the old line number\n         */\n        changeWhitespaceAfterLineNumber(id, newAfterLineNumber) {\n            id = id | 0;\n            newAfterLineNumber = newAfterLineNumber | 0;\n            let sid = id.toString();\n            if (this._whitespaceId2Index.hasOwnProperty(sid)) {\n                let index = this._whitespaceId2Index[sid];\n                if (this._afterLineNumbers[index] !== newAfterLineNumber) {\n                    // `afterLineNumber` changed for this whitespace\n                    // Record old ordinal\n                    let ordinal = this._ordinals[index];\n                    // Record old height\n                    let heightInPx = this._heights[index];\n                    // Record old min width\n                    let minWidth = this._minWidths[index];\n                    // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n                    this.removeWhitespace(id);\n                    // And add it again\n                    let insertionIndex = WhitespaceComputer.findInsertionIndex(this._afterLineNumbers, newAfterLineNumber, this._ordinals, ordinal);\n                    this._insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx, minWidth);\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Remove an existing whitespace.\n         *\n         * @param id The whitespace to remove\n         * @return Returns true if the whitespace is found and it is removed.\n         */\n        removeWhitespace(id) {\n            id = id | 0;\n            let sid = id.toString();\n            if (this._whitespaceId2Index.hasOwnProperty(sid)) {\n                let index = this._whitespaceId2Index[sid];\n                delete this._whitespaceId2Index[sid];\n                this._removeWhitespaceAtIndex(index);\n                this._minWidth = -1; /* marker for not being computed */\n                return true;\n            }\n            return false;\n        }\n        _removeWhitespaceAtIndex(removeIndex) {\n            removeIndex = removeIndex | 0;\n            this._heights.splice(removeIndex, 1);\n            this._minWidths.splice(removeIndex, 1);\n            this._ids.splice(removeIndex, 1);\n            this._afterLineNumbers.splice(removeIndex, 1);\n            this._ordinals.splice(removeIndex, 1);\n            this._prefixSum.splice(removeIndex, 1);\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n            let keys = Object.keys(this._whitespaceId2Index);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                let sid = keys[i];\n                let oldIndex = this._whitespaceId2Index[sid];\n                if (oldIndex >= removeIndex) {\n                    this._whitespaceId2Index[sid] = oldIndex - 1;\n                }\n            }\n        }\n        /**\n         * Notify the computer that lines have been deleted (a continuous zone of lines).\n         * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n         *\n         * @param fromLineNumber The line number at which the deletion started, inclusive\n         * @param toLineNumber The line number at which the deletion ended, inclusive\n         */\n        onLinesDeleted(fromLineNumber, toLineNumber) {\n            fromLineNumber = fromLineNumber | 0;\n            toLineNumber = toLineNumber | 0;\n            for (let i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n                let afterLineNumber = this._afterLineNumbers[i];\n                if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                    // The line this whitespace was after has been deleted\n                    //  => move whitespace to before first deleted line\n                    this._afterLineNumbers[i] = fromLineNumber - 1;\n                }\n                else if (afterLineNumber > toLineNumber) {\n                    // The line this whitespace was after has been moved up\n                    //  => move whitespace up\n                    this._afterLineNumbers[i] -= (toLineNumber - fromLineNumber + 1);\n                }\n            }\n        }\n        /**\n         * Notify the computer that lines have been inserted (a continuous zone of lines).\n         * This gives it a chance to update `afterLineNumber` for whitespaces, giving the \"sticky\" characteristic.\n         *\n         * @param fromLineNumber The line number at which the insertion started, inclusive\n         * @param toLineNumber The line number at which the insertion ended, inclusive.\n         */\n        onLinesInserted(fromLineNumber, toLineNumber) {\n            fromLineNumber = fromLineNumber | 0;\n            toLineNumber = toLineNumber | 0;\n            for (let i = 0, len = this._afterLineNumbers.length; i < len; i++) {\n                let afterLineNumber = this._afterLineNumbers[i];\n                if (fromLineNumber <= afterLineNumber) {\n                    this._afterLineNumbers[i] += (toLineNumber - fromLineNumber + 1);\n                }\n            }\n        }\n        /**\n         * Get the sum of all the whitespaces.\n         */\n        getTotalHeight() {\n            if (this._heights.length === 0) {\n                return 0;\n            }\n            return this.getAccumulatedHeight(this._heights.length - 1);\n        }\n        /**\n         * Return the sum of the heights of the whitespaces at [0..index].\n         * This includes the whitespace at `index`.\n         *\n         * @param index The index of the whitespace.\n         * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n         */\n        getAccumulatedHeight(index) {\n            index = index | 0;\n            let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n            if (startIndex === 0) {\n                this._prefixSum[0] = this._heights[0];\n                startIndex++;\n            }\n            for (let i = startIndex; i <= index; i++) {\n                this._prefixSum[i] = this._prefixSum[i - 1] + this._heights[i];\n            }\n            this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n            return this._prefixSum[index];\n        }\n        /**\n         * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.\n         *\n         * @param lineNumber The line number whitespaces should be before.\n         * @return The sum of the heights of the whitespaces before `lineNumber`.\n         */\n        getAccumulatedHeightBeforeLineNumber(lineNumber) {\n            lineNumber = lineNumber | 0;\n            let lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n            if (lastWhitespaceBeforeLineNumber === -1) {\n                return 0;\n            }\n            return this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n        }\n        _findLastWhitespaceBeforeLineNumber(lineNumber) {\n            lineNumber = lineNumber | 0;\n            // Find the whitespace before line number\n            let afterLineNumbers = this._afterLineNumbers;\n            let low = 0;\n            let high = afterLineNumbers.length - 1;\n            while (low <= high) {\n                let delta = (high - low) | 0;\n                let halfDelta = (delta / 2) | 0;\n                let mid = (low + halfDelta) | 0;\n                if (afterLineNumbers[mid] < lineNumber) {\n                    if (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {\n                        return mid;\n                    }\n                    else {\n                        low = (mid + 1) | 0;\n                    }\n                }\n                else {\n                    high = (mid - 1) | 0;\n                }\n            }\n            return -1;\n        }\n        _findFirstWhitespaceAfterLineNumber(lineNumber) {\n            lineNumber = lineNumber | 0;\n            let lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n            let firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n            if (firstWhitespaceAfterLineNumber < this._heights.length) {\n                return firstWhitespaceAfterLineNumber;\n            }\n            return -1;\n        }\n        /**\n         * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n         * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n         */\n        getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n            lineNumber = lineNumber | 0;\n            return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n        }\n        /**\n         * The number of whitespaces.\n         */\n        getCount() {\n            return this._heights.length;\n        }\n        /**\n         * The maximum min width for all whitespaces.\n         */\n        getMinWidth() {\n            if (this._minWidth === -1) {\n                let minWidth = 0;\n                for (let i = 0, len = this._minWidths.length; i < len; i++) {\n                    minWidth = Math.max(minWidth, this._minWidths[i]);\n                }\n                this._minWidth = minWidth;\n            }\n            return this._minWidth;\n        }\n        /**\n         * Get the `afterLineNumber` for whitespace at index `index`.\n         *\n         * @param index The index of the whitespace.\n         * @return `afterLineNumber` of whitespace at `index`.\n         */\n        getAfterLineNumberForWhitespaceIndex(index) {\n            index = index | 0;\n            return this._afterLineNumbers[index];\n        }\n        /**\n         * Get the `id` for whitespace at index `index`.\n         *\n         * @param index The index of the whitespace.\n         * @return `id` of whitespace at `index`.\n         */\n        getIdForWhitespaceIndex(index) {\n            index = index | 0;\n            return this._ids[index];\n        }\n        /**\n         * Get the `height` for whitespace at index `index`.\n         *\n         * @param index The index of the whitespace.\n         * @return `height` of whitespace at `index`.\n         */\n        getHeightForWhitespaceIndex(index) {\n            index = index | 0;\n            return this._heights[index];\n        }\n        /**\n         * Get all whitespaces.\n         */\n        getWhitespaces(deviceLineHeight) {\n            deviceLineHeight = deviceLineHeight | 0;\n            let result = [];\n            for (let i = 0; i < this._heights.length; i++) {\n                result.push({\n                    id: this._ids[i],\n                    afterLineNumber: this._afterLineNumbers[i],\n                    heightInLines: this._heights[i] / deviceLineHeight\n                });\n            }\n            return result;\n        }\n    }\n    exports.WhitespaceComputer = WhitespaceComputer;\n});\n",null]}