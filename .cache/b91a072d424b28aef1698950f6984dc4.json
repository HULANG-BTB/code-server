{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/browser/controller/textAreaInput.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/browser/controller/textAreaInput.ts","mtime":1555846338032},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar browser = require(\"vs/base/browser/browser\");\nvar dom = require(\"vs/base/browser/dom\");\nvar async_1 = require(\"vs/base/common/async\");\nvar event_1 = require(\"vs/base/common/event\");\nvar keyCodes_1 = require(\"vs/base/common/keyCodes\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar platform = require(\"vs/base/common/platform\");\nvar strings = require(\"vs/base/common/strings\");\nvar textAreaState_1 = require(\"vs/editor/browser/controller/textAreaState\");\nvar selection_1 = require(\"vs/editor/common/core/selection\");\nexports.CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\nvar ReadFromTextArea;\n(function (ReadFromTextArea) {\n    ReadFromTextArea[ReadFromTextArea[\"Type\"] = 0] = \"Type\";\n    ReadFromTextArea[ReadFromTextArea[\"Paste\"] = 1] = \"Paste\";\n})(ReadFromTextArea || (ReadFromTextArea = {}));\nvar TextAreaInputEventType;\n(function (TextAreaInputEventType) {\n    TextAreaInputEventType[TextAreaInputEventType[\"none\"] = 0] = \"none\";\n    TextAreaInputEventType[TextAreaInputEventType[\"compositionstart\"] = 1] = \"compositionstart\";\n    TextAreaInputEventType[TextAreaInputEventType[\"compositionupdate\"] = 2] = \"compositionupdate\";\n    TextAreaInputEventType[TextAreaInputEventType[\"compositionend\"] = 3] = \"compositionend\";\n    TextAreaInputEventType[TextAreaInputEventType[\"input\"] = 4] = \"input\";\n    TextAreaInputEventType[TextAreaInputEventType[\"cut\"] = 5] = \"cut\";\n    TextAreaInputEventType[TextAreaInputEventType[\"copy\"] = 6] = \"copy\";\n    TextAreaInputEventType[TextAreaInputEventType[\"paste\"] = 7] = \"paste\";\n    TextAreaInputEventType[TextAreaInputEventType[\"focus\"] = 8] = \"focus\";\n    TextAreaInputEventType[TextAreaInputEventType[\"blur\"] = 9] = \"blur\";\n})(TextAreaInputEventType || (TextAreaInputEventType = {}));\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nvar TextAreaInput = /** @class */ (function (_super) {\n    tslib_1.__extends(TextAreaInput, _super);\n    function TextAreaInput(host, textArea) {\n        var _this = _super.call(this) || this;\n        _this._onFocus = _this._register(new event_1.Emitter());\n        _this.onFocus = _this._onFocus.event;\n        _this._onBlur = _this._register(new event_1.Emitter());\n        _this.onBlur = _this._onBlur.event;\n        _this._onKeyDown = _this._register(new event_1.Emitter());\n        _this.onKeyDown = _this._onKeyDown.event;\n        _this._onKeyUp = _this._register(new event_1.Emitter());\n        _this.onKeyUp = _this._onKeyUp.event;\n        _this._onCut = _this._register(new event_1.Emitter());\n        _this.onCut = _this._onCut.event;\n        _this._onPaste = _this._register(new event_1.Emitter());\n        _this.onPaste = _this._onPaste.event;\n        _this._onType = _this._register(new event_1.Emitter());\n        _this.onType = _this._onType.event;\n        _this._onCompositionStart = _this._register(new event_1.Emitter());\n        _this.onCompositionStart = _this._onCompositionStart.event;\n        _this._onCompositionUpdate = _this._register(new event_1.Emitter());\n        _this.onCompositionUpdate = _this._onCompositionUpdate.event;\n        _this._onCompositionEnd = _this._register(new event_1.Emitter());\n        _this.onCompositionEnd = _this._onCompositionEnd.event;\n        _this._onSelectionChangeRequest = _this._register(new event_1.Emitter());\n        _this.onSelectionChangeRequest = _this._onSelectionChangeRequest.event;\n        _this._host = host;\n        _this._textArea = _this._register(new TextAreaWrapper(textArea));\n        _this._lastTextAreaEvent = TextAreaInputEventType.none;\n        _this._asyncTriggerCut = _this._register(new async_1.RunOnceScheduler(function () { return _this._onCut.fire(); }, 0));\n        _this._textAreaState = textAreaState_1.TextAreaState.EMPTY;\n        _this.writeScreenReaderContent('ctor');\n        _this._hasFocus = false;\n        _this._isDoingComposition = false;\n        _this._nextCommand = ReadFromTextArea.Type;\n        _this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', function (e) {\n            if (_this._isDoingComposition &&\n                (e.keyCode === keyCodes_1.KeyCode.KEY_IN_COMPOSITION || e.keyCode === keyCodes_1.KeyCode.Backspace)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(keyCodes_1.KeyCode.Escape)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            _this._onKeyDown.fire(e);\n        }));\n        _this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', function (e) {\n            _this._onKeyUp.fire(e);\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', function (e) {\n            _this._lastTextAreaEvent = TextAreaInputEventType.compositionstart;\n            if (_this._isDoingComposition) {\n                return;\n            }\n            _this._isDoingComposition = true;\n            // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.\n            if (!browser.isEdgeOrIE) {\n                _this._setAndWriteTextAreaState('compositionstart', textAreaState_1.TextAreaState.EMPTY);\n            }\n            _this._onCompositionStart.fire();\n        }));\n        /**\n         * Deduce the typed input from a text area's value and the last observed state.\n         */\n        var deduceInputFromTextAreaValue = function (couldBeEmojiInput, couldBeTypingAtOffset0) {\n            var oldState = _this._textAreaState;\n            var newState = textAreaState_1.TextAreaState.readFromTextArea(_this._textArea);\n            return [newState, textAreaState_1.TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput, couldBeTypingAtOffset0)];\n        };\n        /**\n         * Deduce the composition input from a string.\n         */\n        var deduceComposition = function (text) {\n            var oldState = _this._textAreaState;\n            var newState = textAreaState_1.TextAreaState.selectedText(text);\n            var typeInput = {\n                text: newState.value,\n                replaceCharCnt: oldState.selectionEnd - oldState.selectionStart\n            };\n            return [newState, typeInput];\n        };\n        var compositionDataInValid = function (locale) {\n            // https://github.com/Microsoft/monaco-editor/issues/339\n            // Multi-part Japanese compositions reset cursor in Edge/IE, Chinese and Korean IME don't have this issue.\n            // The reason that we can't use this path for all CJK IME is IE and Edge behave differently when handling Korean IME,\n            // which breaks this path of code.\n            if (browser.isEdgeOrIE && locale === 'ja') {\n                return true;\n            }\n            // https://github.com/Microsoft/monaco-editor/issues/545\n            // On IE11, we can't trust composition data when typing Chinese as IE11 doesn't emit correct\n            // events when users type numbers in IME.\n            // Chinese: zh-Hans-CN, zh-Hans-SG, zh-Hant-TW, zh-Hant-HK\n            if (browser.isIE && locale.indexOf('zh-Han') === 0) {\n                return true;\n            }\n            return false;\n        };\n        _this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', function (e) {\n            _this._lastTextAreaEvent = TextAreaInputEventType.compositionupdate;\n            if (compositionDataInValid(e.locale)) {\n                var _a = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ false, /*couldBeTypingAtOffset0*/ false), newState_1 = _a[0], typeInput_1 = _a[1];\n                _this._textAreaState = newState_1;\n                _this._onType.fire(typeInput_1);\n                _this._onCompositionUpdate.fire(e);\n                return;\n            }\n            var _b = deduceComposition(e.data), newState = _b[0], typeInput = _b[1];\n            _this._textAreaState = newState;\n            _this._onType.fire(typeInput);\n            _this._onCompositionUpdate.fire(e);\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', function (e) {\n            _this._lastTextAreaEvent = TextAreaInputEventType.compositionend;\n            if (compositionDataInValid(e.locale)) {\n                // https://github.com/Microsoft/monaco-editor/issues/339\n                var _a = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ false, /*couldBeTypingAtOffset0*/ false), newState = _a[0], typeInput = _a[1];\n                _this._textAreaState = newState;\n                _this._onType.fire(typeInput);\n            }\n            else {\n                var _b = deduceComposition(e.data), newState = _b[0], typeInput = _b[1];\n                _this._textAreaState = newState;\n                _this._onType.fire(typeInput);\n            }\n            // Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)\n            // we cannot assume the text at the end consists only of the composited text\n            if (browser.isEdgeOrIE || browser.isChrome) {\n                _this._textAreaState = textAreaState_1.TextAreaState.readFromTextArea(_this._textArea);\n            }\n            if (!_this._isDoingComposition) {\n                return;\n            }\n            _this._isDoingComposition = false;\n            _this._onCompositionEnd.fire();\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'input', function () {\n            // We want to find out if this is the first `input` after a `focus`.\n            var previousEventWasFocus = (_this._lastTextAreaEvent === TextAreaInputEventType.focus);\n            _this._lastTextAreaEvent = TextAreaInputEventType.input;\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            _this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (_this._isDoingComposition) {\n                return;\n            }\n            var _a = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ browser.isMacintosh, /*couldBeTypingAtOffset0*/ previousEventWasFocus && browser.isMacintosh), newState = _a[0], typeInput = _a[1];\n            if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n                // Ignore invalid input but keep it around for next time\n                return;\n            }\n            _this._textAreaState = newState;\n            if (_this._nextCommand === ReadFromTextArea.Type) {\n                if (typeInput.text !== '') {\n                    _this._onType.fire(typeInput);\n                }\n            }\n            else {\n                if (typeInput.text !== '') {\n                    _this._onPaste.fire({\n                        text: typeInput.text\n                    });\n                }\n                _this._nextCommand = ReadFromTextArea.Type;\n            }\n        }));\n        // --- Clipboard operations\n        _this._register(dom.addDisposableListener(textArea.domNode, 'cut', function (e) {\n            _this._lastTextAreaEvent = TextAreaInputEventType.cut;\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            _this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            _this._ensureClipboardGetsEditorSelection(e);\n            _this._asyncTriggerCut.schedule();\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'copy', function (e) {\n            _this._lastTextAreaEvent = TextAreaInputEventType.copy;\n            _this._ensureClipboardGetsEditorSelection(e);\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'paste', function (e) {\n            _this._lastTextAreaEvent = TextAreaInputEventType.paste;\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            _this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            if (ClipboardEventUtils.canUseTextData(e)) {\n                var pastePlainText = ClipboardEventUtils.getTextData(e);\n                if (pastePlainText !== '') {\n                    _this._onPaste.fire({\n                        text: pastePlainText\n                    });\n                }\n            }\n            else {\n                if (_this._textArea.getSelectionStart() !== _this._textArea.getSelectionEnd()) {\n                    // Clean up the textarea, to get a clean paste\n                    _this._setAndWriteTextAreaState('paste', textAreaState_1.TextAreaState.EMPTY);\n                }\n                _this._nextCommand = ReadFromTextArea.Paste;\n            }\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'focus', function () {\n            _this._lastTextAreaEvent = TextAreaInputEventType.focus;\n            _this._setHasFocus(true);\n        }));\n        _this._register(dom.addDisposableListener(textArea.domNode, 'blur', function () {\n            _this._lastTextAreaEvent = TextAreaInputEventType.blur;\n            _this._setHasFocus(false);\n        }));\n        return _this;\n    }\n    TextAreaInput.prototype._installSelectionChangeListener = function () {\n        // See https://github.com/Microsoft/vscode/issues/27216\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        var _this = this;\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        var previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(document, 'selectionchange', function (e) {\n            if (!_this._hasFocus) {\n                return;\n            }\n            if (_this._isDoingComposition) {\n                return;\n            }\n            if (!browser.isChrome || !platform.isWindows) {\n                // Support only for Chrome on Windows until testing happens on other browsers + OS configurations\n                return;\n            }\n            var now = Date.now();\n            var delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            var delta2 = now - _this._textArea.getIgnoreSelectionChangeTime();\n            _this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!_this._textAreaState.selectionStartPosition || !_this._textAreaState.selectionEndPosition) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            var newValue = _this._textArea.getValue();\n            if (_this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            var newSelectionStart = _this._textArea.getSelectionStart();\n            var newSelectionEnd = _this._textArea.getSelectionEnd();\n            if (_this._textAreaState.selectionStart === newSelectionStart && _this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            var _newSelectionStartPosition = _this._textAreaState.deduceEditorPosition(newSelectionStart);\n            var newSelectionStartPosition = _this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            var _newSelectionEndPosition = _this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            var newSelectionEndPosition = _this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            var newSelection = new selection_1.Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            _this._onSelectionChangeRequest.fire(newSelection);\n        });\n    };\n    TextAreaInput.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    };\n    TextAreaInput.prototype.focusTextArea = function () {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n    };\n    TextAreaInput.prototype.isFocused = function () {\n        return this._hasFocus;\n    };\n    TextAreaInput.prototype._setHasFocus = function (newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            if (browser.isEdge) {\n                // Edge has a bug where setting the selection range while the focus event\n                // is dispatching doesn't work. To reproduce, \"tab into\" the editor.\n                this._setAndWriteTextAreaState('focusgain', textAreaState_1.TextAreaState.EMPTY);\n            }\n            else {\n                this.writeScreenReaderContent('focusgain');\n            }\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    };\n    TextAreaInput.prototype._setAndWriteTextAreaState = function (reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    };\n    TextAreaInput.prototype.writeScreenReaderContent = function (reason) {\n        if (this._isDoingComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    };\n    TextAreaInput.prototype._ensureClipboardGetsEditorSelection = function (e) {\n        var copyPlainText = this._host.getPlainTextToCopy();\n        if (!ClipboardEventUtils.canUseTextData(e)) {\n            // Looks like an old browser. The strategy is to place the text\n            // we'd like to be copied to the clipboard in the textarea and select it.\n            this._setAndWriteTextAreaState('copy or cut', textAreaState_1.TextAreaState.selectedText(copyPlainText));\n            return;\n        }\n        var copyHTML = null;\n        if (browser.hasClipboardSupport() && (copyPlainText.length < 65536 || exports.CopyOptions.forceCopyWithSyntaxHighlighting)) {\n            copyHTML = this._host.getHTMLToCopy();\n        }\n        ClipboardEventUtils.setTextData(e, copyPlainText, copyHTML);\n    };\n    return TextAreaInput;\n}(lifecycle_1.Disposable));\nexports.TextAreaInput = TextAreaInput;\nvar ClipboardEventUtils = /** @class */ (function () {\n    function ClipboardEventUtils() {\n    }\n    ClipboardEventUtils.canUseTextData = function (e) {\n        if (e.clipboardData) {\n            return true;\n        }\n        if (window.clipboardData) {\n            return true;\n        }\n        return false;\n    };\n    ClipboardEventUtils.getTextData = function (e) {\n        if (e.clipboardData) {\n            e.preventDefault();\n            return e.clipboardData.getData('text/plain');\n        }\n        if (window.clipboardData) {\n            e.preventDefault();\n            return window.clipboardData.getData('Text');\n        }\n        throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n    };\n    ClipboardEventUtils.setTextData = function (e, text, richText) {\n        if (e.clipboardData) {\n            e.clipboardData.setData('text/plain', text);\n            if (richText !== null) {\n                e.clipboardData.setData('text/html', richText);\n            }\n            e.preventDefault();\n            return;\n        }\n        if (window.clipboardData) {\n            window.clipboardData.setData('Text', text);\n            e.preventDefault();\n            return;\n        }\n        throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n    };\n    return ClipboardEventUtils;\n}());\nvar TextAreaWrapper = /** @class */ (function (_super) {\n    tslib_1.__extends(TextAreaWrapper, _super);\n    function TextAreaWrapper(_textArea) {\n        var _this = _super.call(this) || this;\n        _this._actual = _textArea;\n        _this._ignoreSelectionChangeTime = 0;\n        return _this;\n    }\n    TextAreaWrapper.prototype.setIgnoreSelectionChangeTime = function (reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    };\n    TextAreaWrapper.prototype.getIgnoreSelectionChangeTime = function () {\n        return this._ignoreSelectionChangeTime;\n    };\n    TextAreaWrapper.prototype.resetSelectionChangeTime = function () {\n        this._ignoreSelectionChangeTime = 0;\n    };\n    TextAreaWrapper.prototype.getValue = function () {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.domNode.value;\n    };\n    TextAreaWrapper.prototype.setValue = function (reason, value) {\n        var textArea = this._actual.domNode;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    };\n    TextAreaWrapper.prototype.getSelectionStart = function () {\n        return this._actual.domNode.selectionStart;\n    };\n    TextAreaWrapper.prototype.getSelectionEnd = function () {\n        return this._actual.domNode.selectionEnd;\n    };\n    TextAreaWrapper.prototype.setSelectionRange = function (reason, selectionStart, selectionEnd) {\n        var textArea = this._actual.domNode;\n        var currentIsFocused = (document.activeElement === textArea);\n        var currentSelectionStart = textArea.selectionStart;\n        var currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/Microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            var scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    };\n    return TextAreaWrapper;\n}(lifecycle_1.Disposable));\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/browser/controller/textAreaInput.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/browser/controller/textAreaInput.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from 'vs/base/browser/browser';\nimport * as dom from 'vs/base/browser/dom';\nimport { FastDomNode } from 'vs/base/browser/fastDomNode';\nimport { IKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport * as platform from 'vs/base/common/platform';\nimport * as strings from 'vs/base/common/strings';\nimport { ITextAreaWrapper, ITypeData, TextAreaState } from 'vs/editor/browser/controller/textAreaState';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Selection } from 'vs/editor/common/core/selection';\n\nexport interface ICompositionData {\n\tdata: string;\n}\n\nexport const CopyOptions = {\n\tforceCopyWithSyntaxHighlighting: false\n};\n\nconst enum ReadFromTextArea {\n\tType,\n\tPaste\n}\n\nexport interface IPasteData {\n\ttext: string;\n}\n\nexport interface ITextAreaInputHost {\n\tgetPlainTextToCopy(): string;\n\tgetHTMLToCopy(): string | null;\n\tgetScreenReaderContent(currentState: TextAreaState): TextAreaState;\n\tdeduceModelPosition(viewAnchorPosition: Position, deltaOffset: number, lineFeedCnt: number): Position;\n}\n\nconst enum TextAreaInputEventType {\n\tnone,\n\tcompositionstart,\n\tcompositionupdate,\n\tcompositionend,\n\tinput,\n\tcut,\n\tcopy,\n\tpaste,\n\tfocus,\n\tblur\n}\n\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n\n\tprivate _onFocus = this._register(new Emitter<void>());\n\tpublic readonly onFocus: Event<void> = this._onFocus.event;\n\n\tprivate _onBlur = this._register(new Emitter<void>());\n\tpublic readonly onBlur: Event<void> = this._onBlur.event;\n\n\tprivate _onKeyDown = this._register(new Emitter<IKeyboardEvent>());\n\tpublic readonly onKeyDown: Event<IKeyboardEvent> = this._onKeyDown.event;\n\n\tprivate _onKeyUp = this._register(new Emitter<IKeyboardEvent>());\n\tpublic readonly onKeyUp: Event<IKeyboardEvent> = this._onKeyUp.event;\n\n\tprivate _onCut = this._register(new Emitter<void>());\n\tpublic readonly onCut: Event<void> = this._onCut.event;\n\n\tprivate _onPaste = this._register(new Emitter<IPasteData>());\n\tpublic readonly onPaste: Event<IPasteData> = this._onPaste.event;\n\n\tprivate _onType = this._register(new Emitter<ITypeData>());\n\tpublic readonly onType: Event<ITypeData> = this._onType.event;\n\n\tprivate _onCompositionStart = this._register(new Emitter<void>());\n\tpublic readonly onCompositionStart: Event<void> = this._onCompositionStart.event;\n\n\tprivate _onCompositionUpdate = this._register(new Emitter<ICompositionData>());\n\tpublic readonly onCompositionUpdate: Event<ICompositionData> = this._onCompositionUpdate.event;\n\n\tprivate _onCompositionEnd = this._register(new Emitter<void>());\n\tpublic readonly onCompositionEnd: Event<void> = this._onCompositionEnd.event;\n\n\tprivate _onSelectionChangeRequest = this._register(new Emitter<Selection>());\n\tpublic readonly onSelectionChangeRequest: Event<Selection> = this._onSelectionChangeRequest.event;\n\n\t// ---\n\n\tprivate readonly _host: ITextAreaInputHost;\n\tprivate readonly _textArea: TextAreaWrapper;\n\tprivate _lastTextAreaEvent: TextAreaInputEventType;\n\tprivate readonly _asyncTriggerCut: RunOnceScheduler;\n\n\tprivate _textAreaState: TextAreaState;\n\tprivate _selectionChangeListener: IDisposable | null;\n\n\tprivate _hasFocus: boolean;\n\tprivate _isDoingComposition: boolean;\n\tprivate _nextCommand: ReadFromTextArea;\n\n\tconstructor(host: ITextAreaInputHost, textArea: FastDomNode<HTMLTextAreaElement>) {\n\t\tsuper();\n\t\tthis._host = host;\n\t\tthis._textArea = this._register(new TextAreaWrapper(textArea));\n\t\tthis._lastTextAreaEvent = TextAreaInputEventType.none;\n\t\tthis._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n\n\t\tthis._textAreaState = TextAreaState.EMPTY;\n\t\tthis.writeScreenReaderContent('ctor');\n\n\t\tthis._hasFocus = false;\n\t\tthis._isDoingComposition = false;\n\t\tthis._nextCommand = ReadFromTextArea.Type;\n\n\t\tthis._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', (e: IKeyboardEvent) => {\n\t\t\tif (this._isDoingComposition &&\n\t\t\t\t(e.keyCode === KeyCode.KEY_IN_COMPOSITION || e.keyCode === KeyCode.Backspace)) {\n\t\t\t\t// Stop propagation for keyDown events if the IME is processing key input\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\n\t\t\tif (e.equals(KeyCode.Escape)) {\n\t\t\t\t// Prevent default always for `Esc`, otherwise it will generate a keypress\n\t\t\t\t// See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t\tthis._onKeyDown.fire(e);\n\t\t}));\n\n\t\tthis._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', (e: IKeyboardEvent) => {\n\t\t\tthis._onKeyUp.fire(e);\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', (e: CompositionEvent) => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.compositionstart;\n\n\t\t\tif (this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._isDoingComposition = true;\n\n\t\t\t// In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.\n\t\t\tif (!browser.isEdgeOrIE) {\n\t\t\t\tthis._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n\t\t\t}\n\n\t\t\tthis._onCompositionStart.fire();\n\t\t}));\n\n\t\t/**\n\t\t * Deduce the typed input from a text area's value and the last observed state.\n\t\t */\n\t\tconst deduceInputFromTextAreaValue = (couldBeEmojiInput: boolean, couldBeTypingAtOffset0: boolean): [TextAreaState, ITypeData] => {\n\t\t\tconst oldState = this._textAreaState;\n\t\t\tconst newState = TextAreaState.readFromTextArea(this._textArea);\n\t\t\treturn [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput, couldBeTypingAtOffset0)];\n\t\t};\n\n\t\t/**\n\t\t * Deduce the composition input from a string.\n\t\t */\n\t\tconst deduceComposition = (text: string): [TextAreaState, ITypeData] => {\n\t\t\tconst oldState = this._textAreaState;\n\t\t\tconst newState = TextAreaState.selectedText(text);\n\t\t\tconst typeInput: ITypeData = {\n\t\t\t\ttext: newState.value,\n\t\t\t\treplaceCharCnt: oldState.selectionEnd - oldState.selectionStart\n\t\t\t};\n\t\t\treturn [newState, typeInput];\n\t\t};\n\n\t\tconst compositionDataInValid = (locale: string): boolean => {\n\t\t\t// https://github.com/Microsoft/monaco-editor/issues/339\n\t\t\t// Multi-part Japanese compositions reset cursor in Edge/IE, Chinese and Korean IME don't have this issue.\n\t\t\t// The reason that we can't use this path for all CJK IME is IE and Edge behave differently when handling Korean IME,\n\t\t\t// which breaks this path of code.\n\t\t\tif (browser.isEdgeOrIE && locale === 'ja') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// https://github.com/Microsoft/monaco-editor/issues/545\n\t\t\t// On IE11, we can't trust composition data when typing Chinese as IE11 doesn't emit correct\n\t\t\t// events when users type numbers in IME.\n\t\t\t// Chinese: zh-Hans-CN, zh-Hans-SG, zh-Hant-TW, zh-Hant-HK\n\t\t\tif (browser.isIE && locale.indexOf('zh-Han') === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', (e: CompositionEvent) => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.compositionupdate;\n\n\t\t\tif (compositionDataInValid(e.locale)) {\n\t\t\t\tconst [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/false, /*couldBeTypingAtOffset0*/false);\n\t\t\t\tthis._textAreaState = newState;\n\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t\tthis._onCompositionUpdate.fire(e);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [newState, typeInput] = deduceComposition(e.data);\n\t\t\tthis._textAreaState = newState;\n\t\t\tthis._onType.fire(typeInput);\n\t\t\tthis._onCompositionUpdate.fire(e);\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'compositionend', (e: CompositionEvent) => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.compositionend;\n\n\t\t\tif (compositionDataInValid(e.locale)) {\n\t\t\t\t// https://github.com/Microsoft/monaco-editor/issues/339\n\t\t\t\tconst [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/false, /*couldBeTypingAtOffset0*/false);\n\t\t\t\tthis._textAreaState = newState;\n\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t} else {\n\t\t\t\tconst [newState, typeInput] = deduceComposition(e.data);\n\t\t\t\tthis._textAreaState = newState;\n\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t}\n\n\t\t\t// Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)\n\t\t\t// we cannot assume the text at the end consists only of the composited text\n\t\t\tif (browser.isEdgeOrIE || browser.isChrome) {\n\t\t\t\tthis._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n\t\t\t}\n\n\t\t\tif (!this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._isDoingComposition = false;\n\n\t\t\tthis._onCompositionEnd.fire();\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\n\t\t\t// We want to find out if this is the first `input` after a `focus`.\n\t\t\tconst previousEventWasFocus = (this._lastTextAreaEvent === TextAreaInputEventType.focus);\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.input;\n\n\t\t\t// Pretend here we touched the text area, as the `input` event will most likely\n\t\t\t// result in a `selectionchange` event which we want to ignore\n\t\t\tthis._textArea.setIgnoreSelectionChangeTime('received input event');\n\n\t\t\tif (this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/browser.isMacintosh, /*couldBeTypingAtOffset0*/previousEventWasFocus && browser.isMacintosh);\n\t\t\tif (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n\t\t\t\t// Ignore invalid input but keep it around for next time\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._textAreaState = newState;\n\t\t\tif (this._nextCommand === ReadFromTextArea.Type) {\n\t\t\t\tif (typeInput.text !== '') {\n\t\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (typeInput.text !== '') {\n\t\t\t\t\tthis._onPaste.fire({\n\t\t\t\t\t\ttext: typeInput.text\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._nextCommand = ReadFromTextArea.Type;\n\t\t\t}\n\t\t}));\n\n\t\t// --- Clipboard operations\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'cut', (e: ClipboardEvent) => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.cut;\n\n\t\t\t// Pretend here we touched the text area, as the `cut` event will most likely\n\t\t\t// result in a `selectionchange` event which we want to ignore\n\t\t\tthis._textArea.setIgnoreSelectionChangeTime('received cut event');\n\n\t\t\tthis._ensureClipboardGetsEditorSelection(e);\n\t\t\tthis._asyncTriggerCut.schedule();\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'copy', (e: ClipboardEvent) => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.copy;\n\n\t\t\tthis._ensureClipboardGetsEditorSelection(e);\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'paste', (e: ClipboardEvent) => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.paste;\n\n\t\t\t// Pretend here we touched the text area, as the `paste` event will most likely\n\t\t\t// result in a `selectionchange` event which we want to ignore\n\t\t\tthis._textArea.setIgnoreSelectionChangeTime('received paste event');\n\n\t\t\tif (ClipboardEventUtils.canUseTextData(e)) {\n\t\t\t\tconst pastePlainText = ClipboardEventUtils.getTextData(e);\n\t\t\t\tif (pastePlainText !== '') {\n\t\t\t\t\tthis._onPaste.fire({\n\t\t\t\t\t\ttext: pastePlainText\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\n\t\t\t\t\t// Clean up the textarea, to get a clean paste\n\t\t\t\t\tthis._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n\t\t\t\t}\n\t\t\t\tthis._nextCommand = ReadFromTextArea.Paste;\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.focus;\n\t\t\tthis._setHasFocus(true);\n\t\t}));\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\n\t\t\tthis._lastTextAreaEvent = TextAreaInputEventType.blur;\n\t\t\tthis._setHasFocus(false);\n\t\t}));\n\t}\n\n\tprivate _installSelectionChangeListener(): IDisposable {\n\t\t// See https://github.com/Microsoft/vscode/issues/27216\n\t\t// When using a Braille display, it is possible for users to reposition the\n\t\t// system caret. This is reflected in Chrome as a `selectionchange` event.\n\t\t//\n\t\t// The `selectionchange` event appears to be emitted under numerous other circumstances,\n\t\t// so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n\t\t// using a Braille display from all the other cases.\n\t\t//\n\t\t// The problems with the `selectionchange` event are:\n\t\t//  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n\t\t//  * the event is emitted when the selection is changed in the textarea programatically -- textarea.setSelectionRange(...)\n\t\t//  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n\t\t//  * the event is emitted when tabbing into the textarea\n\t\t//  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n\t\t//  * the event sometimes comes in bursts for a single logical textarea operation\n\n\t\t// `selectionchange` events often come multiple times for a single logical change\n\t\t// so throttle multiple `selectionchange` events that burst in a short period of time.\n\t\tlet previousSelectionChangeEventTime = 0;\n\t\treturn dom.addDisposableListener(document, 'selectionchange', (e) => {\n\t\t\tif (!this._hasFocus) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!browser.isChrome || !platform.isWindows) {\n\t\t\t\t// Support only for Chrome on Windows until testing happens on other browsers + OS configurations\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst now = Date.now();\n\n\t\t\tconst delta1 = now - previousSelectionChangeEventTime;\n\t\t\tpreviousSelectionChangeEventTime = now;\n\t\t\tif (delta1 < 5) {\n\t\t\t\t// received another `selectionchange` event within 5ms of the previous `selectionchange` event\n\t\t\t\t// => ignore it\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n\t\t\tthis._textArea.resetSelectionChangeTime();\n\t\t\tif (delta2 < 100) {\n\t\t\t\t// received a `selectionchange` event within 100ms since we touched the textarea\n\t\t\t\t// => ignore it, since we caused it\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n\t\t\t\t// Cannot correlate a position in the textarea with a position in the editor...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newValue = this._textArea.getValue();\n\t\t\tif (this._textAreaState.value !== newValue) {\n\t\t\t\t// Cannot correlate a position in the textarea with a position in the editor...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newSelectionStart = this._textArea.getSelectionStart();\n\t\t\tconst newSelectionEnd = this._textArea.getSelectionEnd();\n\t\t\tif (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n\t\t\t\t// Nothing to do...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n\t\t\tconst newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0]!, _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n\n\t\t\tconst _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n\t\t\tconst newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0]!, _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n\n\t\t\tconst newSelection = new Selection(\n\t\t\t\tnewSelectionStartPosition.lineNumber, newSelectionStartPosition.column,\n\t\t\t\tnewSelectionEndPosition.lineNumber, newSelectionEndPosition.column\n\t\t\t);\n\n\t\t\tthis._onSelectionChangeRequest.fire(newSelection);\n\t\t});\n\t}\n\n\tpublic dispose(): void {\n\t\tsuper.dispose();\n\t\tif (this._selectionChangeListener) {\n\t\t\tthis._selectionChangeListener.dispose();\n\t\t\tthis._selectionChangeListener = null;\n\t\t}\n\t}\n\n\tpublic focusTextArea(): void {\n\t\t// Setting this._hasFocus and writing the screen reader content\n\t\t// will result in a focus() and setSelectionRange() in the textarea\n\t\tthis._setHasFocus(true);\n\t}\n\n\tpublic isFocused(): boolean {\n\t\treturn this._hasFocus;\n\t}\n\n\tprivate _setHasFocus(newHasFocus: boolean): void {\n\t\tif (this._hasFocus === newHasFocus) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._hasFocus = newHasFocus;\n\n\t\tif (this._selectionChangeListener) {\n\t\t\tthis._selectionChangeListener.dispose();\n\t\t\tthis._selectionChangeListener = null;\n\t\t}\n\t\tif (this._hasFocus) {\n\t\t\tthis._selectionChangeListener = this._installSelectionChangeListener();\n\t\t}\n\n\t\tif (this._hasFocus) {\n\t\t\tif (browser.isEdge) {\n\t\t\t\t// Edge has a bug where setting the selection range while the focus event\n\t\t\t\t// is dispatching doesn't work. To reproduce, \"tab into\" the editor.\n\t\t\t\tthis._setAndWriteTextAreaState('focusgain', TextAreaState.EMPTY);\n\t\t\t} else {\n\t\t\t\tthis.writeScreenReaderContent('focusgain');\n\t\t\t}\n\t\t}\n\n\t\tif (this._hasFocus) {\n\t\t\tthis._onFocus.fire();\n\t\t} else {\n\t\t\tthis._onBlur.fire();\n\t\t}\n\t}\n\n\tprivate _setAndWriteTextAreaState(reason: string, textAreaState: TextAreaState): void {\n\t\tif (!this._hasFocus) {\n\t\t\ttextAreaState = textAreaState.collapseSelection();\n\t\t}\n\n\t\ttextAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n\t\tthis._textAreaState = textAreaState;\n\t}\n\n\tpublic writeScreenReaderContent(reason: string): void {\n\t\tif (this._isDoingComposition) {\n\t\t\t// Do not write to the text area when doing composition\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n\t}\n\n\tprivate _ensureClipboardGetsEditorSelection(e: ClipboardEvent): void {\n\t\tconst copyPlainText = this._host.getPlainTextToCopy();\n\t\tif (!ClipboardEventUtils.canUseTextData(e)) {\n\t\t\t// Looks like an old browser. The strategy is to place the text\n\t\t\t// we'd like to be copied to the clipboard in the textarea and select it.\n\t\t\tthis._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(copyPlainText));\n\t\t\treturn;\n\t\t}\n\n\t\tlet copyHTML: string | null = null;\n\t\tif (browser.hasClipboardSupport() && (copyPlainText.length < 65536 || CopyOptions.forceCopyWithSyntaxHighlighting)) {\n\t\t\tcopyHTML = this._host.getHTMLToCopy();\n\t\t}\n\t\tClipboardEventUtils.setTextData(e, copyPlainText, copyHTML);\n\t}\n}\n\nclass ClipboardEventUtils {\n\n\tpublic static canUseTextData(e: ClipboardEvent): boolean {\n\t\tif (e.clipboardData) {\n\t\t\treturn true;\n\t\t}\n\t\tif ((<any>window).clipboardData) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static getTextData(e: ClipboardEvent): string {\n\t\tif (e.clipboardData) {\n\t\t\te.preventDefault();\n\t\t\treturn e.clipboardData.getData('text/plain');\n\t\t}\n\n\t\tif ((<any>window).clipboardData) {\n\t\t\te.preventDefault();\n\t\t\treturn (<any>window).clipboardData.getData('Text');\n\t\t}\n\n\t\tthrow new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n\t}\n\n\tpublic static setTextData(e: ClipboardEvent, text: string, richText: string | null): void {\n\t\tif (e.clipboardData) {\n\t\t\te.clipboardData.setData('text/plain', text);\n\t\t\tif (richText !== null) {\n\t\t\t\te.clipboardData.setData('text/html', richText);\n\t\t\t}\n\t\t\te.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tif ((<any>window).clipboardData) {\n\t\t\t(<any>window).clipboardData.setData('Text', text);\n\t\t\te.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n\t}\n}\n\nclass TextAreaWrapper extends Disposable implements ITextAreaWrapper {\n\n\tprivate readonly _actual: FastDomNode<HTMLTextAreaElement>;\n\tprivate _ignoreSelectionChangeTime: number;\n\n\tconstructor(_textArea: FastDomNode<HTMLTextAreaElement>) {\n\t\tsuper();\n\t\tthis._actual = _textArea;\n\t\tthis._ignoreSelectionChangeTime = 0;\n\t}\n\n\tpublic setIgnoreSelectionChangeTime(reason: string): void {\n\t\tthis._ignoreSelectionChangeTime = Date.now();\n\t}\n\n\tpublic getIgnoreSelectionChangeTime(): number {\n\t\treturn this._ignoreSelectionChangeTime;\n\t}\n\n\tpublic resetSelectionChangeTime(): void {\n\t\tthis._ignoreSelectionChangeTime = 0;\n\t}\n\n\tpublic getValue(): string {\n\t\t// console.log('current value: ' + this._textArea.value);\n\t\treturn this._actual.domNode.value;\n\t}\n\n\tpublic setValue(reason: string, value: string): void {\n\t\tconst textArea = this._actual.domNode;\n\t\tif (textArea.value === value) {\n\t\t\t// No change\n\t\t\treturn;\n\t\t}\n\t\t// console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n\t\tthis.setIgnoreSelectionChangeTime('setValue');\n\t\ttextArea.value = value;\n\t}\n\n\tpublic getSelectionStart(): number {\n\t\treturn this._actual.domNode.selectionStart;\n\t}\n\n\tpublic getSelectionEnd(): number {\n\t\treturn this._actual.domNode.selectionEnd;\n\t}\n\n\tpublic setSelectionRange(reason: string, selectionStart: number, selectionEnd: number): void {\n\t\tconst textArea = this._actual.domNode;\n\n\t\tconst currentIsFocused = (document.activeElement === textArea);\n\t\tconst currentSelectionStart = textArea.selectionStart;\n\t\tconst currentSelectionEnd = textArea.selectionEnd;\n\n\t\tif (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n\t\t\t// No change\n\t\t\t// Firefox iframe bug https://github.com/Microsoft/monaco-editor/issues/643#issuecomment-367871377\n\t\t\tif (browser.isFirefox && window.parent !== window) {\n\t\t\t\ttextArea.focus();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n\n\t\tif (currentIsFocused) {\n\t\t\t// No need to focus, only need to change the selection range\n\t\t\tthis.setIgnoreSelectionChangeTime('setSelectionRange');\n\t\t\ttextArea.setSelectionRange(selectionStart, selectionEnd);\n\t\t\tif (browser.isFirefox && window.parent !== window) {\n\t\t\t\ttextArea.focus();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n\t\t// Here, we try to undo the browser's desperate reveal.\n\t\ttry {\n\t\t\tconst scrollState = dom.saveParentsScrollTop(textArea);\n\t\t\tthis.setIgnoreSelectionChangeTime('setSelectionRange');\n\t\t\ttextArea.focus();\n\t\t\ttextArea.setSelectionRange(selectionStart, selectionEnd);\n\t\t\tdom.restoreParentsScrollTop(textArea, scrollState);\n\t\t} catch (e) {\n\t\t\t// Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n\t\t}\n\t}\n}\n"]}]}