{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/abstractKeybindingService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/abstractKeybindingService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/event\", \"vs/base/common/keyCodes\", \"vs/base/common/lifecycle\", \"vs/base/common/types\"], function (require, exports, nls, arrays, async_1, event_1, keyCodes_1, lifecycle_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class AbstractKeybindingService extends lifecycle_1.Disposable {\n        constructor(contextKeyService, commandService, telemetryService, notificationService, statusService) {\n            super();\n            this._contextKeyService = contextKeyService;\n            this._commandService = commandService;\n            this._telemetryService = telemetryService;\n            this._statusService = statusService;\n            this._notificationService = notificationService;\n            this._currentChord = null;\n            this._currentChordChecker = new async_1.IntervalTimer();\n            this._currentChordStatusMessage = null;\n            this._onDidUpdateKeybindings = this._register(new event_1.Emitter());\n        }\n        dispose() {\n            super.dispose();\n        }\n        get onDidUpdateKeybindings() {\n            return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : event_1.Event.None; // Sinon stubbing walks properties on prototype\n        }\n        getDefaultKeybindingsContent() {\n            return '';\n        }\n        getDefaultKeybindings() {\n            return this._getResolver().getDefaultKeybindings();\n        }\n        getKeybindings() {\n            return this._getResolver().getKeybindings();\n        }\n        customKeybindingsCount() {\n            return 0;\n        }\n        lookupKeybindings(commandId) {\n            return arrays.coalesce(this._getResolver().lookupKeybindings(commandId).map(item => item.resolvedKeybinding));\n        }\n        lookupKeybinding(commandId) {\n            let result = this._getResolver().lookupPrimaryKeybinding(commandId);\n            if (!result) {\n                return undefined;\n            }\n            return types_1.withNullAsUndefined(result.resolvedKeybinding);\n        }\n        dispatchEvent(e, target) {\n            return this._dispatch(e, target);\n        }\n        softDispatch(e, target) {\n            const keybinding = this.resolveKeyboardEvent(e);\n            if (keybinding.isChord()) {\n                console.warn('Unexpected keyboard event mapped to a chord');\n                return null;\n            }\n            const [firstPart,] = keybinding.getDispatchParts();\n            if (firstPart === null) {\n                // cannot be dispatched, probably only modifier keys\n                return null;\n            }\n            const contextValue = this._contextKeyService.getContext(target);\n            const currentChord = this._currentChord ? this._currentChord.keypress : null;\n            return this._getResolver().resolve(contextValue, currentChord, firstPart);\n        }\n        _enterChordMode(firstPart, keypressLabel) {\n            this._currentChord = {\n                keypress: firstPart,\n                label: keypressLabel\n            };\n            if (this._statusService) {\n                this._currentChordStatusMessage = this._statusService.setStatusMessage(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n            }\n            const chordEnterTime = Date.now();\n            this._currentChordChecker.cancelAndSet(() => {\n                if (!this._documentHasFocus()) {\n                    // Focus has been lost => leave chord mode\n                    this._leaveChordMode();\n                    return;\n                }\n                if (Date.now() - chordEnterTime > 5000) {\n                    // 5 seconds elapsed => leave chord mode\n                    this._leaveChordMode();\n                }\n            }, 500);\n        }\n        _leaveChordMode() {\n            if (this._currentChordStatusMessage) {\n                this._currentChordStatusMessage.dispose();\n                this._currentChordStatusMessage = null;\n            }\n            this._currentChordChecker.cancel();\n            this._currentChord = null;\n        }\n        dispatchByUserSettingsLabel(userSettingsLabel, target) {\n            const keybindings = this.resolveUserBinding(userSettingsLabel);\n            if (keybindings.length >= 1) {\n                this._doDispatch(keybindings[0], target);\n            }\n        }\n        _dispatch(e, target) {\n            return this._doDispatch(this.resolveKeyboardEvent(e), target);\n        }\n        _doDispatch(keybinding, target) {\n            let shouldPreventDefault = false;\n            if (keybinding.isChord()) {\n                console.warn('Unexpected keyboard event mapped to a chord');\n                return false;\n            }\n            const [firstPart,] = keybinding.getDispatchParts();\n            if (firstPart === null) {\n                // cannot be dispatched, probably only modifier keys\n                return shouldPreventDefault;\n            }\n            const contextValue = this._contextKeyService.getContext(target);\n            const currentChord = this._currentChord ? this._currentChord.keypress : null;\n            const keypressLabel = keybinding.getLabel();\n            const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n            if (resolveResult && resolveResult.enterChord) {\n                shouldPreventDefault = true;\n                this._enterChordMode(firstPart, keypressLabel);\n                return shouldPreventDefault;\n            }\n            if (this._statusService && this._currentChord) {\n                if (!resolveResult || !resolveResult.commandId) {\n                    this._statusService.setStatusMessage(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), 10 * 1000 /* 10s */);\n                    shouldPreventDefault = true;\n                }\n            }\n            this._leaveChordMode();\n            if (resolveResult && resolveResult.commandId) {\n                if (!resolveResult.bubble) {\n                    shouldPreventDefault = true;\n                }\n                if (typeof resolveResult.commandArgs === 'undefined') {\n                    this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\n                }\n                else {\n                    this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\n                }\n                /* __GDPR__\n                    \"workbenchActionExecuted\" : {\n                        \"id\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                        \"from\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                this._telemetryService.publicLog('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\n            }\n            return shouldPreventDefault;\n        }\n        mightProducePrintableCharacter(event) {\n            if (event.ctrlKey || event.metaKey) {\n                // ignore ctrl/cmd-combination but not shift/alt-combinatios\n                return false;\n            }\n            // weak check for certain ranges. this is properly implemented in a subclass\n            // with access to the KeyboardMapperFactory.\n            if ((event.keyCode >= keyCodes_1.KeyCode.KEY_A && event.keyCode <= keyCodes_1.KeyCode.KEY_Z)\n                || (event.keyCode >= keyCodes_1.KeyCode.KEY_0 && event.keyCode <= keyCodes_1.KeyCode.KEY_9)) {\n                return true;\n            }\n            return false;\n        }\n    }\n    exports.AbstractKeybindingService = AbstractKeybindingService;\n});\n",null]}