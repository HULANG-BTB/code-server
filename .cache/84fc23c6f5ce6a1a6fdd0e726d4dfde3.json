{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/packages/protocol/src/browser/client.ts","dependencies":[{"path":"/home/coding/workspace/packages/protocol/src/browser/client.ts","mtime":1555841535686},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"util\");\nvar events_1 = require(\"@coder/events\");\nvar logger_1 = require(\"@coder/logger\");\nvar proxy_1 = require(\"../common/proxy\");\nvar util_2 = require(\"../common/util\");\nvar proto_1 = require(\"../proto\");\nvar modules_1 = require(\"./modules\");\n/**\n * Client accepts a connection to communicate with the server.\n */\nvar Client = /** @class */ (function () {\n    /**\n     * @param connection Established connection to the server\n     */\n    function Client(connection) {\n        var _a;\n        var _this = this;\n        this.connection = connection;\n        this.messageId = 0;\n        this.callbackId = 0;\n        this.proxies = new Map();\n        this.successEmitter = new events_1.Emitter();\n        this.failEmitter = new events_1.Emitter();\n        this.eventEmitter = new events_1.Emitter();\n        this.initDataEmitter = new events_1.Emitter();\n        this.sharedProcessActiveEmitter = new events_1.Emitter();\n        this.onSharedProcessActive = this.sharedProcessActiveEmitter.event;\n        this.disconnected = false;\n        this.pingTimeoutDelay = 30000;\n        this.responseTimeout = 10000;\n        /**\n         * Start the ping loop. Does nothing if already pinging.\n         */\n        this.startPinging = function () {\n            if (typeof _this.pingTimeout !== \"undefined\") {\n                return;\n            }\n            var schedulePing = function () {\n                _this.pingTimeout = setTimeout(function () {\n                    var clientMsg = new proto_1.ClientMessage();\n                    clientMsg.setPing(new proto_1.Ping());\n                    _this.connection.send(clientMsg.serializeBinary());\n                    schedulePing();\n                }, _this.pingTimeoutDelay);\n            };\n            schedulePing();\n        };\n        connection.onMessage(function (data) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var message, error_1;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        message = proto_1.ServerMessage.deserializeBinary(data);\n                        return [4 /*yield*/, this.handleMessage(message)];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _a.sent();\n                        logger_1.logger.error(\"Failed to handle server message\", logger_1.field(\"id\", message && this.getMessageId(message)), logger_1.field(\"length\", data.byteLength), logger_1.field(\"error\", error_1.message));\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        }); });\n        this.createProxy(proxy_1.Module.ChildProcess);\n        this.createProxy(proxy_1.Module.Fs);\n        this.createProxy(proxy_1.Module.Net);\n        this.createProxy(proxy_1.Module.NodePty);\n        this.createProxy(proxy_1.Module.Spdlog);\n        this.createProxy(proxy_1.Module.Trash);\n        this.modules = (_a = {},\n            _a[proxy_1.Module.ChildProcess] = new modules_1.ChildProcessModule(this.getProxy(proxy_1.Module.ChildProcess).instance),\n            _a[proxy_1.Module.Fs] = new modules_1.FsModule(this.getProxy(proxy_1.Module.Fs).instance),\n            _a[proxy_1.Module.Net] = new modules_1.NetModule(this.getProxy(proxy_1.Module.Net).instance),\n            _a[proxy_1.Module.NodePty] = new modules_1.NodePtyModule(this.getProxy(proxy_1.Module.NodePty).instance),\n            _a[proxy_1.Module.Spdlog] = new modules_1.SpdlogModule(this.getProxy(proxy_1.Module.Spdlog).instance),\n            _a[proxy_1.Module.Trash] = new modules_1.TrashModule(this.getProxy(proxy_1.Module.Trash).instance),\n            _a);\n        // Methods that don't follow the standard callback pattern (an error\n        // followed by a single result) need to provide a custom promisify function.\n        Object.defineProperty(this.modules[proxy_1.Module.Fs].exists, util_1.promisify.custom, {\n            value: function (path) {\n                return new Promise(function (resolve) { return _this.modules[proxy_1.Module.Fs].exists(path, resolve); });\n            },\n        });\n        Object.defineProperty(this.modules[proxy_1.Module.ChildProcess].exec, util_1.promisify.custom, {\n            value: function (command, options) {\n                return new Promise(function (resolve, reject) {\n                    _this.modules[proxy_1.Module.ChildProcess].exec(command, options, function (error, stdout, stderr) {\n                        if (error) {\n                            reject(error);\n                        }\n                        else {\n                            resolve({ stdout: stdout, stderr: stderr });\n                        }\n                    });\n                });\n            },\n        });\n        /**\n         * If the connection is interrupted, the calls will neither succeed nor fail\n         * nor exit so we need to send a failure on all of them as well as trigger\n         * events so things like child processes can clean up and possibly restart.\n         */\n        var handleDisconnect = function () {\n            _this.disconnected = true;\n            logger_1.logger.trace(function () { return [\n                \"disconnected from server\",\n                logger_1.field(\"proxies\", _this.proxies.size),\n                logger_1.field(\"callbacks\", Array.from(_this.proxies.values()).reduce(function (count, p) { return count + p.callbacks.size; }, 0)),\n                logger_1.field(\"success listeners\", _this.successEmitter.counts),\n                logger_1.field(\"fail listeners\", _this.failEmitter.counts),\n                logger_1.field(\"event listeners\", _this.eventEmitter.counts),\n            ]; });\n            var message = new proto_1.Method.Fail();\n            var error = new Error(\"disconnected\");\n            message.setResponse(util_2.argumentToProto(error));\n            _this.failEmitter.emit(message);\n            _this.eventEmitter.emit({ event: \"disconnected\", args: [error] });\n            _this.eventEmitter.emit({ event: \"done\", args: [] });\n        };\n        connection.onDown(function () { return handleDisconnect(); });\n        connection.onClose(function () {\n            clearTimeout(_this.pingTimeout);\n            _this.pingTimeout = undefined;\n            handleDisconnect();\n            _this.proxies.clear();\n            _this.successEmitter.dispose();\n            _this.failEmitter.dispose();\n            _this.eventEmitter.dispose();\n            _this.initDataEmitter.dispose();\n            _this.sharedProcessActiveEmitter.dispose();\n        });\n        connection.onUp(function () { return _this.disconnected = false; });\n        this.initDataPromise = new Promise(function (resolve) {\n            _this.initDataEmitter.event(resolve);\n        });\n        this.startPinging();\n    }\n    /**\n     * Close the connection.\n     */\n    Client.prototype.dispose = function () {\n        this.connection.close();\n    };\n    Object.defineProperty(Client.prototype, \"initData\", {\n        get: function () {\n            return this.initDataPromise;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Make a remote call for a proxy's method using proto.\n     */\n    Client.prototype.remoteCall = function (proxyId, method, args) {\n        var _this = this;\n        if (typeof proxyId === \"number\" && (this.disconnected || !this.proxies.has(proxyId))) {\n            // Can assume killing or closing works because a disconnected proxy is\n            // disposed on the server's side, and a non-existent proxy has already\n            // been disposed.\n            switch (method) {\n                case \"close\":\n                case \"kill\":\n                    return Promise.resolve();\n            }\n            return Promise.reject(new Error(\"Unable to call \\\"\" + method + \"\\\" on proxy \" + proxyId + \": disconnected\"));\n        }\n        var message = new proto_1.Method();\n        var id = this.messageId++;\n        var proxyMessage;\n        if (typeof proxyId === \"string\") {\n            proxyMessage = new proto_1.Method.Named();\n            proxyMessage.setModule(util_2.moduleToProto(proxyId));\n            message.setNamedProxy(proxyMessage);\n        }\n        else {\n            proxyMessage = new proto_1.Method.Numbered();\n            proxyMessage.setProxyId(proxyId);\n            message.setNumberedProxy(proxyMessage);\n        }\n        proxyMessage.setId(id);\n        proxyMessage.setMethod(method);\n        var storeCallback = function (cb) {\n            var callbackId = _this.callbackId++;\n            logger_1.logger.trace(function () { return [\n                \"storing callback\",\n                logger_1.field(\"proxyId\", proxyId),\n                logger_1.field(\"callbackId\", callbackId),\n            ]; });\n            _this.getProxy(proxyId).callbacks.set(callbackId, cb);\n            return callbackId;\n        };\n        logger_1.logger.trace(function () { return [\n            \"sending\",\n            logger_1.field(\"id\", id),\n            logger_1.field(\"proxyId\", proxyId),\n            logger_1.field(\"method\", method),\n        ]; });\n        proxyMessage.setArgsList(args.map(function (a) { return util_2.argumentToProto(a, storeCallback); }));\n        var clientMessage = new proto_1.ClientMessage();\n        clientMessage.setMethod(message);\n        this.connection.send(clientMessage.serializeBinary());\n        // The server will send back a fail or success message when the method\n        // has completed, so we listen for that based on the message's unique ID.\n        var promise = new Promise(function (resolve, reject) {\n            var dispose = function () {\n                d1.dispose();\n                d2.dispose();\n                clearTimeout(timeout);\n            };\n            var timeout = setTimeout(function () {\n                dispose();\n                reject(new Error(\"timed out\"));\n            }, _this.responseTimeout);\n            var d1 = _this.successEmitter.event(id, function (message) {\n                dispose();\n                resolve(_this.protoToArgument(message.getResponse(), promise));\n            });\n            var d2 = _this.failEmitter.event(id, function (message) {\n                dispose();\n                reject(util_2.protoToArgument(message.getResponse()));\n            });\n        });\n        return promise;\n    };\n    /**\n     * Handle all messages from the server.\n     */\n    Client.prototype.handleMessage = function (message) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _a, init, sharedProcessActiveMessage;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = message.getMsgCase();\n                        switch (_a) {\n                            case proto_1.ServerMessage.MsgCase.INIT: return [3 /*break*/, 1];\n                            case proto_1.ServerMessage.MsgCase.SUCCESS: return [3 /*break*/, 2];\n                            case proto_1.ServerMessage.MsgCase.FAIL: return [3 /*break*/, 3];\n                            case proto_1.ServerMessage.MsgCase.EVENT: return [3 /*break*/, 4];\n                            case proto_1.ServerMessage.MsgCase.CALLBACK: return [3 /*break*/, 6];\n                            case proto_1.ServerMessage.MsgCase.SHARED_PROCESS_ACTIVE: return [3 /*break*/, 8];\n                            case proto_1.ServerMessage.MsgCase.PONG: return [3 /*break*/, 9];\n                        }\n                        return [3 /*break*/, 10];\n                    case 1:\n                        init = message.getInit();\n                        this._initData = {\n                            dataDirectory: init.getDataDirectory(),\n                            homeDirectory: init.getHomeDirectory(),\n                            tmpDirectory: init.getTmpDirectory(),\n                            workingDirectory: init.getWorkingDirectory(),\n                            os: util_2.protoToOperatingSystem(init.getOperatingSystem()),\n                            shell: init.getShell(),\n                            extensionsDirectory: init.getExtensionsDirectory(),\n                            builtInExtensionsDirectory: init.getBuiltinExtensionsDir(),\n                        };\n                        this.initDataEmitter.emit(this._initData);\n                        return [3 /*break*/, 11];\n                    case 2:\n                        this.emitSuccess(message.getSuccess());\n                        return [3 /*break*/, 11];\n                    case 3:\n                        this.emitFail(message.getFail());\n                        return [3 /*break*/, 11];\n                    case 4: return [4 /*yield*/, this.emitEvent(message.getEvent())];\n                    case 5:\n                        _b.sent();\n                        return [3 /*break*/, 11];\n                    case 6: return [4 /*yield*/, this.runCallback(message.getCallback())];\n                    case 7:\n                        _b.sent();\n                        return [3 /*break*/, 11];\n                    case 8:\n                        sharedProcessActiveMessage = message.getSharedProcessActive();\n                        this.sharedProcessActiveEmitter.emit({\n                            socketPath: sharedProcessActiveMessage.getSocketPath(),\n                            logPath: sharedProcessActiveMessage.getLogPath(),\n                        });\n                        return [3 /*break*/, 11];\n                    case 9: \n                    // Nothing to do since pings are on a timer rather than waiting for the\n                    // next pong in case a message from either the client or server is dropped\n                    // which would break the ping cycle.\n                    return [3 /*break*/, 11];\n                    case 10: throw new Error(\"unknown message type\");\n                    case 11: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Convert message to a success event.\n     */\n    Client.prototype.emitSuccess = function (message) {\n        logger_1.logger.trace(function () { return [\n            \"received resolve\",\n            logger_1.field(\"id\", message.getId()),\n        ]; });\n        this.successEmitter.emit(message.getId(), message);\n    };\n    /**\n     * Convert message to a fail event.\n     */\n    Client.prototype.emitFail = function (message) {\n        logger_1.logger.trace(function () { return [\n            \"received reject\",\n            logger_1.field(\"id\", message.getId()),\n        ]; });\n        this.failEmitter.emit(message.getId(), message);\n    };\n    /**\n     * Emit an event received from the server. We could send requests for \"on\" to\n     * the server and serialize functions using IDs, but doing it that way makes\n     * it possible to miss events depending on whether the server receives the\n     * request before it emits. Instead, emit all events from the server so all\n     * events are always caught on the client.\n     */\n    Client.prototype.emitEvent = function (message) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var eventMessage, proxyId, event, args;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        eventMessage = message.getNamedEvent() || message.getNumberedEvent();\n                        proxyId = message.getNamedEvent()\n                            ? util_2.protoToModule(message.getNamedEvent().getModule())\n                            : message.getNumberedEvent().getProxyId();\n                        event = eventMessage.getEvent();\n                        return [4 /*yield*/, this.ensureResolved(proxyId)];\n                    case 1:\n                        _a.sent();\n                        logger_1.logger.trace(function () { return [\n                            \"received event\",\n                            logger_1.field(\"proxyId\", proxyId),\n                            logger_1.field(\"event\", event),\n                        ]; });\n                        args = eventMessage.getArgsList().map(function (a) { return _this.protoToArgument(a); });\n                        this.eventEmitter.emit(proxyId, { event: event, args: args });\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Run a callback as requested by the server. Since we don't know when\n     * callbacks get garbage collected we dispose them only when the proxy\n     * disposes. That means they should only be used if they run for the lifetime\n     * of the proxy (like child_process.exec), otherwise we'll leak. They should\n     * also only be used when passed together with the method. If they are sent\n     * afterward, they may never be called due to timing issues.\n     */\n    Client.prototype.runCallback = function (message) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var callbackMessage, proxyId, callbackId, args;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        callbackMessage = message.getNamedCallback() || message.getNumberedCallback();\n                        proxyId = message.getNamedCallback()\n                            ? util_2.protoToModule(message.getNamedCallback().getModule())\n                            : message.getNumberedCallback().getProxyId();\n                        callbackId = callbackMessage.getCallbackId();\n                        return [4 /*yield*/, this.ensureResolved(proxyId)];\n                    case 1:\n                        _a.sent();\n                        logger_1.logger.trace(function () { return [\n                            \"running callback\",\n                            logger_1.field(\"proxyId\", proxyId),\n                            logger_1.field(\"callbackId\", callbackId),\n                        ]; });\n                        args = callbackMessage.getArgsList().map(function (a) { return _this.protoToArgument(a); });\n                        this.getProxy(proxyId).callbacks.get(callbackId).apply(void 0, args);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Return the message's ID if it has one or a string identifier. For logging\n     * errors with an ID to make the error more useful.\n     */\n    Client.prototype.getMessageId = function (message) {\n        if (message.hasInit()) {\n            return \"init\";\n        }\n        else if (message.hasSuccess()) {\n            return message.getSuccess().getId();\n        }\n        else if (message.hasFail()) {\n            return message.getFail().getId();\n        }\n        else if (message.hasEvent()) {\n            var eventMessage = message.getEvent().getNamedEvent()\n                || message.getEvent().getNumberedEvent();\n            return \"event: \" + eventMessage.getEvent();\n        }\n        else if (message.hasCallback()) {\n            var callbackMessage = message.getCallback().getNamedCallback()\n                || message.getCallback().getNumberedCallback();\n            return \"callback: \" + callbackMessage.getCallbackId();\n        }\n        else if (message.hasSharedProcessActive()) {\n            return \"shared\";\n        }\n        else if (message.hasPong()) {\n            return \"pong\";\n        }\n    };\n    /**\n     * Return a proxy that makes remote calls.\n     */\n    Client.prototype.createProxy = function (proxyId, promise) {\n        var _this = this;\n        if (promise === void 0) { promise = Promise.resolve(); }\n        logger_1.logger.trace(function () { return [\n            \"creating proxy\",\n            logger_1.field(\"proxyId\", proxyId),\n        ]; });\n        var instance = new Proxy({\n            proxyId: proxyId,\n            onDone: function (cb) {\n                _this.eventEmitter.event(proxyId, function (event) {\n                    if (event.event === \"done\") {\n                        cb.apply(void 0, event.args);\n                    }\n                });\n            },\n            onEvent: function (cb) {\n                _this.eventEmitter.event(proxyId, function (event) {\n                    cb.apply(void 0, [event.event].concat(event.args));\n                });\n            },\n        }, {\n            get: function (target, name) {\n                // When resolving a promise with a proxy, it will check for \"then\".\n                if (name === \"then\") {\n                    return;\n                }\n                if (typeof target[name] === \"undefined\") {\n                    target[name] = function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        return _this.remoteCall(proxyId, name, args);\n                    };\n                }\n                return target[name];\n            },\n        });\n        this.proxies.set(proxyId, {\n            promise: promise,\n            instance: instance,\n            callbacks: new Map(),\n        });\n        instance.onDone(function () {\n            var log = function () {\n                logger_1.logger.trace(function () { return [\n                    typeof proxyId === \"number\" ? \"disposed proxy\" : \"disposed proxy callbacks\",\n                    logger_1.field(\"proxyId\", proxyId),\n                    logger_1.field(\"disconnected\", _this.disconnected),\n                    logger_1.field(\"callbacks\", Array.from(_this.proxies.values()).reduce(function (count, proxy) { return count + proxy.callbacks.size; }, 0)),\n                    logger_1.field(\"success listeners\", _this.successEmitter.counts),\n                    logger_1.field(\"fail listeners\", _this.failEmitter.counts),\n                    logger_1.field(\"event listeners\", _this.eventEmitter.counts),\n                ]; });\n            };\n            // Uniquely identified items (top-level module proxies) can continue to\n            // be used so we don't need to delete them.\n            if (typeof proxyId === \"number\") {\n                var dispose = function () {\n                    _this.proxies.delete(proxyId);\n                    _this.eventEmitter.dispose(proxyId);\n                    log();\n                };\n                if (!_this.disconnected) {\n                    instance.dispose().then(dispose).catch(dispose);\n                }\n                else {\n                    dispose();\n                }\n            }\n            else {\n                // The callbacks will still be unusable though.\n                _this.getProxy(proxyId).callbacks.clear();\n                log();\n            }\n        });\n        return instance;\n    };\n    /**\n     * We aren't guaranteed the promise will call all the `then` callbacks\n     * synchronously once it resolves, so the event message can come in and fire\n     * before a caller has been able to attach an event. Waiting for the promise\n     * ensures it runs after everything else.\n     */\n    Client.prototype.ensureResolved = function (proxyId) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getProxy(proxyId).promise];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Same as protoToArgument except provides createProxy.\n     */\n    Client.prototype.protoToArgument = function (value, promise) {\n        var _this = this;\n        return util_2.protoToArgument(value, undefined, function (id) { return _this.createProxy(id, promise); });\n    };\n    /**\n     * Get a proxy. Error if it doesn't exist.\n     */\n    Client.prototype.getProxy = function (proxyId) {\n        if (!this.proxies.has(proxyId)) {\n            throw new Error(\"proxy \" + proxyId + \" disposed too early\");\n        }\n        return this.proxies.get(proxyId);\n    };\n    return Client;\n}());\nexports.Client = Client;\n",{"version":3,"file":"/home/coding/workspace/packages/protocol/src/browser/client.ts","sourceRoot":"","sources":["/home/coding/workspace/packages/protocol/src/browser/client.ts"],"names":[],"mappings":"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","sourcesContent":["import { PathLike } from \"fs\";\nimport { ExecException, ExecOptions } from \"child_process\";\nimport { promisify } from \"util\";\nimport { Emitter } from \"@coder/events\";\nimport { logger, field } from \"@coder/logger\";\nimport { ReadWriteConnection, InitData, SharedProcessData } from \"../common/connection\";\nimport { Module, ServerProxy } from \"../common/proxy\";\nimport { argumentToProto, protoToArgument, moduleToProto, protoToModule, protoToOperatingSystem } from \"../common/util\";\nimport { Argument, Ping, ServerMessage, ClientMessage, Method, Event, Callback } from \"../proto\";\nimport { FsModule, ChildProcessModule, NetModule, NodePtyModule, SpdlogModule, TrashModule } from \"./modules\";\n\n// tslint:disable no-any\n\ninterface ProxyData {\n\tpromise: Promise<void>;\n\tinstance: any;\n\tcallbacks: Map<number, (...args: any[]) => void>;\n}\n\n/**\n * Client accepts a connection to communicate with the server.\n */\nexport class Client {\n\tprivate messageId = 0;\n\tprivate callbackId = 0;\n\tprivate readonly proxies = new Map<number | Module, ProxyData>();\n\tprivate readonly successEmitter = new Emitter<Method.Success>();\n\tprivate readonly failEmitter = new Emitter<Method.Fail>();\n\tprivate readonly eventEmitter = new Emitter<{ event: string; args: any[]; }>();\n\n\tprivate _initData: InitData | undefined;\n\tprivate readonly initDataEmitter = new Emitter<InitData>();\n\tprivate readonly initDataPromise: Promise<InitData>;\n\n\tprivate readonly sharedProcessActiveEmitter = new Emitter<SharedProcessData>();\n\tpublic readonly onSharedProcessActive = this.sharedProcessActiveEmitter.event;\n\n\tprivate disconnected: boolean = false;\n\n\t// The socket timeout is 60s, so we need to send a ping periodically to\n\t// prevent it from closing.\n\tprivate pingTimeout: NodeJS.Timer | number | undefined;\n\tprivate readonly pingTimeoutDelay = 30000;\n\n\tprivate readonly responseTimeout = 10000;\n\n\tpublic readonly modules: {\n\t\t[Module.ChildProcess]: ChildProcessModule,\n\t\t[Module.Fs]: FsModule,\n\t\t[Module.Net]: NetModule,\n\t\t[Module.NodePty]: NodePtyModule,\n\t\t[Module.Spdlog]: SpdlogModule,\n\t\t[Module.Trash]: TrashModule,\n\t};\n\n\t/**\n\t * @param connection Established connection to the server\n\t */\n\tpublic constructor(private readonly connection: ReadWriteConnection) {\n\t\tconnection.onMessage(async (data) => {\n\t\t\tlet message: ServerMessage | undefined;\n\t\t\ttry {\n\t\t\t\tmessage = ServerMessage.deserializeBinary(data);\n\t\t\t\tawait this.handleMessage(message);\n\t\t\t} catch (error) {\n\t\t\t\tlogger.error(\n\t\t\t\t\t\"Failed to handle server message\",\n\t\t\t\t\tfield(\"id\", message && this.getMessageId(message)),\n\t\t\t\t\tfield(\"length\", data.byteLength),\n\t\t\t\t\tfield(\"error\", error.message),\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\n\t\tthis.createProxy(Module.ChildProcess);\n\t\tthis.createProxy(Module.Fs);\n\t\tthis.createProxy(Module.Net);\n\t\tthis.createProxy(Module.NodePty);\n\t\tthis.createProxy(Module.Spdlog);\n\t\tthis.createProxy(Module.Trash);\n\n\t\tthis.modules = {\n\t\t\t[Module.ChildProcess]: new ChildProcessModule(this.getProxy(Module.ChildProcess).instance),\n\t\t\t[Module.Fs]: new FsModule(this.getProxy(Module.Fs).instance),\n\t\t\t[Module.Net]: new NetModule(this.getProxy(Module.Net).instance),\n\t\t\t[Module.NodePty]: new NodePtyModule(this.getProxy(Module.NodePty).instance),\n\t\t\t[Module.Spdlog]: new SpdlogModule(this.getProxy(Module.Spdlog).instance),\n\t\t\t[Module.Trash]: new TrashModule(this.getProxy(Module.Trash).instance),\n\t\t};\n\n\t\t// Methods that don't follow the standard callback pattern (an error\n\t\t// followed by a single result) need to provide a custom promisify function.\n\t\tObject.defineProperty(this.modules[Module.Fs].exists, promisify.custom, {\n\t\t\tvalue: (path: PathLike): Promise<boolean> => {\n\t\t\t\treturn new Promise((resolve): void => this.modules[Module.Fs].exists(path, resolve));\n\t\t\t},\n\t\t});\n\n\t\tObject.defineProperty(this.modules[Module.ChildProcess].exec, promisify.custom, {\n\t\t\tvalue: (\n\t\t\t\tcommand: string,\n\t\t\t\toptions?: { encoding?: string | null } & ExecOptions | null,\n\t\t\t): Promise<{ stdout: string | Buffer, stderr: string | Buffer }> => {\n\t\t\t\treturn new Promise((resolve, reject): void => {\n\t\t\t\t\tthis.modules[Module.ChildProcess].exec(command, options, (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => {\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve({ stdout, stderr });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\n\t\t/**\n\t\t * If the connection is interrupted, the calls will neither succeed nor fail\n\t\t * nor exit so we need to send a failure on all of them as well as trigger\n\t\t * events so things like child processes can clean up and possibly restart.\n\t\t */\n\t\tconst handleDisconnect = (): void => {\n\t\t\tthis.disconnected = true;\n\t\t\tlogger.trace(() => [\n\t\t\t\t\"disconnected from server\",\n\t\t\t\tfield(\"proxies\", this.proxies.size),\n\t\t\t\tfield(\"callbacks\", Array.from(this.proxies.values()).reduce((count, p) => count + p.callbacks.size, 0)),\n\t\t\t\tfield(\"success listeners\", this.successEmitter.counts),\n\t\t\t\tfield(\"fail listeners\", this.failEmitter.counts),\n\t\t\t\tfield(\"event listeners\", this.eventEmitter.counts),\n\t\t\t]);\n\n\t\t\tconst message = new Method.Fail();\n\t\t\tconst error = new Error(\"disconnected\");\n\t\t\tmessage.setResponse(argumentToProto(error));\n\t\t\tthis.failEmitter.emit(message);\n\n\t\t\tthis.eventEmitter.emit({ event: \"disconnected\", args: [error] });\n\t\t\tthis.eventEmitter.emit({ event: \"done\", args: [] });\n\t\t};\n\n\t\tconnection.onDown(() => handleDisconnect());\n\t\tconnection.onClose(() => {\n\t\t\tclearTimeout(this.pingTimeout as any);\n\t\t\tthis.pingTimeout = undefined;\n\t\t\thandleDisconnect();\n\t\t\tthis.proxies.clear();\n\t\t\tthis.successEmitter.dispose();\n\t\t\tthis.failEmitter.dispose();\n\t\t\tthis.eventEmitter.dispose();\n\t\t\tthis.initDataEmitter.dispose();\n\t\t\tthis.sharedProcessActiveEmitter.dispose();\n\t\t});\n\t\tconnection.onUp(() => this.disconnected = false);\n\n\t\tthis.initDataPromise = new Promise((resolve): void => {\n\t\t\tthis.initDataEmitter.event(resolve);\n\t\t});\n\n\t\tthis.startPinging();\n\t}\n\n\t/**\n\t * Close the connection.\n\t */\n\tpublic dispose(): void {\n\t\tthis.connection.close();\n\t}\n\n\tpublic get initData(): Promise<InitData> {\n\t\treturn this.initDataPromise;\n\t}\n\n\t/**\n\t * Make a remote call for a proxy's method using proto.\n\t */\n\tprivate remoteCall(proxyId: number | Module, method: string, args: any[]): Promise<any> {\n\t\tif (typeof proxyId === \"number\" && (this.disconnected || !this.proxies.has(proxyId))) {\n\t\t\t// Can assume killing or closing works because a disconnected proxy is\n\t\t\t// disposed on the server's side, and a non-existent proxy has already\n\t\t\t// been disposed.\n\t\t\tswitch (method) {\n\t\t\t\tcase \"close\":\n\t\t\t\tcase \"kill\":\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`Unable to call \"${method}\" on proxy ${proxyId}: disconnected`),\n\t\t\t);\n\t\t}\n\n\t\tconst message = new Method();\n\t\tconst id = this.messageId++;\n\t\tlet proxyMessage: Method.Named | Method.Numbered;\n\t\tif (typeof proxyId === \"string\") {\n\t\t\tproxyMessage = new Method.Named();\n\t\t\tproxyMessage.setModule(moduleToProto(proxyId));\n\t\t\tmessage.setNamedProxy(proxyMessage);\n\t\t} else {\n\t\t\tproxyMessage = new Method.Numbered();\n\t\t\tproxyMessage.setProxyId(proxyId);\n\t\t\tmessage.setNumberedProxy(proxyMessage);\n\t\t}\n\t\tproxyMessage.setId(id);\n\t\tproxyMessage.setMethod(method);\n\n\t\tconst storeCallback = (cb: (...args: any[]) => void): number => {\n\t\t\tconst callbackId = this.callbackId++;\n\t\t\tlogger.trace(() => [\n\t\t\t\t\"storing callback\",\n\t\t\t\tfield(\"proxyId\", proxyId),\n\t\t\t\tfield(\"callbackId\", callbackId),\n\t\t\t]);\n\n\t\t\tthis.getProxy(proxyId).callbacks.set(callbackId, cb);\n\n\t\t\treturn callbackId;\n\t\t};\n\n\t\tlogger.trace(() => [\n\t\t\t\"sending\",\n\t\t\tfield(\"id\", id),\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"method\", method),\n\t\t]);\n\n\t\tproxyMessage.setArgsList(args.map((a) => argumentToProto(a, storeCallback)));\n\n\t\tconst clientMessage = new ClientMessage();\n\t\tclientMessage.setMethod(message);\n\t\tthis.connection.send(clientMessage.serializeBinary());\n\n\t\t// The server will send back a fail or success message when the method\n\t\t// has completed, so we listen for that based on the message's unique ID.\n\t\tconst promise = new Promise((resolve, reject): void => {\n\t\t\tconst dispose = (): void => {\n\t\t\t\td1.dispose();\n\t\t\t\td2.dispose();\n\t\t\t\tclearTimeout(timeout as any);\n\t\t\t};\n\n\t\t\tconst timeout = setTimeout(() => {\n\t\t\t\tdispose();\n\t\t\t\treject(new Error(\"timed out\"));\n\t\t\t}, this.responseTimeout);\n\n\t\t\tconst d1 = this.successEmitter.event(id, (message) => {\n\t\t\t\tdispose();\n\t\t\t\tresolve(this.protoToArgument(message.getResponse(), promise));\n\t\t\t});\n\n\t\t\tconst d2 = this.failEmitter.event(id, (message) => {\n\t\t\t\tdispose();\n\t\t\t\treject(protoToArgument(message.getResponse()));\n\t\t\t});\n\t\t});\n\n\t\treturn promise;\n\t}\n\n\t/**\n\t * Handle all messages from the server.\n\t */\n\tprivate async handleMessage(message: ServerMessage): Promise<void> {\n\t\tswitch (message.getMsgCase()) {\n\t\t\tcase ServerMessage.MsgCase.INIT:\n\t\t\t\tconst init = message.getInit()!;\n\t\t\t\tthis._initData = {\n\t\t\t\t\tdataDirectory: init.getDataDirectory(),\n\t\t\t\t\thomeDirectory: init.getHomeDirectory(),\n\t\t\t\t\ttmpDirectory: init.getTmpDirectory(),\n\t\t\t\t\tworkingDirectory: init.getWorkingDirectory(),\n\t\t\t\t\tos: protoToOperatingSystem(init.getOperatingSystem()),\n\t\t\t\t\tshell: init.getShell(),\n\t\t\t\t\textensionsDirectory: init.getExtensionsDirectory(),\n\t\t\t\t\tbuiltInExtensionsDirectory: init.getBuiltinExtensionsDir(),\n\t\t\t\t};\n\t\t\t\tthis.initDataEmitter.emit(this._initData);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessage.MsgCase.SUCCESS:\n\t\t\t\tthis.emitSuccess(message.getSuccess()!);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessage.MsgCase.FAIL:\n\t\t\t\tthis.emitFail(message.getFail()!);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessage.MsgCase.EVENT:\n\t\t\t\tawait this.emitEvent(message.getEvent()!);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessage.MsgCase.CALLBACK:\n\t\t\t\tawait this.runCallback(message.getCallback()!);\n\t\t\t\tbreak;\n\t\t\tcase ServerMessage.MsgCase.SHARED_PROCESS_ACTIVE:\n\t\t\t\tconst sharedProcessActiveMessage = message.getSharedProcessActive()!;\n\t\t\t\tthis.sharedProcessActiveEmitter.emit({\n\t\t\t\t\tsocketPath: sharedProcessActiveMessage.getSocketPath(),\n\t\t\t\t\tlogPath: sharedProcessActiveMessage.getLogPath(),\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase ServerMessage.MsgCase.PONG:\n\t\t\t\t// Nothing to do since pings are on a timer rather than waiting for the\n\t\t\t\t// next pong in case a message from either the client or server is dropped\n\t\t\t\t// which would break the ping cycle.\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"unknown message type\");\n\t\t}\n\t}\n\n\t/**\n\t * Convert message to a success event.\n\t */\n\tprivate emitSuccess(message: Method.Success): void {\n\t\tlogger.trace(() => [\n\t\t\t\"received resolve\",\n\t\t\tfield(\"id\", message.getId()),\n\t\t]);\n\n\t\tthis.successEmitter.emit(message.getId(), message);\n\t}\n\n\t/**\n\t * Convert message to a fail event.\n\t */\n\tprivate emitFail(message: Method.Fail): void {\n\t\tlogger.trace(() => [\n\t\t\t\"received reject\",\n\t\t\tfield(\"id\", message.getId()),\n\t\t]);\n\n\t\tthis.failEmitter.emit(message.getId(), message);\n\t}\n\n\t/**\n\t * Emit an event received from the server. We could send requests for \"on\" to\n\t * the server and serialize functions using IDs, but doing it that way makes\n\t * it possible to miss events depending on whether the server receives the\n\t * request before it emits. Instead, emit all events from the server so all\n\t * events are always caught on the client.\n\t */\n\tprivate async emitEvent(message: Event): Promise<void> {\n\t\tconst eventMessage = message.getNamedEvent()! || message.getNumberedEvent()!;\n\t\tconst proxyId = message.getNamedEvent()\n\t\t\t? protoToModule(message.getNamedEvent()!.getModule())\n\t\t\t: message.getNumberedEvent()!.getProxyId();\n\t\tconst event = eventMessage.getEvent();\n\t\tawait this.ensureResolved(proxyId);\n\t\tlogger.trace(() => [\n\t\t\t\"received event\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"event\", event),\n\t\t]);\n\n\t\tconst args = eventMessage.getArgsList().map((a) => this.protoToArgument(a));\n\t\tthis.eventEmitter.emit(proxyId, { event, args });\n\t}\n\n\t/**\n\t * Run a callback as requested by the server. Since we don't know when\n\t * callbacks get garbage collected we dispose them only when the proxy\n\t * disposes. That means they should only be used if they run for the lifetime\n\t * of the proxy (like child_process.exec), otherwise we'll leak. They should\n\t * also only be used when passed together with the method. If they are sent\n\t * afterward, they may never be called due to timing issues.\n\t */\n\tprivate async runCallback(message: Callback): Promise<void> {\n\t\tconst callbackMessage = message.getNamedCallback()! || message.getNumberedCallback()!;\n\t\tconst proxyId = message.getNamedCallback()\n\t\t\t? protoToModule(message.getNamedCallback()!.getModule())\n\t\t\t: message.getNumberedCallback()!.getProxyId();\n\t\tconst callbackId = callbackMessage.getCallbackId();\n\t\tawait this.ensureResolved(proxyId);\n\t\tlogger.trace(() => [\n\t\t\t\"running callback\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t\tfield(\"callbackId\", callbackId),\n\t\t]);\n\t\tconst args = callbackMessage.getArgsList().map((a) => this.protoToArgument(a));\n\t\tthis.getProxy(proxyId).callbacks.get(callbackId)!(...args);\n\t}\n\n\t/**\n\t * Start the ping loop. Does nothing if already pinging.\n\t */\n\tprivate readonly startPinging = (): void => {\n\t\tif (typeof this.pingTimeout !== \"undefined\") {\n\t\t\treturn;\n\t\t}\n\n\t\tconst schedulePing = (): void => {\n\t\t\tthis.pingTimeout = setTimeout(() => {\n\t\t\t\tconst clientMsg = new ClientMessage();\n\t\t\t\tclientMsg.setPing(new Ping());\n\t\t\t\tthis.connection.send(clientMsg.serializeBinary());\n\t\t\t\tschedulePing();\n\t\t\t}, this.pingTimeoutDelay);\n\t\t};\n\n\t\tschedulePing();\n\t}\n\n\t/**\n\t * Return the message's ID if it has one or a string identifier. For logging\n\t * errors with an ID to make the error more useful.\n\t */\n\tprivate getMessageId(message: ServerMessage): number | string | undefined {\n\t\tif (message.hasInit()) {\n\t\t\treturn \"init\";\n\t\t} else if (message.hasSuccess()) {\n\t\t\treturn message.getSuccess()!.getId();\n\t\t} else if (message.hasFail()) {\n\t\t\treturn message.getFail()!.getId();\n\t\t} else if (message.hasEvent()) {\n\t\t\tconst eventMessage = message.getEvent()!.getNamedEvent()!\n\t\t\t\t|| message.getEvent()!.getNumberedEvent()!;\n\n\t\t\treturn `event: ${eventMessage.getEvent()}`;\n\t\t} else if (message.hasCallback()) {\n\t\t\tconst callbackMessage = message.getCallback()!.getNamedCallback()!\n\t\t\t\t|| message.getCallback()!.getNumberedCallback()!;\n\n\t\t\treturn `callback: ${callbackMessage.getCallbackId()}`;\n\t\t} else if (message.hasSharedProcessActive()) {\n\t\t\treturn \"shared\";\n\t\t} else if (message.hasPong()) {\n\t\t\treturn \"pong\";\n\t\t}\n\t}\n\n\t/**\n\t * Return a proxy that makes remote calls.\n\t */\n\tprivate createProxy<T>(proxyId: number | Module, promise: Promise<any> = Promise.resolve()): T {\n\t\tlogger.trace(() => [\n\t\t\t\"creating proxy\",\n\t\t\tfield(\"proxyId\", proxyId),\n\t\t]);\n\n\t\tconst instance = new Proxy({\n\t\t\tproxyId,\n\t\t\tonDone: (cb: (...args: any[]) => void): void => {\n\t\t\t\tthis.eventEmitter.event(proxyId, (event) => {\n\t\t\t\t\tif (event.event === \"done\") {\n\t\t\t\t\t\tcb(...event.args);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonEvent: (cb: (event: string, ...args: any[]) => void): void => {\n\t\t\t\tthis.eventEmitter.event(proxyId, (event) => {\n\t\t\t\t\tcb(event.event, ...event.args);\n\t\t\t\t});\n\t\t\t},\n\t\t}, {\n\t\t\tget: (target: any, name: string): any => {\n\t\t\t\t// When resolving a promise with a proxy, it will check for \"then\".\n\t\t\t\tif (name === \"then\") {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (typeof target[name] === \"undefined\") {\n\t\t\t\t\ttarget[name] = (...args: any[]): Promise<any> | ServerProxy => {\n\t\t\t\t\t\treturn this.remoteCall(proxyId, name, args);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn target[name];\n\t\t\t},\n\t\t});\n\n\t\tthis.proxies.set(proxyId, {\n\t\t\tpromise,\n\t\t\tinstance,\n\t\t\tcallbacks: new Map(),\n\t\t});\n\n\t\tinstance.onDone(() => {\n\t\t\tconst log = (): void => {\n\t\t\t\tlogger.trace(() => [\n\t\t\t\t\ttypeof proxyId === \"number\" ? \"disposed proxy\" : \"disposed proxy callbacks\",\n\t\t\t\t\tfield(\"proxyId\", proxyId),\n\t\t\t\t\tfield(\"disconnected\", this.disconnected),\n\t\t\t\t\tfield(\"callbacks\", Array.from(this.proxies.values()).reduce((count, proxy) => count + proxy.callbacks.size, 0)),\n\t\t\t\t\tfield(\"success listeners\", this.successEmitter.counts),\n\t\t\t\t\tfield(\"fail listeners\", this.failEmitter.counts),\n\t\t\t\t\tfield(\"event listeners\", this.eventEmitter.counts),\n\t\t\t\t]);\n\t\t\t};\n\n\t\t\t// Uniquely identified items (top-level module proxies) can continue to\n\t\t\t// be used so we don't need to delete them.\n\t\t\tif (typeof proxyId === \"number\") {\n\t\t\t\tconst dispose = (): void => {\n\t\t\t\t\tthis.proxies.delete(proxyId);\n\t\t\t\t\tthis.eventEmitter.dispose(proxyId);\n\t\t\t\t\tlog();\n\t\t\t\t};\n\t\t\t\tif (!this.disconnected) {\n\t\t\t\t\tinstance.dispose().then(dispose).catch(dispose);\n\t\t\t\t} else {\n\t\t\t\t\tdispose();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// The callbacks will still be unusable though.\n\t\t\t\tthis.getProxy(proxyId).callbacks.clear();\n\t\t\t\tlog();\n\t\t\t}\n\t\t});\n\n\t\treturn instance;\n\t}\n\n\t/**\n\t * We aren't guaranteed the promise will call all the `then` callbacks\n\t * synchronously once it resolves, so the event message can come in and fire\n\t * before a caller has been able to attach an event. Waiting for the promise\n\t * ensures it runs after everything else.\n\t */\n\tprivate async ensureResolved(proxyId: number | Module): Promise<void> {\n\t\tawait this.getProxy(proxyId).promise;\n\t}\n\n\t/**\n\t * Same as protoToArgument except provides createProxy.\n\t */\n\tprivate protoToArgument(value?: Argument, promise?: Promise<any>): any {\n\t\treturn protoToArgument(value, undefined, (id) => this.createProxy(id, promise));\n\t}\n\n\t/**\n\t * Get a proxy. Error if it doesn't exist.\n\t */\n\tprivate getProxy(proxyId: number | Module): ProxyData {\n\t\tif (!this.proxies.has(proxyId)) {\n\t\t\tthrow new Error(`proxy ${proxyId} disposed too early`);\n\t\t}\n\n\t\treturn this.proxies.get(proxyId)!;\n\t}\n}\n"]}]}