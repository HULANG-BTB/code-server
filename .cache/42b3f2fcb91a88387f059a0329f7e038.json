{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/indentation/indentation.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/indentation/indentation.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/lifecycle\", \"vs/base/common/strings\", \"vs/editor/browser/editorExtensions\", \"vs/editor/common/commands/shiftCommand\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/range\", \"vs/editor/common/core/selection\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/model/textModel\", \"vs/editor/common/modes\", \"vs/editor/common/modes/languageConfigurationRegistry\", \"vs/editor/common/modes/supports/indentRules\", \"vs/editor/common/services/modelService\", \"vs/editor/contrib/indentation/indentUtils\", \"vs/platform/quickinput/common/quickInput\"], function (require, exports, nls, lifecycle_1, strings, editorExtensions_1, shiftCommand_1, editOperation_1, range_1, selection_1, editorContextKeys_1, textModel_1, modes_1, languageConfigurationRegistry_1, indentRules_1, modelService_1, indentUtils, quickInput_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {\n        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n            // Model is empty\n            return [];\n        }\n        let indentationRules = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentationRules(model.getLanguageIdentifier().id);\n        if (!indentationRules) {\n            return [];\n        }\n        endLineNumber = Math.min(endLineNumber, model.getLineCount());\n        // Skip `unIndentedLinePattern` lines\n        while (startLineNumber <= endLineNumber) {\n            if (!indentationRules.unIndentedLinePattern) {\n                break;\n            }\n            let text = model.getLineContent(startLineNumber);\n            if (!indentationRules.unIndentedLinePattern.test(text)) {\n                break;\n            }\n            startLineNumber++;\n        }\n        if (startLineNumber > endLineNumber - 1) {\n            return [];\n        }\n        const { tabSize, indentSize, insertSpaces } = model.getOptions();\n        const shiftIndent = (indentation, count) => {\n            count = count || 1;\n            return shiftCommand_1.ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n        };\n        const unshiftIndent = (indentation, count) => {\n            count = count || 1;\n            return shiftCommand_1.ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);\n        };\n        let indentEdits = [];\n        // indentation being passed to lines below\n        let globalIndent;\n        // Calculate indentation for the first line\n        // If there is no passed-in indentation, we use the indentation of the first line as base.\n        let currentLineText = model.getLineContent(startLineNumber);\n        let adjustedLineContent = currentLineText;\n        if (inheritedIndent !== undefined && inheritedIndent !== null) {\n            globalIndent = inheritedIndent;\n            let oldIndentation = strings.getLeadingWhitespace(currentLineText);\n            adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n            if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n                globalIndent = unshiftIndent(globalIndent);\n                adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);\n            }\n            if (currentLineText !== adjustedLineContent) {\n                indentEdits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), textModel_1.TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));\n            }\n        }\n        else {\n            globalIndent = strings.getLeadingWhitespace(currentLineText);\n        }\n        // idealIndentForNextLine doesn't equal globalIndent when there is a line matching `indentNextLinePattern`.\n        let idealIndentForNextLine = globalIndent;\n        if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n            idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n            globalIndent = shiftIndent(globalIndent);\n        }\n        else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n            idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n        }\n        startLineNumber++;\n        // Calculate indentation adjustment for all following lines\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            let text = model.getLineContent(lineNumber);\n            let oldIndentation = strings.getLeadingWhitespace(text);\n            let adjustedLineContent = idealIndentForNextLine + text.substring(oldIndentation.length);\n            if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {\n                idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);\n                globalIndent = unshiftIndent(globalIndent);\n            }\n            if (oldIndentation !== idealIndentForNextLine) {\n                indentEdits.push(editOperation_1.EditOperation.replace(new selection_1.Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), textModel_1.TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));\n            }\n            // calculate idealIndentForNextLine\n            if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {\n                // In reindent phase, if the line matches `unIndentedLinePattern` we inherit indentation from above lines\n                // but don't change globalIndent and idealIndentForNextLine.\n                continue;\n            }\n            else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {\n                globalIndent = shiftIndent(globalIndent);\n                idealIndentForNextLine = globalIndent;\n            }\n            else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {\n                idealIndentForNextLine = shiftIndent(idealIndentForNextLine);\n            }\n            else {\n                idealIndentForNextLine = globalIndent;\n            }\n        }\n        return indentEdits;\n    }\n    exports.getReindentEditOperations = getReindentEditOperations;\n    class IndentationToSpacesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: IndentationToSpacesAction.ID,\n                label: nls.localize('indentationToSpaces', \"Convert Indentation to Spaces\"),\n                alias: 'Convert Indentation to Spaces',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        run(accessor, editor) {\n            let model = editor.getModel();\n            if (!model) {\n                return;\n            }\n            let modelOpts = model.getOptions();\n            let selection = editor.getSelection();\n            if (!selection) {\n                return;\n            }\n            const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, [command]);\n            editor.pushUndoStop();\n            model.updateOptions({\n                insertSpaces: true\n            });\n        }\n    }\n    IndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';\n    exports.IndentationToSpacesAction = IndentationToSpacesAction;\n    class IndentationToTabsAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: IndentationToTabsAction.ID,\n                label: nls.localize('indentationToTabs', \"Convert Indentation to Tabs\"),\n                alias: 'Convert Indentation to Tabs',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        run(accessor, editor) {\n            let model = editor.getModel();\n            if (!model) {\n                return;\n            }\n            let modelOpts = model.getOptions();\n            let selection = editor.getSelection();\n            if (!selection) {\n                return;\n            }\n            const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);\n            editor.pushUndoStop();\n            editor.executeCommands(this.id, [command]);\n            editor.pushUndoStop();\n            model.updateOptions({\n                insertSpaces: false\n            });\n        }\n    }\n    IndentationToTabsAction.ID = 'editor.action.indentationToTabs';\n    exports.IndentationToTabsAction = IndentationToTabsAction;\n    class ChangeIndentationSizeAction extends editorExtensions_1.EditorAction {\n        constructor(insertSpaces, opts) {\n            super(opts);\n            this.insertSpaces = insertSpaces;\n        }\n        run(accessor, editor) {\n            const quickInputService = accessor.get(quickInput_1.IQuickInputService);\n            const modelService = accessor.get(modelService_1.IModelService);\n            let model = editor.getModel();\n            if (!model) {\n                return;\n            }\n            let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);\n            const picks = [1, 2, 3, 4, 5, 6, 7, 8].map(n => ({\n                id: n.toString(),\n                label: n.toString(),\n                // add description for tabSize value set in the configuration\n                description: n === creationOpts.tabSize ? nls.localize('configuredTabSize', \"Configured Tab Size\") : undefined\n            }));\n            // auto focus the tabSize set for the current editor\n            const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);\n            setTimeout(() => {\n                quickInputService.pick(picks, { placeHolder: nls.localize({ key: 'selectTabWidth', comment: ['Tab corresponds to the tab key'] }, \"Select Tab Size for Current File\"), activeItem: picks[autoFocusIndex] }).then(pick => {\n                    if (pick) {\n                        if (model && !model.isDisposed()) {\n                            model.updateOptions({\n                                tabSize: parseInt(pick.label, 10),\n                                insertSpaces: this.insertSpaces\n                            });\n                        }\n                    }\n                });\n            }, 50 /* quick open is sensitive to being opened so soon after another */);\n        }\n    }\n    exports.ChangeIndentationSizeAction = ChangeIndentationSizeAction;\n    class IndentUsingTabs extends ChangeIndentationSizeAction {\n        constructor() {\n            super(false, {\n                id: IndentUsingTabs.ID,\n                label: nls.localize('indentUsingTabs', \"Indent Using Tabs\"),\n                alias: 'Indent Using Tabs',\n                precondition: null\n            });\n        }\n    }\n    IndentUsingTabs.ID = 'editor.action.indentUsingTabs';\n    exports.IndentUsingTabs = IndentUsingTabs;\n    class IndentUsingSpaces extends ChangeIndentationSizeAction {\n        constructor() {\n            super(true, {\n                id: IndentUsingSpaces.ID,\n                label: nls.localize('indentUsingSpaces', \"Indent Using Spaces\"),\n                alias: 'Indent Using Spaces',\n                precondition: null\n            });\n        }\n    }\n    IndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';\n    exports.IndentUsingSpaces = IndentUsingSpaces;\n    class DetectIndentation extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: DetectIndentation.ID,\n                label: nls.localize('detectIndentation', \"Detect Indentation from Content\"),\n                alias: 'Detect Indentation from Content',\n                precondition: null\n            });\n        }\n        run(accessor, editor) {\n            const modelService = accessor.get(modelService_1.IModelService);\n            let model = editor.getModel();\n            if (!model) {\n                return;\n            }\n            let creationOpts = modelService.getCreationOptions(model.getLanguageIdentifier().language, model.uri, model.isForSimpleWidget);\n            model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);\n        }\n    }\n    DetectIndentation.ID = 'editor.action.detectIndentation';\n    exports.DetectIndentation = DetectIndentation;\n    class ReindentLinesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.reindentlines',\n                label: nls.localize('editor.reindentlines', \"Reindent Lines\"),\n                alias: 'Reindent Lines',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        run(accessor, editor) {\n            let model = editor.getModel();\n            if (!model) {\n                return;\n            }\n            let edits = getReindentEditOperations(model, 1, model.getLineCount());\n            if (edits.length > 0) {\n                editor.pushUndoStop();\n                editor.executeEdits(this.id, edits);\n                editor.pushUndoStop();\n            }\n        }\n    }\n    exports.ReindentLinesAction = ReindentLinesAction;\n    class ReindentSelectedLinesAction extends editorExtensions_1.EditorAction {\n        constructor() {\n            super({\n                id: 'editor.action.reindentselectedlines',\n                label: nls.localize('editor.reindentselectedlines', \"Reindent Selected Lines\"),\n                alias: 'Reindent Selected Lines',\n                precondition: editorContextKeys_1.EditorContextKeys.writable\n            });\n        }\n        run(accessor, editor) {\n            let model = editor.getModel();\n            if (!model) {\n                return;\n            }\n            let selections = editor.getSelections();\n            if (selections === null) {\n                return;\n            }\n            let edits = [];\n            for (let selection of selections) {\n                let startLineNumber = selection.startLineNumber;\n                let endLineNumber = selection.endLineNumber;\n                if (startLineNumber !== endLineNumber && selection.endColumn === 1) {\n                    endLineNumber--;\n                }\n                if (startLineNumber === 1) {\n                    if (startLineNumber === endLineNumber) {\n                        continue;\n                    }\n                }\n                else {\n                    startLineNumber--;\n                }\n                let editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber);\n                edits.push(...editOperations);\n            }\n            if (edits.length > 0) {\n                editor.pushUndoStop();\n                editor.executeEdits(this.id, edits);\n                editor.pushUndoStop();\n            }\n        }\n    }\n    exports.ReindentSelectedLinesAction = ReindentSelectedLinesAction;\n    class AutoIndentOnPasteCommand {\n        constructor(edits, initialSelection) {\n            this._initialSelection = initialSelection;\n            this._edits = [];\n            for (let edit of edits) {\n                if (edit.range && typeof edit.text === 'string') {\n                    this._edits.push(edit);\n                }\n            }\n        }\n        getEditOperations(model, builder) {\n            for (let edit of this._edits) {\n                builder.addEditOperation(range_1.Range.lift(edit.range), edit.text);\n            }\n            let selectionIsSet = false;\n            if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {\n                if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&\n                    this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {\n                    selectionIsSet = true;\n                    this._selectionId = builder.trackSelection(this._initialSelection, true);\n                }\n                else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&\n                    this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {\n                    selectionIsSet = true;\n                    this._selectionId = builder.trackSelection(this._initialSelection, false);\n                }\n            }\n            if (!selectionIsSet) {\n                this._selectionId = builder.trackSelection(this._initialSelection);\n            }\n        }\n        computeCursorState(model, helper) {\n            return helper.getTrackedSelection(this._selectionId);\n        }\n    }\n    exports.AutoIndentOnPasteCommand = AutoIndentOnPasteCommand;\n    class AutoIndentOnPaste {\n        constructor(editor) {\n            this.editor = editor;\n            this.callOnDispose = [];\n            this.callOnModel = [];\n            this.callOnDispose.push(editor.onDidChangeConfiguration(() => this.update()));\n            this.callOnDispose.push(editor.onDidChangeModel(() => this.update()));\n            this.callOnDispose.push(editor.onDidChangeModelLanguage(() => this.update()));\n        }\n        update() {\n            // clean up\n            this.callOnModel = lifecycle_1.dispose(this.callOnModel);\n            // we are disabled\n            if (!this.editor.getConfiguration().autoIndent || this.editor.getConfiguration().contribInfo.formatOnPaste) {\n                return;\n            }\n            // no model\n            if (!this.editor.hasModel()) {\n                return;\n            }\n            this.callOnModel.push(this.editor.onDidPaste((range) => {\n                this.trigger(range);\n            }));\n        }\n        trigger(range) {\n            let selections = this.editor.getSelections();\n            if (selections === null || selections.length > 1) {\n                return;\n            }\n            const model = this.editor.getModel();\n            if (!model) {\n                return;\n            }\n            if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n                return;\n            }\n            const { tabSize, indentSize, insertSpaces } = model.getOptions();\n            this.editor.pushUndoStop();\n            let textEdits = [];\n            let indentConverter = {\n                shiftIndent: (indentation) => {\n                    return shiftCommand_1.ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n                },\n                unshiftIndent: (indentation) => {\n                    return shiftCommand_1.ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);\n                }\n            };\n            let startLineNumber = range.startLineNumber;\n            while (startLineNumber <= range.endLineNumber) {\n                if (this.shouldIgnoreLine(model, startLineNumber)) {\n                    startLineNumber++;\n                    continue;\n                }\n                break;\n            }\n            if (startLineNumber > range.endLineNumber) {\n                return;\n            }\n            let firstLineText = model.getLineContent(startLineNumber);\n            if (!/\\S/.test(firstLineText.substring(0, range.startColumn - 1))) {\n                let indentOfFirstLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(model, model.getLanguageIdentifier().id, startLineNumber, indentConverter);\n                if (indentOfFirstLine !== null) {\n                    let oldIndentation = strings.getLeadingWhitespace(firstLineText);\n                    let newSpaceCnt = indentUtils.getSpaceCnt(indentOfFirstLine, tabSize);\n                    let oldSpaceCnt = indentUtils.getSpaceCnt(oldIndentation, tabSize);\n                    if (newSpaceCnt !== oldSpaceCnt) {\n                        let newIndent = indentUtils.generateIndent(newSpaceCnt, tabSize, insertSpaces);\n                        textEdits.push({\n                            range: new range_1.Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),\n                            text: newIndent\n                        });\n                        firstLineText = newIndent + firstLineText.substr(oldIndentation.length);\n                    }\n                    else {\n                        let indentMetadata = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);\n                        if (indentMetadata === 0 || indentMetadata === indentRules_1.IndentConsts.UNINDENT_MASK) {\n                            // we paste content into a line where only contains whitespaces\n                            // after pasting, the indentation of the first line is already correct\n                            // the first line doesn't match any indentation rule\n                            // then no-op.\n                            return;\n                        }\n                    }\n                }\n            }\n            const firstLineNumber = startLineNumber;\n            // ignore empty or ignored lines\n            while (startLineNumber < range.endLineNumber) {\n                if (!/\\S/.test(model.getLineContent(startLineNumber + 1))) {\n                    startLineNumber++;\n                    continue;\n                }\n                break;\n            }\n            if (startLineNumber !== range.endLineNumber) {\n                let virtualModel = {\n                    getLineTokens: (lineNumber) => {\n                        return model.getLineTokens(lineNumber);\n                    },\n                    getLanguageIdentifier: () => {\n                        return model.getLanguageIdentifier();\n                    },\n                    getLanguageIdAtPosition: (lineNumber, column) => {\n                        return model.getLanguageIdAtPosition(lineNumber, column);\n                    },\n                    getLineContent: (lineNumber) => {\n                        if (lineNumber === firstLineNumber) {\n                            return firstLineText;\n                        }\n                        else {\n                            return model.getLineContent(lineNumber);\n                        }\n                    }\n                };\n                let indentOfSecondLine = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getGoodIndentForLine(virtualModel, model.getLanguageIdentifier().id, startLineNumber + 1, indentConverter);\n                if (indentOfSecondLine !== null) {\n                    let newSpaceCntOfSecondLine = indentUtils.getSpaceCnt(indentOfSecondLine, tabSize);\n                    let oldSpaceCntOfSecondLine = indentUtils.getSpaceCnt(strings.getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);\n                    if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {\n                        let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;\n                        for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {\n                            let lineContent = model.getLineContent(i);\n                            let originalIndent = strings.getLeadingWhitespace(lineContent);\n                            let originalSpacesCnt = indentUtils.getSpaceCnt(originalIndent, tabSize);\n                            let newSpacesCnt = originalSpacesCnt + spaceCntOffset;\n                            let newIndent = indentUtils.generateIndent(newSpacesCnt, tabSize, insertSpaces);\n                            if (newIndent !== originalIndent) {\n                                textEdits.push({\n                                    range: new range_1.Range(i, 1, i, originalIndent.length + 1),\n                                    text: newIndent\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());\n            this.editor.executeCommand('autoIndentOnPaste', cmd);\n            this.editor.pushUndoStop();\n        }\n        shouldIgnoreLine(model, lineNumber) {\n            model.forceTokenization(lineNumber);\n            let nonWhiteSpaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n            if (nonWhiteSpaceColumn === 0) {\n                return true;\n            }\n            let tokens = model.getLineTokens(lineNumber);\n            if (tokens.getCount() > 0) {\n                let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhiteSpaceColumn);\n                if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === modes_1.StandardTokenType.Comment) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        getId() {\n            return AutoIndentOnPaste.ID;\n        }\n        dispose() {\n            this.callOnDispose = lifecycle_1.dispose(this.callOnDispose);\n            this.callOnModel = lifecycle_1.dispose(this.callOnModel);\n        }\n    }\n    AutoIndentOnPaste.ID = 'editor.contrib.autoIndentOnPaste';\n    exports.AutoIndentOnPaste = AutoIndentOnPaste;\n    function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {\n        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {\n            // Model is empty\n            return;\n        }\n        let spaces = '';\n        for (let i = 0; i < tabSize; i++) {\n            spaces += ' ';\n        }\n        let spacesRegExp = new RegExp(spaces, 'gi');\n        for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {\n            let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);\n            if (lastIndentationColumn === 0) {\n                lastIndentationColumn = model.getLineMaxColumn(lineNumber);\n            }\n            if (lastIndentationColumn === 1) {\n                continue;\n            }\n            const originalIndentationRange = new range_1.Range(lineNumber, 1, lineNumber, lastIndentationColumn);\n            const originalIndentation = model.getValueInRange(originalIndentationRange);\n            const newIndentation = (tabsToSpaces\n                ? originalIndentation.replace(/\\t/ig, spaces)\n                : originalIndentation.replace(spacesRegExp, '\\t'));\n            builder.addEditOperation(originalIndentationRange, newIndentation);\n        }\n    }\n    class IndentationToSpacesCommand {\n        constructor(selection, tabSize) {\n            this.selection = selection;\n            this.tabSize = tabSize;\n        }\n        getEditOperations(model, builder) {\n            this.selectionId = builder.trackSelection(this.selection);\n            getIndentationEditOperations(model, builder, this.tabSize, true);\n        }\n        computeCursorState(model, helper) {\n            return helper.getTrackedSelection(this.selectionId);\n        }\n    }\n    exports.IndentationToSpacesCommand = IndentationToSpacesCommand;\n    class IndentationToTabsCommand {\n        constructor(selection, tabSize) {\n            this.selection = selection;\n            this.tabSize = tabSize;\n        }\n        getEditOperations(model, builder) {\n            this.selectionId = builder.trackSelection(this.selection);\n            getIndentationEditOperations(model, builder, this.tabSize, false);\n        }\n        computeCursorState(model, helper) {\n            return helper.getTrackedSelection(this.selectionId);\n        }\n    }\n    exports.IndentationToTabsCommand = IndentationToTabsCommand;\n    editorExtensions_1.registerEditorContribution(AutoIndentOnPaste);\n    editorExtensions_1.registerEditorAction(IndentationToSpacesAction);\n    editorExtensions_1.registerEditorAction(IndentationToTabsAction);\n    editorExtensions_1.registerEditorAction(IndentUsingTabs);\n    editorExtensions_1.registerEditorAction(IndentUsingSpaces);\n    editorExtensions_1.registerEditorAction(DetectIndentation);\n    editorExtensions_1.registerEditorAction(ReindentLinesAction);\n    editorExtensions_1.registerEditorAction(ReindentSelectedLinesAction);\n});\n",null]}