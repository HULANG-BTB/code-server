{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/fileSearch.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/fileSearch.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"child_process\", \"fs\", \"vs/base/common/path\", \"string_decoder\", \"vs/base/common/arrays\", \"vs/base/common/errorMessage\", \"vs/base/common/glob\", \"vs/base/common/normalization\", \"vs/base/common/objects\", \"vs/base/common/extpath\", \"vs/base/common/platform\", \"vs/base/common/stopwatch\", \"vs/base/common/strings\", \"vs/base/common/types\", \"vs/base/node/extfs\", \"vs/base/node/flow\", \"./ripgrepFileSearch\"], function (require, exports, childProcess, fs, path, string_decoder_1, arrays, errorMessage_1, glob, normalization, objects, extpath_1, platform, stopwatch_1, strings, types, extfs, flow, ripgrepFileSearch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const killCmds = new Set();\n    process.on('exit', () => {\n        killCmds.forEach(cmd => cmd());\n    });\n    class FileWalker {\n        constructor(config) {\n            this.config = config;\n            this.filePattern = config.filePattern || '';\n            this.includePattern = config.includePattern && glob.parse(config.includePattern);\n            this.maxResults = config.maxResults || null;\n            this.exists = !!config.exists;\n            this.walkedPaths = Object.create(null);\n            this.resultCount = 0;\n            this.isLimitHit = false;\n            this.directoriesWalked = 0;\n            this.filesWalked = 0;\n            this.errors = [];\n            if (this.filePattern) {\n                this.normalizedFilePatternLowercase = strings.stripWildcards(this.filePattern).toLowerCase();\n            }\n            this.globalExcludePattern = config.excludePattern && glob.parse(config.excludePattern);\n            this.folderExcludePatterns = new Map();\n            config.folderQueries.forEach(folderQuery => {\n                const folderExcludeExpression = objects.assign({}, folderQuery.excludePattern || {}, this.config.excludePattern || {});\n                // Add excludes for other root folders\n                const fqPath = folderQuery.folder.fsPath;\n                config.folderQueries\n                    .map(rootFolderQuery => rootFolderQuery.folder.fsPath)\n                    .filter(rootFolder => rootFolder !== fqPath)\n                    .forEach(otherRootFolder => {\n                    // Exclude nested root folders\n                    if (extpath_1.isEqualOrParent(otherRootFolder, fqPath)) {\n                        folderExcludeExpression[path.relative(fqPath, otherRootFolder)] = true;\n                    }\n                });\n                this.folderExcludePatterns.set(fqPath, new AbsoluteAndRelativeParsedExpression(folderExcludeExpression, fqPath));\n            });\n        }\n        cancel() {\n            this.isCanceled = true;\n        }\n        walk(folderQueries, extraFiles, onResult, onMessage, done) {\n            this.fileWalkSW = stopwatch_1.StopWatch.create(false);\n            // Support that the file pattern is a full path to a file that exists\n            if (this.isCanceled) {\n                return done(null, this.isLimitHit);\n            }\n            // For each extra file\n            extraFiles.forEach(extraFilePath => {\n                const basename = path.basename(extraFilePath.fsPath);\n                if (this.globalExcludePattern && this.globalExcludePattern(extraFilePath.fsPath, basename)) {\n                    return; // excluded\n                }\n                // File: Check for match on file pattern and include pattern\n                this.matchFile(onResult, { relativePath: extraFilePath.fsPath /* no workspace relative path */, basename });\n            });\n            this.cmdSW = stopwatch_1.StopWatch.create(false);\n            // For each root folder\n            flow.parallel(folderQueries, (folderQuery, rootFolderDone) => {\n                this.call(this.cmdTraversal, this, folderQuery, onResult, onMessage, (err) => {\n                    if (err) {\n                        const errorMessage = errorMessage_1.toErrorMessage(err);\n                        console.error(errorMessage);\n                        this.errors.push(errorMessage);\n                        rootFolderDone(err, undefined);\n                    }\n                    else {\n                        rootFolderDone(null, undefined);\n                    }\n                });\n            }, (errors, result) => {\n                this.fileWalkSW.stop();\n                const err = errors ? arrays.coalesce(errors)[0] : null;\n                done(err, this.isLimitHit);\n            });\n        }\n        call(fun, that, ...args) {\n            try {\n                fun.apply(that, args);\n            }\n            catch (e) {\n                args[args.length - 1](e);\n            }\n        }\n        cmdTraversal(folderQuery, onResult, onMessage, cb) {\n            const rootFolder = folderQuery.folder.fsPath;\n            const isMac = platform.isMacintosh;\n            let cmd;\n            const killCmd = () => cmd && cmd.kill();\n            killCmds.add(killCmd);\n            let done = (err) => {\n                killCmds.delete(killCmd);\n                done = () => { };\n                cb(err);\n            };\n            let leftover = '';\n            const tree = this.initDirectoryTree();\n            let noSiblingsClauses;\n            const ripgrep = ripgrepFileSearch_1.spawnRipgrepCmd(this.config, folderQuery, this.config.includePattern, this.folderExcludePatterns.get(folderQuery.folder.fsPath).expression);\n            cmd = ripgrep.cmd;\n            noSiblingsClauses = !Object.keys(ripgrep.siblingClauses).length;\n            const escapedArgs = ripgrep.rgArgs.args\n                .map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n                .join(' ');\n            let rgCmd = `rg ${escapedArgs}\\n - cwd: ${ripgrep.cwd}`;\n            if (ripgrep.rgArgs.siblingClauses) {\n                rgCmd += `\\n - Sibling clauses: ${JSON.stringify(ripgrep.rgArgs.siblingClauses)}`;\n            }\n            onMessage({ message: rgCmd });\n            this.cmdResultCount = 0;\n            this.collectStdout(cmd, 'utf8', onMessage, (err, stdout, last) => {\n                if (err) {\n                    done(err);\n                    return;\n                }\n                if (this.isLimitHit) {\n                    done();\n                    return;\n                }\n                // Mac: uses NFD unicode form on disk, but we want NFC\n                const normalized = leftover + (isMac ? normalization.normalizeNFC(stdout || '') : stdout);\n                const relativeFiles = normalized.split('\\n');\n                if (last) {\n                    const n = relativeFiles.length;\n                    relativeFiles[n - 1] = relativeFiles[n - 1].trim();\n                    if (!relativeFiles[n - 1]) {\n                        relativeFiles.pop();\n                    }\n                }\n                else {\n                    leftover = relativeFiles.pop() || '';\n                }\n                if (relativeFiles.length && relativeFiles[0].indexOf('\\n') !== -1) {\n                    done(new Error('Splitting up files failed'));\n                    return;\n                }\n                this.cmdResultCount += relativeFiles.length;\n                if (noSiblingsClauses) {\n                    for (const relativePath of relativeFiles) {\n                        const basename = path.basename(relativePath);\n                        this.matchFile(onResult, { base: rootFolder, relativePath, basename });\n                        if (this.isLimitHit) {\n                            killCmd();\n                            break;\n                        }\n                    }\n                    if (last || this.isLimitHit) {\n                        done();\n                    }\n                    return;\n                }\n                // TODO: Optimize siblings clauses with ripgrep here.\n                this.addDirectoryEntries(tree, rootFolder, relativeFiles, onResult);\n                if (last) {\n                    this.matchDirectoryTree(tree, rootFolder, onResult);\n                    done();\n                }\n            });\n        }\n        /**\n         * Public for testing.\n         */\n        spawnFindCmd(folderQuery) {\n            const excludePattern = this.folderExcludePatterns.get(folderQuery.folder.fsPath);\n            const basenames = excludePattern.getBasenameTerms();\n            const pathTerms = excludePattern.getPathTerms();\n            const args = ['-L', '.'];\n            if (basenames.length || pathTerms.length) {\n                args.push('-not', '(', '(');\n                for (const basename of basenames) {\n                    args.push('-name', basename);\n                    args.push('-o');\n                }\n                for (const path of pathTerms) {\n                    args.push('-path', path);\n                    args.push('-o');\n                }\n                args.pop();\n                args.push(')', '-prune', ')');\n            }\n            args.push('-type', 'f');\n            return childProcess.spawn('find', args, { cwd: folderQuery.folder.fsPath });\n        }\n        /**\n         * Public for testing.\n         */\n        readStdout(cmd, encoding, cb) {\n            let all = '';\n            this.collectStdout(cmd, encoding, () => { }, (err, stdout, last) => {\n                if (err) {\n                    cb(err);\n                    return;\n                }\n                all += stdout;\n                if (last) {\n                    cb(null, all);\n                }\n            });\n        }\n        collectStdout(cmd, encoding, onMessage, cb) {\n            let onData = (err, stdout, last) => {\n                if (err || last) {\n                    onData = () => { };\n                    if (this.cmdSW) {\n                        this.cmdSW.stop();\n                    }\n                }\n                cb(err, stdout, last);\n            };\n            let gotData = false;\n            if (cmd.stdout) {\n                // Should be non-null, but #38195\n                this.forwardData(cmd.stdout, encoding, onData);\n                cmd.stdout.once('data', () => gotData = true);\n            }\n            else {\n                onMessage({ message: 'stdout is null' });\n            }\n            let stderr;\n            if (cmd.stderr) {\n                // Should be non-null, but #38195\n                stderr = this.collectData(cmd.stderr);\n            }\n            else {\n                onMessage({ message: 'stderr is null' });\n            }\n            cmd.on('error', (err) => {\n                onData(err);\n            });\n            cmd.on('close', (code) => {\n                // ripgrep returns code=1 when no results are found\n                let stderrText;\n                if (!gotData && (stderrText = this.decodeData(stderr, encoding)) && rgErrorMsgForDisplay(stderrText)) {\n                    onData(new Error(`command failed with error code ${code}: ${this.decodeData(stderr, encoding)}`));\n                }\n                else {\n                    if (this.exists && code === 0) {\n                        this.isLimitHit = true;\n                    }\n                    onData(null, '', true);\n                }\n            });\n        }\n        forwardData(stream, encoding, cb) {\n            const decoder = new string_decoder_1.StringDecoder(encoding);\n            stream.on('data', (data) => {\n                cb(null, decoder.write(data));\n            });\n            return decoder;\n        }\n        collectData(stream) {\n            const buffers = [];\n            stream.on('data', (data) => {\n                buffers.push(data);\n            });\n            return buffers;\n        }\n        decodeData(buffers, encoding) {\n            const decoder = new string_decoder_1.StringDecoder(encoding);\n            return buffers.map(buffer => decoder.write(buffer)).join('');\n        }\n        initDirectoryTree() {\n            const tree = {\n                rootEntries: [],\n                pathToEntries: Object.create(null)\n            };\n            tree.pathToEntries['.'] = tree.rootEntries;\n            return tree;\n        }\n        addDirectoryEntries({ pathToEntries }, base, relativeFiles, onResult) {\n            // Support relative paths to files from a root resource (ignores excludes)\n            if (relativeFiles.indexOf(this.filePattern) !== -1) {\n                const basename = path.basename(this.filePattern);\n                this.matchFile(onResult, { base: base, relativePath: this.filePattern, basename });\n            }\n            function add(relativePath) {\n                const basename = path.basename(relativePath);\n                const dirname = path.dirname(relativePath);\n                let entries = pathToEntries[dirname];\n                if (!entries) {\n                    entries = pathToEntries[dirname] = [];\n                    add(dirname);\n                }\n                entries.push({\n                    base,\n                    relativePath,\n                    basename\n                });\n            }\n            relativeFiles.forEach(add);\n        }\n        matchDirectoryTree({ rootEntries, pathToEntries }, rootFolder, onResult) {\n            const self = this;\n            const excludePattern = this.folderExcludePatterns.get(rootFolder);\n            const filePattern = this.filePattern;\n            function matchDirectory(entries) {\n                self.directoriesWalked++;\n                const hasSibling = glob.hasSiblingFn(() => entries.map(entry => entry.basename));\n                for (let i = 0, n = entries.length; i < n; i++) {\n                    const entry = entries[i];\n                    const { relativePath, basename } = entry;\n                    // Check exclude pattern\n                    // If the user searches for the exact file name, we adjust the glob matching\n                    // to ignore filtering by siblings because the user seems to know what she\n                    // is searching for and we want to include the result in that case anyway\n                    if (excludePattern.test(relativePath, basename, filePattern !== basename ? hasSibling : undefined)) {\n                        continue;\n                    }\n                    const sub = pathToEntries[relativePath];\n                    if (sub) {\n                        matchDirectory(sub);\n                    }\n                    else {\n                        self.filesWalked++;\n                        if (relativePath === filePattern) {\n                            continue; // ignore file if its path matches with the file pattern because that is already matched above\n                        }\n                        self.matchFile(onResult, entry);\n                    }\n                    if (self.isLimitHit) {\n                        break;\n                    }\n                }\n            }\n            matchDirectory(rootEntries);\n        }\n        getStats() {\n            return {\n                cmdTime: this.cmdSW && this.cmdSW.elapsed(),\n                fileWalkTime: this.fileWalkSW.elapsed(),\n                directoriesWalked: this.directoriesWalked,\n                filesWalked: this.filesWalked,\n                cmdResultCount: this.cmdResultCount\n            };\n        }\n        doWalk(folderQuery, relativeParentPath, files, onResult, done) {\n            const rootFolder = folderQuery.folder;\n            // Execute tasks on each file in parallel to optimize throughput\n            const hasSibling = glob.hasSiblingFn(() => files);\n            flow.parallel(files, (file, clb) => {\n                // Check canceled\n                if (this.isCanceled || this.isLimitHit) {\n                    return clb(null);\n                }\n                // Check exclude pattern\n                // If the user searches for the exact file name, we adjust the glob matching\n                // to ignore filtering by siblings because the user seems to know what she\n                // is searching for and we want to include the result in that case anyway\n                const currentRelativePath = relativeParentPath ? [relativeParentPath, file].join(path.sep) : file;\n                if (this.folderExcludePatterns.get(folderQuery.folder.fsPath).test(currentRelativePath, file, this.config.filePattern !== file ? hasSibling : undefined)) {\n                    return clb(null);\n                }\n                // Use lstat to detect links\n                const currentAbsolutePath = [rootFolder.fsPath, currentRelativePath].join(path.sep);\n                fs.lstat(currentAbsolutePath, (error, lstat) => {\n                    if (error || this.isCanceled || this.isLimitHit) {\n                        return clb(null);\n                    }\n                    // If the path is a link, we must instead use fs.stat() to find out if the\n                    // link is a directory or not because lstat will always return the stat of\n                    // the link which is always a file.\n                    this.statLinkIfNeeded(currentAbsolutePath, lstat, (error, stat) => {\n                        if (error || this.isCanceled || this.isLimitHit) {\n                            return clb(null);\n                        }\n                        // Directory: Follow directories\n                        if (stat.isDirectory()) {\n                            this.directoriesWalked++;\n                            // to really prevent loops with links we need to resolve the real path of them\n                            return this.realPathIfNeeded(currentAbsolutePath, lstat, (error, realpath) => {\n                                if (error || this.isCanceled || this.isLimitHit) {\n                                    return clb(null);\n                                }\n                                realpath = realpath || '';\n                                if (this.walkedPaths[realpath]) {\n                                    return clb(null); // escape when there are cycles (can happen with symlinks)\n                                }\n                                this.walkedPaths[realpath] = true; // remember as walked\n                                // Continue walking\n                                return extfs.readdir(currentAbsolutePath, (error, children) => {\n                                    if (error || this.isCanceled || this.isLimitHit) {\n                                        return clb(null);\n                                    }\n                                    this.doWalk(folderQuery, currentRelativePath, children, onResult, err => clb(err || null));\n                                });\n                            });\n                        }\n                        // File: Check for match on file pattern and include pattern\n                        else {\n                            this.filesWalked++;\n                            if (currentRelativePath === this.filePattern) {\n                                return clb(null, undefined); // ignore file if its path matches with the file pattern because checkFilePatternRelativeMatch() takes care of those\n                            }\n                            if (this.maxFilesize && types.isNumber(stat.size) && stat.size > this.maxFilesize) {\n                                return clb(null, undefined); // ignore file if max file size is hit\n                            }\n                            this.matchFile(onResult, { base: rootFolder.fsPath, relativePath: currentRelativePath, basename: file, size: stat.size });\n                        }\n                        // Unwind\n                        return clb(null, undefined);\n                    });\n                });\n            }, (error) => {\n                if (error) {\n                    error = arrays.coalesce(error); // find any error by removing null values first\n                }\n                return done(error && error.length > 0 ? error[0] : undefined);\n            });\n        }\n        matchFile(onResult, candidate) {\n            if (this.isFilePatternMatch(candidate.relativePath) && (!this.includePattern || this.includePattern(candidate.relativePath, candidate.basename))) {\n                this.resultCount++;\n                if (this.exists || (this.maxResults && this.resultCount > this.maxResults)) {\n                    this.isLimitHit = true;\n                }\n                if (!this.isLimitHit) {\n                    onResult(candidate);\n                }\n            }\n        }\n        isFilePatternMatch(path) {\n            // Check for search pattern\n            if (this.filePattern) {\n                if (this.filePattern === '*') {\n                    return true; // support the all-matching wildcard\n                }\n                return strings.fuzzyContains(path, this.normalizedFilePatternLowercase);\n            }\n            // No patterns means we match all\n            return true;\n        }\n        statLinkIfNeeded(path, lstat, clb) {\n            if (lstat.isSymbolicLink()) {\n                return fs.stat(path, clb); // stat the target the link points to\n            }\n            return clb(null, lstat); // not a link, so the stat is already ok for us\n        }\n        realPathIfNeeded(path, lstat, clb) {\n            if (lstat.isSymbolicLink()) {\n                return fs.realpath(path, (error, realpath) => {\n                    if (error) {\n                        return clb(error);\n                    }\n                    return clb(null, realpath);\n                });\n            }\n            return clb(null, path);\n        }\n    }\n    exports.FileWalker = FileWalker;\n    class Engine {\n        constructor(config) {\n            this.folderQueries = config.folderQueries;\n            this.extraFiles = config.extraFileResources || [];\n            this.walker = new FileWalker(config);\n        }\n        search(onResult, onProgress, done) {\n            this.walker.walk(this.folderQueries, this.extraFiles, onResult, onProgress, (err, isLimitHit) => {\n                done(err, {\n                    limitHit: isLimitHit,\n                    stats: this.walker.getStats()\n                });\n            });\n        }\n        cancel() {\n            this.walker.cancel();\n        }\n    }\n    exports.Engine = Engine;\n    /**\n     * This class exists to provide one interface on top of two ParsedExpressions, one for absolute expressions and one for relative expressions.\n     * The absolute and relative expressions don't \"have\" to be kept separate, but this keeps us from having to path.join every single\n     * file searched, it's only used for a text search with a searchPath\n     */\n    class AbsoluteAndRelativeParsedExpression {\n        constructor(expression, root) {\n            this.expression = expression;\n            this.root = root;\n            this.init(expression);\n        }\n        /**\n         * Split the IExpression into its absolute and relative components, and glob.parse them separately.\n         */\n        init(expr) {\n            let absoluteGlobExpr;\n            let relativeGlobExpr;\n            Object.keys(expr)\n                .filter(key => expr[key])\n                .forEach(key => {\n                if (path.isAbsolute(key)) {\n                    absoluteGlobExpr = absoluteGlobExpr || glob.getEmptyExpression();\n                    absoluteGlobExpr[key] = expr[key];\n                }\n                else {\n                    relativeGlobExpr = relativeGlobExpr || glob.getEmptyExpression();\n                    relativeGlobExpr[key] = expr[key];\n                }\n            });\n            this.absoluteParsedExpr = absoluteGlobExpr && glob.parse(absoluteGlobExpr, { trimForExclusions: true });\n            this.relativeParsedExpr = relativeGlobExpr && glob.parse(relativeGlobExpr, { trimForExclusions: true });\n        }\n        test(_path, basename, hasSibling) {\n            return (this.relativeParsedExpr && this.relativeParsedExpr(_path, basename, hasSibling)) ||\n                (this.absoluteParsedExpr && this.absoluteParsedExpr(path.join(this.root, _path), basename, hasSibling));\n        }\n        getBasenameTerms() {\n            const basenameTerms = [];\n            if (this.absoluteParsedExpr) {\n                basenameTerms.push(...glob.getBasenameTerms(this.absoluteParsedExpr));\n            }\n            if (this.relativeParsedExpr) {\n                basenameTerms.push(...glob.getBasenameTerms(this.relativeParsedExpr));\n            }\n            return basenameTerms;\n        }\n        getPathTerms() {\n            const pathTerms = [];\n            if (this.absoluteParsedExpr) {\n                pathTerms.push(...glob.getPathTerms(this.absoluteParsedExpr));\n            }\n            if (this.relativeParsedExpr) {\n                pathTerms.push(...glob.getPathTerms(this.relativeParsedExpr));\n            }\n            return pathTerms;\n        }\n    }\n    function rgErrorMsgForDisplay(msg) {\n        const lines = msg.trim().split('\\n');\n        const firstLine = lines[0].trim();\n        if (strings.startsWith(firstLine, 'Error parsing regex')) {\n            return firstLine;\n        }\n        if (strings.startsWith(firstLine, 'regex parse error')) {\n            return strings.uppercaseFirstLetter(lines[lines.length - 1].trim());\n        }\n        if (strings.startsWith(firstLine, 'error parsing glob') ||\n            strings.startsWith(firstLine, 'unsupported encoding')) {\n            // Uppercase first letter\n            return firstLine.charAt(0).toUpperCase() + firstLine.substr(1);\n        }\n        if (firstLine === `Literal '\\\\n' not allowed.`) {\n            // I won't localize this because none of the Ripgrep error messages are localized\n            return `Literal '\\\\n' currently not supported`;\n        }\n        if (strings.startsWith(firstLine, 'Literal ')) {\n            // Other unsupported chars\n            return firstLine;\n        }\n        return undefined;\n    }\n    exports.rgErrorMsgForDisplay = rgErrorMsgForDisplay;\n});\n",null]}