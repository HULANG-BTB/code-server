{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorTypeOperations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorTypeOperations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar strings = require(\"vs/base/common/strings\");\nvar replaceCommand_1 = require(\"vs/editor/common/commands/replaceCommand\");\nvar shiftCommand_1 = require(\"vs/editor/common/commands/shiftCommand\");\nvar surroundSelectionCommand_1 = require(\"vs/editor/common/commands/surroundSelectionCommand\");\nvar cursorCommon_1 = require(\"vs/editor/common/controller/cursorCommon\");\nvar wordCharacterClassifier_1 = require(\"vs/editor/common/controller/wordCharacterClassifier\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar languageConfiguration_1 = require(\"vs/editor/common/modes/languageConfiguration\");\nvar languageConfigurationRegistry_1 = require(\"vs/editor/common/modes/languageConfigurationRegistry\");\nvar TypeOperations = /** @class */ (function () {\n    function TypeOperations() {\n    }\n    TypeOperations.indent = function (config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new shiftCommand_1.ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops\n            });\n        }\n        return commands;\n    };\n    TypeOperations.outdent = function (config, model, selections) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new shiftCommand_1.ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops\n            });\n        }\n        return commands;\n    };\n    TypeOperations.shiftIndent = function (config, indentation, count) {\n        count = count || 1;\n        return shiftCommand_1.ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    };\n    TypeOperations.unshiftIndent = function (config, indentation, count) {\n        count = count || 1;\n        return shiftCommand_1.ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    };\n    TypeOperations._distributedPaste = function (config, model, selections, text) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new replaceCommand_1.ReplaceCommand(selections[i], text[i]);\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    };\n    TypeOperations._simplePaste = function (config, model, selections, text, pasteOnNewLine) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            var position = selection.getPosition();\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new replaceCommand_1.ReplaceCommand(typeSelection, text);\n            }\n            else {\n                commands[i] = new replaceCommand_1.ReplaceCommand(selection, text);\n            }\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    };\n    TypeOperations._distributePasteToCursors = function (selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        // Remove trailing \\n if present\n        if (text.charCodeAt(text.length - 1) === charCode_1.CharCode.LineFeed) {\n            text = text.substr(0, text.length - 1);\n        }\n        var lines = text.split(/\\r\\n|\\r|\\n/);\n        if (lines.length === selections.length) {\n            return lines;\n        }\n        return null;\n    };\n    TypeOperations.paste = function (config, model, selections, text, pasteOnNewLine, multicursorText) {\n        var distributedPaste = this._distributePasteToCursors(selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(range_1.Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    };\n    TypeOperations._goodIndentForLine = function (config, model, lineNumber) {\n        var action = null;\n        var indentation = '';\n        var expectedIndentAction = config.autoIndent ? languageConfigurationRegistry_1.LanguageConfigurationRegistry.getInheritIndentForLine(model, lineNumber, false) : null;\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            var lastLineNumber = void 0;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                var lineText = model.getLineContent(lastLineNumber);\n                var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            var maxColumn = model.getLineMaxColumn(lastLineNumber);\n            var expectedEnterAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterAction(model, new range_1.Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation;\n                action = expectedEnterAction.enterAction;\n                if (action) {\n                    indentation += action.appendText;\n                }\n            }\n        }\n        if (action) {\n            if (action === languageConfiguration_1.IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === languageConfiguration_1.IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    };\n    TypeOperations._replaceJumpToNextIndent = function (config, model, selection, insertsAutoWhitespace) {\n        var typeText = '';\n        var position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            var visibleColumnFromColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);\n            var indentSize = config.indentSize;\n            var spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (var i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new replaceCommand_1.ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    };\n    TypeOperations.tab = function (config, model, selections) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            if (selection.isEmpty()) {\n                var lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n                    var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    var possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!strings.startsWith(lineText, possibleTypeText)) {\n                        commands[i] = new replaceCommand_1.ReplaceCommand(new range_1.Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new shiftCommand_1.ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops\n                });\n            }\n        }\n        return commands;\n    };\n    TypeOperations.replacePreviousChar = function (prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            if (!selection.isEmpty()) {\n                // looks like https://github.com/Microsoft/vscode/issues/2773\n                // where a cursor operation occurred before a canceled composition\n                // => ignore composition\n                commands[i] = null;\n                continue;\n            }\n            var pos = selection.getPosition();\n            var startColumn = Math.max(1, pos.column - replaceCharCnt);\n            var range = new range_1.Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\n            commands[i] = new replaceCommand_1.ReplaceCommand(range, txt);\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n            shouldPushStackElementBefore: (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing),\n            shouldPushStackElementAfter: false\n        });\n    };\n    TypeOperations._typeCommand = function (range, text, keepPosition) {\n        if (keepPosition) {\n            return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new replaceCommand_1.ReplaceCommand(range, text, true);\n        }\n    };\n    TypeOperations._enter = function (config, model, keepPosition, range) {\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n            var lineText_1 = model.getLineContent(range.startLineNumber);\n            var indentation_1 = strings.getLeadingWhitespace(lineText_1).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_1), keepPosition);\n        }\n        var r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterAction(model, range);\n        if (r) {\n            var enterAction = r.enterAction;\n            var indentation_2 = r.indentation;\n            if (enterAction.indentAction === languageConfiguration_1.IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_2 + enterAction.appendText), keepPosition);\n            }\n            else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_2 + enterAction.appendText), keepPosition);\n            }\n            else if (enterAction.indentAction === languageConfiguration_1.IndentAction.IndentOutdent) {\n                // Ultra special\n                var normalIndent = config.normalizeIndentation(indentation_2);\n                var increasedIndent = config.normalizeIndentation(indentation_2 + enterAction.appendText);\n                var typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Outdent) {\n                var actualIndentation = TypeOperations.unshiftIndent(config, indentation_2);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);\n            }\n        }\n        // no enter rules applied, we should check indentation rules then.\n        if (!config.autoIndent) {\n            // Nothing special\n            var lineText_2 = model.getLineContent(range.startLineNumber);\n            var indentation_3 = strings.getLeadingWhitespace(lineText_2).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation_3), keepPosition);\n        }\n        var ir = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentForEnter(model, range, {\n            unshiftIndent: function (indent) {\n                return TypeOperations.unshiftIndent(config, indent);\n            },\n            shiftIndent: function (indent) {\n                return TypeOperations.shiftIndent(config, indent);\n            },\n            normalizeIndentation: function (indent) {\n                return config.normalizeIndentation(indent);\n            }\n        }, config.autoIndent);\n        var lineText = model.getLineContent(range.startLineNumber);\n        var indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (ir) {\n            var oldEndViewColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n            var oldEndColumn = range.endColumn;\n            var beforeText = '\\n';\n            if (indentation !== config.normalizeIndentation(ir.beforeEnter)) {\n                beforeText = config.normalizeIndentation(ir.beforeEnter) + lineText.substring(indentation.length, range.startColumn - 1) + '\\n';\n                range = new range_1.Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn);\n            }\n            var newLineContent = model.getLineContent(range.endLineNumber);\n            var firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n            if (firstNonWhitespace >= 0) {\n                range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n            }\n            else {\n                range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n            }\n            if (keepPosition) {\n                return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, beforeText + config.normalizeIndentation(ir.afterEnter), true);\n            }\n            else {\n                var offset = 0;\n                if (oldEndColumn <= firstNonWhitespace + 1) {\n                    if (!config.insertSpaces) {\n                        oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                    }\n                    offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                }\n                return new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, beforeText + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n            }\n        }\n        else {\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n    };\n    TypeOperations._isAutoIndentType = function (config, model, selections) {\n        if (!config.autoIndent) {\n            return false;\n        }\n        for (var i = 0, len = selections.length; i < len; i++) {\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    TypeOperations._runAutoIndentType = function (config, model, range, ch) {\n        var currentIndentation = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        var actualIndentation = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getIndentActionForType(model, range, ch, {\n            shiftIndent: function (indentation) {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: function (indentation) {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        });\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            var firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new range_1.Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new range_1.Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    };\n    TypeOperations._isAutoClosingCloseCharType = function (config, model, selections, ch) {\n        var autoCloseConfig = cursorCommon_1.isQuote(ch) ? config.autoClosingQuotes : config.autoClosingBrackets;\n        if (autoCloseConfig === 'never' || !config.autoClosingPairsClose.hasOwnProperty(ch)) {\n            return false;\n        }\n        var isEqualPair = (ch === config.autoClosingPairsClose[ch]);\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            var position = selection.getPosition();\n            var lineText = model.getLineContent(position.lineNumber);\n            var afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            if (isEqualPair) {\n                var lineTextBeforeCursor = lineText.substr(0, position.column - 1);\n                var chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);\n                if (chCntBefore % 2 === 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    TypeOperations._countNeedlesInHaystack = function (haystack, needle) {\n        var cnt = 0;\n        var lastIndex = -1;\n        while ((lastIndex = haystack.indexOf(needle, lastIndex + 1)) !== -1) {\n            cnt++;\n        }\n        return cnt;\n    };\n    TypeOperations._runAutoClosingCloseCharType = function (prevEditOperationType, config, model, selections, ch) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            var position = selection.getPosition();\n            var typeSelection = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new replaceCommand_1.ReplaceCommand(typeSelection, ch);\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n            shouldPushStackElementBefore: (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing),\n            shouldPushStackElementAfter: false\n        });\n    };\n    TypeOperations._isBeforeClosingBrace = function (config, ch, characterAfter) {\n        var thisBraceIsSymmetric = (config.autoClosingPairsOpen[ch] === ch);\n        var isBeforeCloseBrace = false;\n        for (var otherCloseBrace in config.autoClosingPairsClose) {\n            var otherBraceIsSymmetric = (config.autoClosingPairsOpen[otherCloseBrace] === otherCloseBrace);\n            if (!thisBraceIsSymmetric && otherBraceIsSymmetric) {\n                continue;\n            }\n            if (characterAfter === otherCloseBrace) {\n                isBeforeCloseBrace = true;\n                break;\n            }\n        }\n        return isBeforeCloseBrace;\n    };\n    TypeOperations._isAutoClosingOpenCharType = function (config, model, selections, ch) {\n        var chIsQuote = cursorCommon_1.isQuote(ch);\n        var autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n        if (autoCloseConfig === 'never' || !config.autoClosingPairsOpen.hasOwnProperty(ch)) {\n            return false;\n        }\n        var shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            var position = selection.getPosition();\n            var lineText = model.getLineContent(position.lineNumber);\n            // Do not auto-close ' or \" after a word character\n            if ((chIsQuote && position.column > 1) && autoCloseConfig !== 'always') {\n                var wordSeparators = wordCharacterClassifier_1.getMapForWordSeparators(config.wordSeparators);\n                var characterBeforeCode = lineText.charCodeAt(position.column - 2);\n                var characterBeforeType = wordSeparators.get(characterBeforeCode);\n                if (characterBeforeType === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    return false;\n                }\n            }\n            // Only consider auto closing the pair if a space follows or if another autoclosed pair follows\n            var characterAfter = lineText.charAt(position.column - 1);\n            if (characterAfter) {\n                var isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, ch, characterAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return false;\n                }\n            }\n            if (!model.isCheapToTokenize(position.lineNumber)) {\n                // Do not force tokenization\n                return false;\n            }\n            model.forceTokenization(position.lineNumber);\n            var lineTokens = model.getLineTokens(position.lineNumber);\n            var shouldAutoClosePair = false;\n            try {\n                shouldAutoClosePair = languageConfigurationRegistry_1.LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column);\n            }\n            catch (e) {\n                errors_1.onUnexpectedError(e);\n            }\n            if (!shouldAutoClosePair) {\n                return false;\n            }\n        }\n        return true;\n    };\n    TypeOperations._runAutoClosingOpenCharType = function (prevEditOperationType, config, model, selections, ch) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            var closeCharacter = config.autoClosingPairsOpen[ch];\n            commands[i] = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length);\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    };\n    TypeOperations._shouldSurroundChar = function (config, ch) {\n        if (cursorCommon_1.isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    };\n    TypeOperations._isSurroundSelectionType = function (config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        var isTypingAQuoteCharacter = cursorCommon_1.isQuote(ch);\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            if (selection.isEmpty()) {\n                return false;\n            }\n            var selectionContainsOnlyWhitespace = true;\n            for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                var lineText = model.getLineContent(lineNumber);\n                var startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                var endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                var selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                var selectionText = model.getValueInRange(selection);\n                if (cursorCommon_1.isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    TypeOperations._runSurroundSelectionType = function (prevEditOperationType, config, model, selections, ch) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var selection = selections[i];\n            var closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new surroundSelectionCommand_1.SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Other, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    };\n    TypeOperations._isTypeInterceptorElectricChar = function (config, model, selections) {\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    };\n    TypeOperations._typeInterceptorElectricChar = function (prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        var position = selection.getPosition();\n        model.forceTokenization(position.lineNumber);\n        var lineTokens = model.getLineTokens(position.lineNumber);\n        var electricAction;\n        try {\n            electricAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            errors_1.onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.appendText) {\n            var command = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + electricAction.appendText, 0, -electricAction.appendText.length);\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: true\n            });\n        }\n        if (electricAction.matchOpenBracket) {\n            var endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            var match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            });\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                var matchLine = model.getLineContent(match.startLineNumber);\n                var matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                var newIndentation = config.normalizeIndentation(matchLineIndentation);\n                var lineText = model.getLineContent(position.lineNumber);\n                var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                var typeText = newIndentation + prefix + ch;\n                var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, position.column);\n                var command = new replaceCommand_1.ReplaceCommand(typeSelection, typeText);\n                return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    };\n    TypeOperations.compositionEndWithInterceptors = function (prevEditOperationType, config, model, selections) {\n        if (config.autoClosingQuotes === 'never') {\n            return null;\n        }\n        var commands = [];\n        for (var i = 0; i < selections.length; i++) {\n            if (!selections[i].isEmpty()) {\n                continue;\n            }\n            var position = selections[i].getPosition();\n            var lineText = model.getLineContent(position.lineNumber);\n            var ch = lineText.charAt(position.column - 2);\n            if (config.autoClosingPairsClose.hasOwnProperty(ch)) { // first of all, it's a closing tag\n                if (ch === config.autoClosingPairsClose[ch] /** isEqualPair */) {\n                    var lineTextBeforeCursor = lineText.substr(0, position.column - 2);\n                    var chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);\n                    if (chCntBefore % 2 === 1) {\n                        continue; // it pairs with the opening tag.\n                    }\n                }\n            }\n            // As we are not typing in a new character, so we don't need to run `_runAutoClosingCloseCharType`\n            // Next step, let's try to check if it's an open char.\n            if (config.autoClosingPairsOpen.hasOwnProperty(ch)) {\n                if (cursorCommon_1.isQuote(ch) && position.column > 2) {\n                    var wordSeparators = wordCharacterClassifier_1.getMapForWordSeparators(config.wordSeparators);\n                    var characterBeforeCode = lineText.charCodeAt(position.column - 3);\n                    var characterBeforeType = wordSeparators.get(characterBeforeCode);\n                    if (characterBeforeType === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                        continue;\n                    }\n                }\n                var characterAfter = lineText.charAt(position.column - 1);\n                if (characterAfter) {\n                    var isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, ch, characterAfter);\n                    var shouldAutoCloseBefore = cursorCommon_1.isQuote(ch) ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n                    if (isBeforeCloseBrace) {\n                        // In normal auto closing logic, we will auto close if the cursor is even before a closing brace intentionally.\n                        // However for composition mode, we do nothing here as users might clear all the characters for composition and we don't want to do a unnecessary auto close.\n                        // Related: microsoft/vscode#57250.\n                        continue;\n                    }\n                    if (!shouldAutoCloseBefore(characterAfter)) {\n                        continue;\n                    }\n                }\n                if (!model.isCheapToTokenize(position.lineNumber)) {\n                    // Do not force tokenization\n                    continue;\n                }\n                model.forceTokenization(position.lineNumber);\n                var lineTokens = model.getLineTokens(position.lineNumber);\n                var shouldAutoClosePair = false;\n                try {\n                    shouldAutoClosePair = languageConfigurationRegistry_1.LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column - 1);\n                }\n                catch (e) {\n                    errors_1.onUnexpectedError(e);\n                }\n                if (shouldAutoClosePair) {\n                    var closeCharacter = config.autoClosingPairsOpen[ch];\n                    commands[i] = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selections[i], closeCharacter, 0, -closeCharacter.length);\n                }\n            }\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    };\n    TypeOperations.typeWithInterceptors = function (prevEditOperationType, config, model, selections, ch) {\n        if (ch === '\\n') {\n            var commands_1 = [];\n            for (var i = 0, len = selections.length; i < len; i++) {\n                commands_1[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands_1, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (this._isAutoIndentType(config, model, selections)) {\n            var commands_2 = [];\n            var autoIndentFails = false;\n            for (var i = 0, len = selections.length; i < len; i++) {\n                commands_2[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands_2[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands_2, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingCloseCharType(config, model, selections, ch)) {\n            return this._runAutoClosingCloseCharType(prevEditOperationType, config, model, selections, ch);\n        }\n        if (this._isAutoClosingOpenCharType(config, model, selections, ch)) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch);\n        }\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (this._isTypeInterceptorElectricChar(config, model, selections)) {\n            var r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new replaceCommand_1.ReplaceCommand(selections[i], ch);\n        }\n        var shouldPushStackElementBefore = (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing);\n        if (ch === ' ') {\n            shouldPushStackElementBefore = true;\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBefore,\n            shouldPushStackElementAfter: false\n        });\n    };\n    TypeOperations.typeWithoutInterceptors = function (prevEditOperationType, config, model, selections, str) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new replaceCommand_1.ReplaceCommand(selections[i], str);\n        }\n        return new cursorCommon_1.EditOperationResult(cursorCommon_1.EditOperationType.Typing, commands, {\n            shouldPushStackElementBefore: (prevEditOperationType !== cursorCommon_1.EditOperationType.Typing),\n            shouldPushStackElementAfter: false\n        });\n    };\n    TypeOperations.lineInsertBefore = function (config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(new range_1.Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                var column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new range_1.Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    };\n    TypeOperations.lineInsertAfter = function (config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            var lineNumber = selections[i].positionLineNumber;\n            var column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new range_1.Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    };\n    TypeOperations.lineBreakInsert = function (config, model, selections) {\n        var commands = [];\n        for (var i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    };\n    return TypeOperations;\n}());\nexports.TypeOperations = TypeOperations;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorTypeOperations.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorTypeOperations.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport * as strings from 'vs/base/common/strings';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition } from 'vs/editor/common/commands/replaceCommand';\nimport { ShiftCommand } from 'vs/editor/common/commands/shiftCommand';\nimport { SurroundSelectionCommand } from 'vs/editor/common/commands/surroundSelectionCommand';\nimport { CursorColumns, CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel, isQuote } from 'vs/editor/common/controller/cursorCommon';\nimport { WordCharacterClass, getMapForWordSeparators } from 'vs/editor/common/controller/wordCharacterClassifier';\nimport { Range } from 'vs/editor/common/core/range';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport { ICommand } from 'vs/editor/common/editorCommon';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { EnterAction, IndentAction } from 'vs/editor/common/modes/languageConfiguration';\nimport { LanguageConfigurationRegistry } from 'vs/editor/common/modes/languageConfigurationRegistry';\nimport { IElectricAction } from 'vs/editor/common/modes/supports/electricCharacter';\n\nexport class TypeOperations {\n\n\tpublic static indent(config: CursorConfiguration, model: ICursorSimpleModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ShiftCommand(selections[i], {\n\t\t\t\tisUnshift: false,\n\t\t\t\ttabSize: config.tabSize,\n\t\t\t\tindentSize: config.indentSize,\n\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\tuseTabStops: config.useTabStops\n\t\t\t});\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static outdent(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): ICommand[] {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ShiftCommand(selections[i], {\n\t\t\t\tisUnshift: true,\n\t\t\t\ttabSize: config.tabSize,\n\t\t\t\tindentSize: config.indentSize,\n\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\tuseTabStops: config.useTabStops\n\t\t\t});\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static shiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\t\tcount = count || 1;\n\t\treturn ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n\t}\n\n\tpublic static unshiftIndent(config: CursorConfiguration, indentation: string, count?: number): string {\n\t\tcount = count || 1;\n\t\treturn ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n\t}\n\n\tprivate static _distributedPaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string[]): EditOperationResult {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], text[i]);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _simplePaste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean): EditOperationResult {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tlet position = selection.getPosition();\n\n\t\t\tif (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\t\t\tif (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {\n\t\t\t\tpasteOnNewLine = false;\n\t\t\t}\n\n\t\t\tif (pasteOnNewLine) {\n\t\t\t\t// Paste entire line at the beginning of line\n\t\t\t\tlet typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n\t\t\t\tcommands[i] = new ReplaceCommand(typeSelection, text);\n\t\t\t} else {\n\t\t\t\tcommands[i] = new ReplaceCommand(selection, text);\n\t\t\t}\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _distributePasteToCursors(selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): string[] | null {\n\t\tif (pasteOnNewLine) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (selections.length === 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (multicursorText && multicursorText.length === selections.length) {\n\t\t\treturn multicursorText;\n\t\t}\n\n\t\t// Remove trailing \\n if present\n\t\tif (text.charCodeAt(text.length - 1) === CharCode.LineFeed) {\n\t\t\ttext = text.substr(0, text.length - 1);\n\t\t}\n\t\tlet lines = text.split(/\\r\\n|\\r|\\n/);\n\t\tif (lines.length === selections.length) {\n\t\t\treturn lines;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic static paste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): EditOperationResult {\n\t\tconst distributedPaste = this._distributePasteToCursors(selections, text, pasteOnNewLine, multicursorText);\n\n\t\tif (distributedPaste) {\n\t\t\tselections = selections.sort(Range.compareRangesUsingStarts);\n\t\t\treturn this._distributedPaste(config, model, selections, distributedPaste);\n\t\t} else {\n\t\t\treturn this._simplePaste(config, model, selections, text, pasteOnNewLine);\n\t\t}\n\t}\n\n\tprivate static _goodIndentForLine(config: CursorConfiguration, model: ITextModel, lineNumber: number): string | null {\n\t\tlet action: IndentAction | EnterAction | null = null;\n\t\tlet indentation: string = '';\n\n\t\tlet expectedIndentAction = config.autoIndent ? LanguageConfigurationRegistry.getInheritIndentForLine(model, lineNumber, false) : null;\n\t\tif (expectedIndentAction) {\n\t\t\taction = expectedIndentAction.action;\n\t\t\tindentation = expectedIndentAction.indentation;\n\t\t} else if (lineNumber > 1) {\n\t\t\tlet lastLineNumber: number;\n\t\t\tfor (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n\t\t\t\tlet lineText = model.getLineContent(lastLineNumber);\n\t\t\t\tlet nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\t\t\t\tif (nonWhitespaceIdx >= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (lastLineNumber < 1) {\n\t\t\t\t// No previous line with content found\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet maxColumn = model.getLineMaxColumn(lastLineNumber);\n\t\t\tlet expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n\t\t\tif (expectedEnterAction) {\n\t\t\t\tindentation = expectedEnterAction.indentation;\n\t\t\t\taction = expectedEnterAction.enterAction;\n\t\t\t\tif (action) {\n\t\t\t\t\tindentation += action.appendText;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (action) {\n\t\t\tif (action === IndentAction.Indent) {\n\t\t\t\tindentation = TypeOperations.shiftIndent(config, indentation);\n\t\t\t}\n\n\t\t\tif (action === IndentAction.Outdent) {\n\t\t\t\tindentation = TypeOperations.unshiftIndent(config, indentation);\n\t\t\t}\n\n\t\t\tindentation = config.normalizeIndentation(indentation);\n\t\t}\n\n\t\tif (!indentation) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn indentation;\n\t}\n\n\tprivate static _replaceJumpToNextIndent(config: CursorConfiguration, model: ICursorSimpleModel, selection: Selection, insertsAutoWhitespace: boolean): ReplaceCommand {\n\t\tlet typeText = '';\n\n\t\tlet position = selection.getStartPosition();\n\t\tif (config.insertSpaces) {\n\t\t\tlet visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n\t\t\tlet indentSize = config.indentSize;\n\t\t\tlet spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n\t\t\tfor (let i = 0; i < spacesCnt; i++) {\n\t\t\t\ttypeText += ' ';\n\t\t\t}\n\t\t} else {\n\t\t\ttypeText = '\\t';\n\t\t}\n\n\t\treturn new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n\t}\n\n\tpublic static tab(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tif (selection.isEmpty()) {\n\n\t\t\t\tlet lineText = model.getLineContent(selection.startLineNumber);\n\n\t\t\t\tif (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n\t\t\t\t\tlet goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\t\t\t\t\tgoodIndent = goodIndent || '\\t';\n\t\t\t\t\tlet possibleTypeText = config.normalizeIndentation(goodIndent);\n\t\t\t\t\tif (!strings.startsWith(lineText, possibleTypeText)) {\n\t\t\t\t\t\tcommands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n\t\t\t} else {\n\t\t\t\tif (selection.startLineNumber === selection.endLineNumber) {\n\t\t\t\t\tlet lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\t\t\t\t\tif (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n\t\t\t\t\t\t// This is a single line selection that is not the entire line\n\t\t\t\t\t\tcommands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcommands[i] = new ShiftCommand(selection, {\n\t\t\t\t\tisUnshift: false,\n\t\t\t\t\ttabSize: config.tabSize,\n\t\t\t\t\tindentSize: config.indentSize,\n\t\t\t\t\tinsertSpaces: config.insertSpaces,\n\t\t\t\t\tuseTabStops: config.useTabStops\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static replacePreviousChar(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], txt: string, replaceCharCnt: number): EditOperationResult {\n\t\tlet commands: Array<ICommand | null> = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\t// looks like https://github.com/Microsoft/vscode/issues/2773\n\t\t\t\t// where a cursor operation occurred before a canceled composition\n\t\t\t\t// => ignore composition\n\t\t\t\tcommands[i] = null;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet pos = selection.getPosition();\n\t\t\tlet startColumn = Math.max(1, pos.column - replaceCharCnt);\n\t\t\tlet range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\n\t\t\tcommands[i] = new ReplaceCommand(range, txt);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\tshouldPushStackElementBefore: (prevEditOperationType !== EditOperationType.Typing),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tprivate static _typeCommand(range: Range, text: string, keepPosition: boolean): ICommand {\n\t\tif (keepPosition) {\n\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, text, true);\n\t\t} else {\n\t\t\treturn new ReplaceCommand(range, text, true);\n\t\t}\n\t}\n\n\tprivate static _enter(config: CursorConfiguration, model: ITextModel, keepPosition: boolean, range: Range): ICommand {\n\t\tif (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {\n\t\t\tlet lineText = model.getLineContent(range.startLineNumber);\n\t\t\tlet indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\t\t\treturn TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t\t}\n\n\t\tlet r = LanguageConfigurationRegistry.getEnterAction(model, range);\n\t\tif (r) {\n\t\t\tlet enterAction = r.enterAction;\n\t\t\tlet indentation = r.indentation;\n\n\t\t\tif (enterAction.indentAction === IndentAction.None) {\n\t\t\t\t// Nothing special\n\t\t\t\treturn TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);\n\n\t\t\t} else if (enterAction.indentAction === IndentAction.Indent) {\n\t\t\t\t// Indent once\n\t\t\t\treturn TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);\n\n\t\t\t} else if (enterAction.indentAction === IndentAction.IndentOutdent) {\n\t\t\t\t// Ultra special\n\t\t\t\tlet normalIndent = config.normalizeIndentation(indentation);\n\t\t\t\tlet increasedIndent = config.normalizeIndentation(indentation + enterAction.appendText);\n\n\t\t\t\tlet typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\n\t\t\t\tif (keepPosition) {\n\t\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n\t\t\t\t} else {\n\t\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n\t\t\t\t}\n\t\t\t} else if (enterAction.indentAction === IndentAction.Outdent) {\n\t\t\t\tlet actualIndentation = TypeOperations.unshiftIndent(config, indentation);\n\t\t\t\treturn TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);\n\t\t\t}\n\t\t}\n\n\t\t// no enter rules applied, we should check indentation rules then.\n\t\tif (!config.autoIndent) {\n\t\t\t// Nothing special\n\t\t\tlet lineText = model.getLineContent(range.startLineNumber);\n\t\t\tlet indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\t\t\treturn TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t\t}\n\n\t\tlet ir = LanguageConfigurationRegistry.getIndentForEnter(model, range, {\n\t\t\tunshiftIndent: (indent) => {\n\t\t\t\treturn TypeOperations.unshiftIndent(config, indent);\n\t\t\t},\n\t\t\tshiftIndent: (indent) => {\n\t\t\t\treturn TypeOperations.shiftIndent(config, indent);\n\t\t\t},\n\t\t\tnormalizeIndentation: (indent) => {\n\t\t\t\treturn config.normalizeIndentation(indent);\n\t\t\t}\n\t\t}, config.autoIndent);\n\n\t\tlet lineText = model.getLineContent(range.startLineNumber);\n\t\tlet indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n\t\tif (ir) {\n\t\t\tlet oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n\t\t\tlet oldEndColumn = range.endColumn;\n\n\t\t\tlet beforeText = '\\n';\n\t\t\tif (indentation !== config.normalizeIndentation(ir.beforeEnter)) {\n\t\t\t\tbeforeText = config.normalizeIndentation(ir.beforeEnter) + lineText.substring(indentation.length, range.startColumn - 1) + '\\n';\n\t\t\t\trange = new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn);\n\t\t\t}\n\n\t\t\tlet newLineContent = model.getLineContent(range.endLineNumber);\n\t\t\tlet firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\t\t\tif (firstNonWhitespace >= 0) {\n\t\t\t\trange = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n\t\t\t} else {\n\t\t\t\trange = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n\t\t\t}\n\n\t\t\tif (keepPosition) {\n\t\t\t\treturn new ReplaceCommandWithoutChangingPosition(range, beforeText + config.normalizeIndentation(ir.afterEnter), true);\n\t\t\t} else {\n\t\t\t\tlet offset = 0;\n\t\t\t\tif (oldEndColumn <= firstNonWhitespace + 1) {\n\t\t\t\t\tif (!config.insertSpaces) {\n\t\t\t\t\t\toldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n\t\t\t\t\t}\n\t\t\t\t\toffset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n\t\t\t\t}\n\t\t\t\treturn new ReplaceCommandWithOffsetCursorState(range, beforeText + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n\t\t}\n\t}\n\n\tprivate static _isAutoIndentType(config: CursorConfiguration, model: ITextModel, selections: Selection[]): boolean {\n\t\tif (!config.autoIndent) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tif (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static _runAutoIndentType(config: CursorConfiguration, model: ITextModel, range: Range, ch: string): ICommand | null {\n\t\tlet currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n\t\tlet actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(model, range, ch, {\n\t\t\tshiftIndent: (indentation) => {\n\t\t\t\treturn TypeOperations.shiftIndent(config, indentation);\n\t\t\t},\n\t\t\tunshiftIndent: (indentation) => {\n\t\t\t\treturn TypeOperations.unshiftIndent(config, indentation);\n\t\t\t},\n\t\t});\n\n\t\tif (actualIndentation === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n\t\t\tlet firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n\t\t\tif (firstNonWhitespace === 0) {\n\t\t\t\treturn TypeOperations._typeCommand(\n\t\t\t\t\tnew Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn),\n\t\t\t\t\tconfig.normalizeIndentation(actualIndentation) + ch,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn TypeOperations._typeCommand(\n\t\t\t\t\tnew Range(range.startLineNumber, 0, range.endLineNumber, range.endColumn),\n\t\t\t\t\tconfig.normalizeIndentation(actualIndentation) +\n\t\t\t\t\tmodel.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate static _isAutoClosingCloseCharType(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): boolean {\n\t\tconst autoCloseConfig = isQuote(ch) ? config.autoClosingQuotes : config.autoClosingBrackets;\n\n\t\tif (autoCloseConfig === 'never' || !config.autoClosingPairsClose.hasOwnProperty(ch)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst isEqualPair = (ch === config.autoClosingPairsClose[ch]);\n\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\tconst afterCharacter = lineText.charAt(position.column - 1);\n\n\t\t\tif (afterCharacter !== ch) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (isEqualPair) {\n\t\t\t\tconst lineTextBeforeCursor = lineText.substr(0, position.column - 1);\n\t\t\t\tconst chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);\n\t\t\t\tif (chCntBefore % 2 === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static _countNeedlesInHaystack(haystack: string, needle: string): number {\n\t\tlet cnt = 0;\n\t\tlet lastIndex = -1;\n\t\twhile ((lastIndex = haystack.indexOf(needle, lastIndex + 1)) !== -1) {\n\t\t\tcnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tprivate static _runAutoClosingCloseCharType(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): EditOperationResult {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n\t\t\tcommands[i] = new ReplaceCommand(typeSelection, ch);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\tshouldPushStackElementBefore: (prevEditOperationType !== EditOperationType.Typing),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tprivate static _isBeforeClosingBrace(config: CursorConfiguration, ch: string, characterAfter: string) {\n\t\tconst thisBraceIsSymmetric = (config.autoClosingPairsOpen[ch] === ch);\n\t\tlet isBeforeCloseBrace = false;\n\t\tfor (let otherCloseBrace in config.autoClosingPairsClose) {\n\t\t\tconst otherBraceIsSymmetric = (config.autoClosingPairsOpen[otherCloseBrace] === otherCloseBrace);\n\t\t\tif (!thisBraceIsSymmetric && otherBraceIsSymmetric) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (characterAfter === otherCloseBrace) {\n\t\t\t\tisBeforeCloseBrace = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn isBeforeCloseBrace;\n\t}\n\n\tprivate static _isAutoClosingOpenCharType(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): boolean {\n\t\tconst chIsQuote = isQuote(ch);\n\t\tconst autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n\n\t\tif (autoCloseConfig === 'never' || !config.autoClosingPairsOpen.hasOwnProperty(ch)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tif (!selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst position = selection.getPosition();\n\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\n\t\t\t// Do not auto-close ' or \" after a word character\n\t\t\tif ((chIsQuote && position.column > 1) && autoCloseConfig !== 'always') {\n\t\t\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\t\t\t\tconst characterBeforeCode = lineText.charCodeAt(position.column - 2);\n\t\t\t\tconst characterBeforeType = wordSeparators.get(characterBeforeCode);\n\t\t\t\tif (characterBeforeType === WordCharacterClass.Regular) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Only consider auto closing the pair if a space follows or if another autoclosed pair follows\n\t\t\tconst characterAfter = lineText.charAt(position.column - 1);\n\t\t\tif (characterAfter) {\n\t\t\t\tlet isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, ch, characterAfter);\n\n\t\t\t\tif (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!model.isCheapToTokenize(position.lineNumber)) {\n\t\t\t\t// Do not force tokenization\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tmodel.forceTokenization(position.lineNumber);\n\t\t\tconst lineTokens = model.getLineTokens(position.lineNumber);\n\n\t\t\tlet shouldAutoClosePair = false;\n\t\t\ttry {\n\t\t\t\tshouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t}\n\n\t\t\tif (!shouldAutoClosePair) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static _runAutoClosingOpenCharType(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): EditOperationResult {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst closeCharacter = config.autoClosingPairsOpen[ch];\n\t\t\tcommands[i] = new ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tprivate static _shouldSurroundChar(config: CursorConfiguration, ch: string): boolean {\n\t\tif (isQuote(ch)) {\n\t\t\treturn (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n\t\t} else {\n\t\t\t// Character is a bracket\n\t\t\treturn (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n\t\t}\n\t}\n\n\tprivate static _isSurroundSelectionType(config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): boolean {\n\t\tif (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst isTypingAQuoteCharacter = isQuote(ch);\n\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\n\t\t\tif (selection.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlet selectionContainsOnlyWhitespace = true;\n\n\t\t\tfor (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n\t\t\t\tconst lineText = model.getLineContent(lineNumber);\n\t\t\t\tconst startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n\t\t\t\tconst endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n\t\t\t\tconst selectedText = lineText.substring(startIndex, endIndex);\n\t\t\t\tif (/[^ \\t]/.test(selectedText)) {\n\t\t\t\t\t// this selected text contains something other than whitespace\n\t\t\t\t\tselectionContainsOnlyWhitespace = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (selectionContainsOnlyWhitespace) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n\t\t\t\tconst selectionText = model.getValueInRange(selection);\n\t\t\t\tif (isQuote(selectionText)) {\n\t\t\t\t\t// Typing a quote character on top of another quote character\n\t\t\t\t\t// => disable surround selection type\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate static _runSurroundSelectionType(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): EditOperationResult {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst selection = selections[i];\n\t\t\tconst closeCharacter = config.surroundingPairs[ch];\n\t\t\tcommands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Other, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: true\n\t\t});\n\t}\n\n\tprivate static _isTypeInterceptorElectricChar(config: CursorConfiguration, model: ITextModel, selections: Selection[]) {\n\t\tif (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate static _typeInterceptorElectricChar(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selection: Selection, ch: string): EditOperationResult | null {\n\t\tif (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet position = selection.getPosition();\n\t\tmodel.forceTokenization(position.lineNumber);\n\t\tlet lineTokens = model.getLineTokens(position.lineNumber);\n\n\t\tlet electricAction: IElectricAction | null;\n\t\ttry {\n\t\t\telectricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!electricAction) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (electricAction.appendText) {\n\t\t\tconst command = new ReplaceCommandWithOffsetCursorState(selection, ch + electricAction.appendText, 0, -electricAction.appendText.length);\n\t\t\treturn new EditOperationResult(EditOperationType.Typing, [command], {\n\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\tshouldPushStackElementAfter: true\n\t\t\t});\n\t\t}\n\n\t\tif (electricAction.matchOpenBracket) {\n\t\t\tlet endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n\t\t\tlet match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n\t\t\t\tlineNumber: position.lineNumber,\n\t\t\t\tcolumn: endColumn\n\t\t\t});\n\n\t\t\tif (match) {\n\t\t\t\tif (match.startLineNumber === position.lineNumber) {\n\t\t\t\t\t// matched something on the same line => no change in indentation\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tlet matchLine = model.getLineContent(match.startLineNumber);\n\t\t\t\tlet matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n\t\t\t\tlet newIndentation = config.normalizeIndentation(matchLineIndentation);\n\n\t\t\t\tlet lineText = model.getLineContent(position.lineNumber);\n\t\t\t\tlet lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n\n\t\t\t\tlet prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n\t\t\t\tlet typeText = newIndentation + prefix + ch;\n\n\t\t\t\tlet typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n\n\t\t\t\tconst command = new ReplaceCommand(typeSelection, typeText);\n\t\t\t\treturn new EditOperationResult(EditOperationType.Typing, [command], {\n\t\t\t\t\tshouldPushStackElementBefore: false,\n\t\t\t\t\tshouldPushStackElementAfter: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic static compositionEndWithInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[]): EditOperationResult | null {\n\t\tif (config.autoClosingQuotes === 'never') {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet commands: ICommand[] = [];\n\n\t\tfor (let i = 0; i < selections.length; i++) {\n\t\t\tif (!selections[i].isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst position = selections[i].getPosition();\n\t\t\tconst lineText = model.getLineContent(position.lineNumber);\n\t\t\tconst ch = lineText.charAt(position.column - 2);\n\n\t\t\tif (config.autoClosingPairsClose.hasOwnProperty(ch)) { // first of all, it's a closing tag\n\t\t\t\tif (ch === config.autoClosingPairsClose[ch] /** isEqualPair */) {\n\t\t\t\t\tconst lineTextBeforeCursor = lineText.substr(0, position.column - 2);\n\t\t\t\t\tconst chCntBefore = this._countNeedlesInHaystack(lineTextBeforeCursor, ch);\n\n\t\t\t\t\tif (chCntBefore % 2 === 1) {\n\t\t\t\t\t\tcontinue; // it pairs with the opening tag.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// As we are not typing in a new character, so we don't need to run `_runAutoClosingCloseCharType`\n\t\t\t// Next step, let's try to check if it's an open char.\n\t\t\tif (config.autoClosingPairsOpen.hasOwnProperty(ch)) {\n\t\t\t\tif (isQuote(ch) && position.column > 2) {\n\t\t\t\t\tconst wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\t\t\t\t\tconst characterBeforeCode = lineText.charCodeAt(position.column - 3);\n\t\t\t\t\tconst characterBeforeType = wordSeparators.get(characterBeforeCode);\n\t\t\t\t\tif (characterBeforeType === WordCharacterClass.Regular) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst characterAfter = lineText.charAt(position.column - 1);\n\n\t\t\t\tif (characterAfter) {\n\t\t\t\t\tlet isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, ch, characterAfter);\n\t\t\t\t\tlet shouldAutoCloseBefore = isQuote(ch) ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n\t\t\t\t\tif (isBeforeCloseBrace) {\n\t\t\t\t\t\t// In normal auto closing logic, we will auto close if the cursor is even before a closing brace intentionally.\n\t\t\t\t\t\t// However for composition mode, we do nothing here as users might clear all the characters for composition and we don't want to do a unnecessary auto close.\n\t\t\t\t\t\t// Related: microsoft/vscode#57250.\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!shouldAutoCloseBefore(characterAfter)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!model.isCheapToTokenize(position.lineNumber)) {\n\t\t\t\t\t// Do not force tokenization\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmodel.forceTokenization(position.lineNumber);\n\t\t\t\tconst lineTokens = model.getLineTokens(position.lineNumber);\n\n\t\t\t\tlet shouldAutoClosePair = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tshouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column - 1);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonUnexpectedError(e);\n\t\t\t\t}\n\n\t\t\t\tif (shouldAutoClosePair) {\n\t\t\t\t\tconst closeCharacter = config.autoClosingPairsOpen[ch];\n\t\t\t\t\tcommands[i] = new ReplaceCommandWithOffsetCursorState(selections[i], closeCharacter, 0, -closeCharacter.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\tshouldPushStackElementBefore: true,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tpublic static typeWithInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], ch: string): EditOperationResult {\n\n\t\tif (ch === '\\n') {\n\t\t\tlet commands: ICommand[] = [];\n\t\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\t\tcommands[i] = TypeOperations._enter(config, model, false, selections[i]);\n\t\t\t}\n\t\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t});\n\t\t}\n\n\t\tif (this._isAutoIndentType(config, model, selections)) {\n\t\t\tlet commands: Array<ICommand | null> = [];\n\t\t\tlet autoIndentFails = false;\n\t\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\t\tcommands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n\t\t\t\tif (!commands[i]) {\n\t\t\t\t\tautoIndentFails = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!autoIndentFails) {\n\t\t\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\t\t\tshouldPushStackElementBefore: true,\n\t\t\t\t\tshouldPushStackElementAfter: false,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (this._isAutoClosingCloseCharType(config, model, selections, ch)) {\n\t\t\treturn this._runAutoClosingCloseCharType(prevEditOperationType, config, model, selections, ch);\n\t\t}\n\n\t\tif (this._isAutoClosingOpenCharType(config, model, selections, ch)) {\n\t\t\treturn this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch);\n\t\t}\n\n\t\tif (this._isSurroundSelectionType(config, model, selections, ch)) {\n\t\t\treturn this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n\t\t}\n\n\t\t// Electric characters make sense only when dealing with a single cursor,\n\t\t// as multiple cursors typing brackets for example would interfer with bracket matching\n\t\tif (this._isTypeInterceptorElectricChar(config, model, selections)) {\n\t\t\tconst r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\t// A simple character type\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], ch);\n\t\t}\n\t\tlet shouldPushStackElementBefore = (prevEditOperationType !== EditOperationType.Typing);\n\t\tif (ch === ' ') {\n\t\t\tshouldPushStackElementBefore = true;\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\tshouldPushStackElementBefore: shouldPushStackElementBefore,\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tpublic static typeWithoutInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], str: string): EditOperationResult {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = new ReplaceCommand(selections[i], str);\n\t\t}\n\t\treturn new EditOperationResult(EditOperationType.Typing, commands, {\n\t\t\tshouldPushStackElementBefore: (prevEditOperationType !== EditOperationType.Typing),\n\t\t\tshouldPushStackElementAfter: false\n\t\t});\n\t}\n\n\tpublic static lineInsertBefore(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tlet lineNumber = selections[i].positionLineNumber;\n\n\t\t\tif (lineNumber === 1) {\n\t\t\t\tcommands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n\t\t\t} else {\n\t\t\t\tlineNumber--;\n\t\t\t\tlet column = model.getLineMaxColumn(lineNumber);\n\n\t\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t\t}\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineInsertAfter(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[] {\n\t\tif (model === null || selections === null) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tconst lineNumber = selections[i].positionLineNumber;\n\t\t\tlet column = model.getLineMaxColumn(lineNumber);\n\t\t\tcommands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n\t\t}\n\t\treturn commands;\n\t}\n\n\tpublic static lineBreakInsert(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[] {\n\t\tlet commands: ICommand[] = [];\n\t\tfor (let i = 0, len = selections.length; i < len; i++) {\n\t\t\tcommands[i] = this._enter(config, model, true, selections[i]);\n\t\t}\n\t\treturn commands;\n\t}\n}\n"]}]}