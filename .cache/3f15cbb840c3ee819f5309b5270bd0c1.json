{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/services/markerDecorationsServiceImpl.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/services/markerDecorationsServiceImpl.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/platform/markers/common/markers\", \"vs/base/common/lifecycle\", \"vs/editor/common/model\", \"vs/editor/common/model/intervalTree\", \"vs/platform/theme/common/themeService\", \"vs/editor/common/view/editorColorRegistry\", \"vs/editor/common/services/modelService\", \"vs/editor/common/core/range\", \"vs/base/common/map\", \"vs/base/common/network\", \"vs/base/common/event\", \"vs/base/common/types\"], function (require, exports, markers_1, lifecycle_1, model_1, intervalTree_1, themeService_1, editorColorRegistry_1, modelService_1, range_1, map_1, network_1, event_1, types_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function MODEL_ID(resource) {\n        return resource.toString();\n    }\n    class MarkerDecorations extends lifecycle_1.Disposable {\n        constructor(model) {\n            super();\n            this.model = model;\n            this._markersData = new Map();\n            this._register(lifecycle_1.toDisposable(() => {\n                this.model.deltaDecorations(map_1.keys(this._markersData), []);\n                this._markersData.clear();\n            }));\n        }\n        update(markers, newDecorations) {\n            const ids = this.model.deltaDecorations(map_1.keys(this._markersData), newDecorations);\n            for (let index = 0; index < ids.length; index++) {\n                this._markersData.set(ids[index], markers[index]);\n            }\n        }\n        getMarker(decoration) {\n            return this._markersData.get(decoration.id);\n        }\n        getMarkers() {\n            const res = [];\n            this._markersData.forEach((marker, id) => {\n                let range = this.model.getDecorationRange(id);\n                if (range) {\n                    res.push([range, marker]);\n                }\n            });\n            return res;\n        }\n    }\n    let MarkerDecorationsService = class MarkerDecorationsService extends lifecycle_1.Disposable {\n        constructor(modelService, _markerService) {\n            super();\n            this._markerService = _markerService;\n            this._onDidChangeMarker = new event_1.Emitter();\n            this.onDidChangeMarker = this._onDidChangeMarker.event;\n            this._markerDecorations = new Map();\n            modelService.getModels().forEach(model => this._onModelAdded(model));\n            this._register(modelService.onModelAdded(this._onModelAdded, this));\n            this._register(modelService.onModelRemoved(this._onModelRemoved, this));\n            this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));\n        }\n        getMarker(model, decoration) {\n            const markerDecorations = this._markerDecorations.get(MODEL_ID(model.uri));\n            return markerDecorations ? types_1.withUndefinedAsNull(markerDecorations.getMarker(decoration)) : null;\n        }\n        getLiveMarkers(model) {\n            const markerDecorations = this._markerDecorations.get(MODEL_ID(model.uri));\n            return markerDecorations ? markerDecorations.getMarkers() : [];\n        }\n        _handleMarkerChange(changedResources) {\n            changedResources.forEach((resource) => {\n                const markerDecorations = this._markerDecorations.get(MODEL_ID(resource));\n                if (markerDecorations) {\n                    this._updateDecorations(markerDecorations);\n                }\n            });\n        }\n        _onModelAdded(model) {\n            const markerDecorations = new MarkerDecorations(model);\n            this._markerDecorations.set(MODEL_ID(model.uri), markerDecorations);\n            this._updateDecorations(markerDecorations);\n        }\n        _onModelRemoved(model) {\n            const markerDecorations = this._markerDecorations.get(MODEL_ID(model.uri));\n            if (markerDecorations) {\n                markerDecorations.dispose();\n                this._markerDecorations.delete(MODEL_ID(model.uri));\n            }\n            // clean up markers for internal, transient models\n            if (model.uri.scheme === network_1.Schemas.inMemory\n                || model.uri.scheme === network_1.Schemas.internal\n                || model.uri.scheme === network_1.Schemas.vscode) {\n                if (this._markerService) {\n                    this._markerService.read({ resource: model.uri }).map(marker => marker.owner).forEach(owner => this._markerService.remove(owner, [model.uri]));\n                }\n            }\n        }\n        _updateDecorations(markerDecorations) {\n            // Limit to the first 500 errors/warnings\n            const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });\n            let newModelDecorations = markers.map((marker) => {\n                return {\n                    range: this._createDecorationRange(markerDecorations.model, marker),\n                    options: this._createDecorationOption(marker)\n                };\n            });\n            markerDecorations.update(markers, newModelDecorations);\n            this._onDidChangeMarker.fire(markerDecorations.model);\n        }\n        _createDecorationRange(model, rawMarker) {\n            let ret = range_1.Range.lift(rawMarker);\n            if (rawMarker.severity === markers_1.MarkerSeverity.Hint) {\n                if (!rawMarker.tags || rawMarker.tags.indexOf(markers_1.MarkerTag.Unnecessary) === -1) {\n                    // * never render hints on multiple lines\n                    // * make enough space for three dots\n                    ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);\n                }\n            }\n            ret = model.validateRange(ret);\n            if (ret.isEmpty()) {\n                let word = model.getWordAtPosition(ret.getStartPosition());\n                if (word) {\n                    ret = new range_1.Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);\n                }\n                else {\n                    let maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) ||\n                        model.getLineMaxColumn(ret.startLineNumber);\n                    if (maxColumn === 1) {\n                        // empty line\n                        // console.warn('marker on empty line:', marker);\n                    }\n                    else if (ret.endColumn >= maxColumn) {\n                        // behind eol\n                        ret = new range_1.Range(ret.startLineNumber, maxColumn - 1, ret.endLineNumber, maxColumn);\n                    }\n                    else {\n                        // extend marker to width = 1\n                        ret = new range_1.Range(ret.startLineNumber, ret.startColumn, ret.endLineNumber, ret.endColumn + 1);\n                    }\n                }\n            }\n            else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {\n                let minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);\n                if (minColumn < ret.endColumn) {\n                    ret = new range_1.Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);\n                    rawMarker.startColumn = minColumn;\n                }\n            }\n            return ret;\n        }\n        _createDecorationOption(marker) {\n            let className;\n            let color = undefined;\n            let zIndex;\n            let inlineClassName = undefined;\n            switch (marker.severity) {\n                case markers_1.MarkerSeverity.Hint:\n                    if (marker.tags && marker.tags.indexOf(markers_1.MarkerTag.Unnecessary) >= 0) {\n                        className = intervalTree_1.ClassName.EditorUnnecessaryDecoration;\n                    }\n                    else {\n                        className = intervalTree_1.ClassName.EditorHintDecoration;\n                    }\n                    zIndex = 0;\n                    break;\n                case markers_1.MarkerSeverity.Warning:\n                    className = intervalTree_1.ClassName.EditorWarningDecoration;\n                    color = themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerWarning);\n                    zIndex = 20;\n                    break;\n                case markers_1.MarkerSeverity.Info:\n                    className = intervalTree_1.ClassName.EditorInfoDecoration;\n                    color = themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerInfo);\n                    zIndex = 10;\n                    break;\n                case markers_1.MarkerSeverity.Error:\n                default:\n                    className = intervalTree_1.ClassName.EditorErrorDecoration;\n                    color = themeService_1.themeColorFromId(editorColorRegistry_1.overviewRulerError);\n                    zIndex = 30;\n                    break;\n            }\n            if (marker.tags) {\n                if (marker.tags.indexOf(markers_1.MarkerTag.Unnecessary) !== -1) {\n                    inlineClassName = intervalTree_1.ClassName.EditorUnnecessaryInlineDecoration;\n                }\n            }\n            return {\n                stickiness: model_1.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n                className,\n                showIfCollapsed: true,\n                overviewRuler: {\n                    color,\n                    position: model_1.OverviewRulerLane.Right\n                },\n                zIndex,\n                inlineClassName,\n            };\n        }\n    };\n    MarkerDecorationsService = __decorate([\n        __param(0, modelService_1.IModelService),\n        __param(1, markers_1.IMarkerService)\n    ], MarkerDecorationsService);\n    exports.MarkerDecorationsService = MarkerDecorationsService;\n});\n",null]}