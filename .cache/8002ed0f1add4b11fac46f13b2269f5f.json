{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/packages/vscode/src/fill/zip.ts","dependencies":[{"path":"/home/coding/workspace/packages/vscode/src/fill/zip.ts","mtime":1555841535694},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vszip\", \"fs\", \"path\", \"tar-stream\", \"util\", \"vs/base/node/pfs\"], function (require, exports, nls, vszip, fs, path, tarStream, util_1, pfs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Override the standard VS Code behavior for zipping\n     * extensions to use the TAR format instead of ZIP.\n     */\n    exports.zip = (tarPath, files) => {\n        return new Promise((c, e) => {\n            const pack = tarStream.pack();\n            const chunks = [];\n            const ended = new Promise((res) => {\n                pack.on(\"end\", () => {\n                    res(Buffer.concat(chunks));\n                });\n            });\n            pack.on(\"data\", (chunk) => {\n                chunks.push(chunk);\n            });\n            for (let i = 0; i < files.length; i++) {\n                const file = files[i];\n                pack.entry({\n                    name: file.path,\n                }, file.contents);\n            }\n            pack.finalize();\n            ended.then((buffer) => {\n                return util_1.promisify(fs.writeFile)(tarPath, buffer);\n            }).then(() => {\n                c(tarPath);\n            }).catch((ex) => {\n                e(ex);\n            });\n        });\n    };\n    /**\n     * Override the standard VS Code behavior for extracting\n     * archives, to first attempt to process the archive as a TAR\n     * and then fallback on the original implementation, for processing\n     * ZIPs.\n     */\n    exports.extract = (archivePath, extractPath, options = {}, token) => {\n        return new Promise((c, e) => {\n            extractTar(archivePath, extractPath, options, token).then(c).catch((ex) => {\n                if (!ex.toString().includes(\"Invalid tar header\")) {\n                    e(ex);\n                    return;\n                }\n                vszip.extract(archivePath, extractPath, options, token).then(c).catch(e);\n            });\n        });\n    };\n    /**\n     * Override the standard VS Code behavior for buffering\n     * archives, to first process the Buffer as a TAR and then\n     * fallback on the original implementation, for processing ZIPs.\n     */\n    exports.buffer = (targetPath, filePath) => {\n        return new Promise((c, e) => {\n            let done = false;\n            exports.extractAssets(targetPath, new RegExp(filePath), (assetPath, data) => {\n                if (path.normalize(assetPath) === path.normalize(filePath)) {\n                    done = true;\n                    c(data);\n                }\n            }).then(() => {\n                if (!done) {\n                    e(\"couldn't find asset \" + filePath);\n                }\n            }).catch((ex) => {\n                if (!ex.toString().includes(\"Invalid tar header\")) {\n                    e(ex);\n                    return;\n                }\n                vszip.buffer(targetPath, filePath).then(c).catch(e);\n            });\n        });\n    };\n    /**\n     * Override the standard VS Code behavior for extracting assets\n     * from archive Buffers to use the TAR format instead of ZIP.\n     */\n    exports.extractAssets = (tarPath, match, callback) => {\n        return new Promise((c, e) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const buffer = yield util_1.promisify(fs.readFile)(tarPath);\n                const extractor = tarStream.extract();\n                extractor.once(\"error\", e);\n                extractor.on(\"entry\", (header, stream, next) => {\n                    const name = header.name;\n                    if (match.test(name)) {\n                        extractData(stream).then((data) => {\n                            callback(name, data);\n                            next();\n                        }).catch(e);\n                        stream.resume();\n                    }\n                    else {\n                        stream.on(\"end\", () => {\n                            next();\n                        });\n                        stream.resume();\n                    }\n                });\n                extractor.on(\"finish\", () => {\n                    c();\n                });\n                extractor.write(buffer);\n                extractor.end();\n            }\n            catch (ex) {\n                e(ex);\n            }\n        }));\n    };\n    const extractData = (stream) => {\n        return new Promise((c, e) => {\n            const fileData = [];\n            stream.on(\"data\", (data) => fileData.push(data));\n            stream.on(\"end\", () => {\n                const fd = Buffer.concat(fileData);\n                c(fd);\n            });\n            stream.on(\"error\", e);\n        });\n    };\n    const extractTar = (tarPath, targetPath, options = {}, token) => {\n        return new Promise((c, e) => __awaiter(this, void 0, void 0, function* () {\n            try {\n                const sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : \"\");\n                const buffer = yield util_1.promisify(fs.readFile)(tarPath);\n                const extractor = tarStream.extract();\n                extractor.once(\"error\", e);\n                extractor.on(\"entry\", (header, stream, next) => {\n                    const rawName = path.normalize(header.name);\n                    const nextEntry = () => {\n                        stream.resume();\n                        next();\n                    };\n                    if (token.isCancellationRequested) {\n                        return nextEntry();\n                    }\n                    if (!sourcePathRegex.test(rawName)) {\n                        return nextEntry();\n                    }\n                    const fileName = rawName.replace(sourcePathRegex, \"\");\n                    const targetFileName = path.join(targetPath, fileName);\n                    if (/\\/$/.test(fileName)) {\n                        stream.resume();\n                        pfs_1.mkdirp(targetFileName).then(() => {\n                            next();\n                        }, e);\n                        return;\n                    }\n                    const dirName = path.dirname(fileName);\n                    const targetDirName = path.join(targetPath, dirName);\n                    if (targetDirName.indexOf(targetPath) !== 0) {\n                        e(nls.localize(\"invalid file\", \"Error extracting {0}. Invalid file.\", fileName));\n                        return nextEntry();\n                    }\n                    return pfs_1.mkdirp(targetDirName, undefined, token).then(() => {\n                        const fstream = fs.createWriteStream(targetFileName, { mode: header.mode });\n                        fstream.once(\"close\", () => {\n                            next();\n                        });\n                        fstream.once(\"error\", e);\n                        stream.pipe(fstream);\n                        stream.resume();\n                    });\n                });\n                extractor.once(\"finish\", c);\n                extractor.write(buffer);\n                extractor.end();\n            }\n            catch (ex) {\n                e(ex);\n            }\n        }));\n    };\n});\n",null]}