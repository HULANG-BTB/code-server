{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/search/common/queryBuilder.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/search/common/queryBuilder.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar arrays = require(\"vs/base/common/arrays\");\nvar collections = require(\"vs/base/common/collections\");\nvar glob = require(\"vs/base/common/glob\");\nvar labels_1 = require(\"vs/base/common/labels\");\nvar map_1 = require(\"vs/base/common/map\");\nvar path = require(\"vs/base/common/path\");\nvar resources_1 = require(\"vs/base/common/resources\");\nvar strings = require(\"vs/base/common/strings\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar textModelSearch_1 = require(\"vs/editor/common/model/textModelSearch\");\nvar nls = require(\"vs/nls\");\nvar configuration_1 = require(\"vs/platform/configuration/common/configuration\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar workspace_1 = require(\"vs/platform/workspace/common/workspace\");\nvar search_1 = require(\"vs/workbench/services/search/common/search\");\nvar network_1 = require(\"vs/base/common/network\");\nvar QueryBuilder = /** @class */ (function () {\n    function QueryBuilder(configurationService, workspaceContextService, environmentService) {\n        this.configurationService = configurationService;\n        this.workspaceContextService = workspaceContextService;\n        this.environmentService = environmentService;\n    }\n    QueryBuilder.prototype.text = function (contentPattern, folderResources, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        contentPattern = this.getContentPattern(contentPattern, options);\n        var searchConfig = this.configurationService.getValue();\n        var fallbackToPCRE = folderResources && folderResources.some(function (folder) {\n            var folderConfig = _this.configurationService.getValue({ resource: folder });\n            return !folderConfig.search.useRipgrep;\n        });\n        var commonQuery = this.commonQuery(folderResources, options);\n        return tslib_1.__assign({}, commonQuery, { type: search_1.QueryType.Text, contentPattern: contentPattern, previewOptions: options.previewOptions, maxFileSize: options.maxFileSize, usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false, beforeContext: options.beforeContext, afterContext: options.afterContext, userDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles });\n    };\n    /**\n     * Adjusts input pattern for config\n     */\n    QueryBuilder.prototype.getContentPattern = function (inputPattern, options) {\n        var searchConfig = this.configurationService.getValue();\n        if (inputPattern.isRegExp) {\n            inputPattern.pattern = inputPattern.pattern.replace(/\\r?\\n/g, '\\\\n');\n        }\n        var newPattern = tslib_1.__assign({}, inputPattern, { wordSeparators: searchConfig.editor.wordSeparators });\n        if (this.isCaseSensitive(inputPattern, options)) {\n            newPattern.isCaseSensitive = true;\n        }\n        if (this.isMultiline(inputPattern)) {\n            newPattern.isMultiline = true;\n        }\n        return newPattern;\n    };\n    QueryBuilder.prototype.file = function (folderResources, options) {\n        if (options === void 0) { options = {}; }\n        var commonQuery = this.commonQuery(folderResources, options);\n        return tslib_1.__assign({}, commonQuery, { type: search_1.QueryType.File, filePattern: options.filePattern\n                ? options.filePattern.trim()\n                : options.filePattern, exists: options.exists, sortByScore: options.sortByScore, cacheKey: options.cacheKey });\n    };\n    QueryBuilder.prototype.commonQuery = function (folderResources, options) {\n        var _this = this;\n        if (folderResources === void 0) { folderResources = []; }\n        if (options === void 0) { options = {}; }\n        var includeSearchPathsInfo = {};\n        if (options.includePattern) {\n            includeSearchPathsInfo = options.expandPatterns ?\n                this.parseSearchPaths(options.includePattern) :\n                { pattern: patternListToIExpression(options.includePattern) };\n        }\n        var excludeSearchPathsInfo = {};\n        if (options.excludePattern) {\n            excludeSearchPathsInfo = options.expandPatterns ?\n                this.parseSearchPaths(options.excludePattern) :\n                { pattern: patternListToIExpression(options.excludePattern) };\n        }\n        // Build folderQueries from searchPaths, if given, otherwise folderResources\n        var folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?\n            includeSearchPathsInfo.searchPaths.map(function (searchPath) { return _this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo); }) :\n            folderResources.map(function (uri) { return _this.getFolderQueryForRoot(uri, options, excludeSearchPathsInfo); }))\n            .filter(function (query) { return !!query; });\n        var queryProps = {\n            _reason: options._reason,\n            folderQueries: folderQueries,\n            usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),\n            extraFileResources: options.extraFileResources,\n            excludePattern: excludeSearchPathsInfo.pattern,\n            includePattern: includeSearchPathsInfo.pattern,\n            maxResults: options.maxResults\n        };\n        // Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace\n        var extraFileResources = options.extraFileResources && options.extraFileResources.filter(function (extraFile) { return search_1.pathIncludedInQuery(queryProps, extraFile.fsPath); });\n        queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;\n        return queryProps;\n    };\n    /**\n     * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.\n     */\n    QueryBuilder.prototype.isCaseSensitive = function (contentPattern, options) {\n        if (options.isSmartCase) {\n            if (contentPattern.isRegExp) {\n                // Consider it case sensitive if it contains an unescaped capital letter\n                if (strings.containsUppercaseCharacter(contentPattern.pattern, true)) {\n                    return true;\n                }\n            }\n            else if (strings.containsUppercaseCharacter(contentPattern.pattern)) {\n                return true;\n            }\n        }\n        return !!contentPattern.isCaseSensitive;\n    };\n    QueryBuilder.prototype.isMultiline = function (contentPattern) {\n        if (contentPattern.isMultiline) {\n            return true;\n        }\n        if (contentPattern.isRegExp && textModelSearch_1.isMultilineRegexSource(contentPattern.pattern)) {\n            return true;\n        }\n        if (contentPattern.pattern.indexOf('\\n') >= 0) {\n            return true;\n        }\n        return !!contentPattern.isMultiline;\n    };\n    /**\n     * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and\n     * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\\/foo/bar}.\n     *\n     * Public for test.\n     */\n    QueryBuilder.prototype.parseSearchPaths = function (pattern) {\n        var _this = this;\n        var isSearchPath = function (segment) {\n            // A segment is a search path if it is an absolute path or starts with ./, ../, .\\, or ..\\\n            return path.isAbsolute(segment) || /^\\.\\.?([\\/\\\\]|$)/.test(segment);\n        };\n        var segments = splitGlobPattern(pattern)\n            .map(function (segment) { return labels_1.untildify(segment, _this.environmentService.userHome); });\n        var groups = collections.groupBy(segments, function (segment) { return isSearchPath(segment) ? 'searchPaths' : 'exprSegments'; });\n        var expandedExprSegments = (groups.exprSegments || [])\n            .map(function (s) { return strings.rtrim(s, '/'); })\n            .map(function (s) { return strings.rtrim(s, '\\\\'); })\n            .map(function (p) {\n            if (p[0] === '.') {\n                p = '*' + p; // convert \".js\" to \"*.js\"\n            }\n            return expandGlobalGlob(p);\n        });\n        var result = {};\n        var searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);\n        if (searchPaths && searchPaths.length) {\n            result.searchPaths = searchPaths;\n        }\n        var exprSegments = arrays.flatten(expandedExprSegments);\n        var includePattern = patternListToIExpression.apply(void 0, exprSegments);\n        if (includePattern) {\n            result.pattern = includePattern;\n        }\n        return result;\n    };\n    QueryBuilder.prototype.getExcludesForFolder = function (folderConfig, options) {\n        return options.disregardExcludeSettings ?\n            undefined :\n            search_1.getExcludes(folderConfig, !options.disregardSearchExcludeSettings);\n    };\n    /**\n     * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths\n     */\n    QueryBuilder.prototype.expandSearchPathPatterns = function (searchPaths) {\n        var _this = this;\n        if (this.workspaceContextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY || !searchPaths || !searchPaths.length) {\n            // No workspace => ignore search paths\n            return [];\n        }\n        var expandedSearchPaths = arrays.flatten(searchPaths.map(function (searchPath) {\n            // 1 open folder => just resolve the search paths to absolute paths\n            var _a = splitGlobFromPath(searchPath), pathPortion = _a.pathPortion, globPortion = _a.globPortion;\n            if (globPortion) {\n                globPortion = normalizeGlobPattern(globPortion);\n            }\n            // One pathPortion to multiple expanded search paths (eg duplicate matching workspace folders)\n            var oneExpanded = _this.expandOneSearchPath(pathPortion);\n            // Expanded search paths to multiple resolved patterns (with ** and without)\n            return arrays.flatten(oneExpanded.map(function (oneExpandedResult) { return _this.resolveOneSearchPathPattern(oneExpandedResult, globPortion); }));\n        }));\n        var searchPathPatternMap = new Map();\n        expandedSearchPaths.forEach(function (oneSearchPathPattern) {\n            var key = oneSearchPathPattern.searchPath.toString();\n            var existing = searchPathPatternMap.get(key);\n            if (existing) {\n                if (oneSearchPathPattern.pattern) {\n                    existing.pattern = existing.pattern || {};\n                    existing.pattern[oneSearchPathPattern.pattern] = true;\n                }\n            }\n            else {\n                searchPathPatternMap.set(key, {\n                    searchPath: oneSearchPathPattern.searchPath,\n                    pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined\n                });\n            }\n        });\n        return map_1.values(searchPathPatternMap);\n    };\n    /**\n     * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.\n     */\n    QueryBuilder.prototype.expandOneSearchPath = function (searchPath) {\n        if (path.isAbsolute(searchPath)) {\n            var workspaceFolders = this.workspaceContextService.getWorkspace().folders;\n            if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== network_1.Schemas.file) {\n                return [{\n                        searchPath: workspaceFolders[0].uri.with({ path: searchPath })\n                    }];\n            }\n            // Currently only local resources can be searched for with absolute search paths.\n            // TODO convert this to a workspace folder + pattern, so excludes will be resolved properly for an absolute path inside a workspace folder\n            return [{\n                    searchPath: uri_1.URI.file(path.normalize(searchPath))\n                }];\n        }\n        if (this.workspaceContextService.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n            var workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;\n            searchPath = normalizeSlashes(searchPath);\n            if (strings.startsWith(searchPath, '../') || searchPath === '..') {\n                var resolvedPath = path.posix.resolve(workspaceUri.path, searchPath);\n                return [{\n                        searchPath: workspaceUri.with({ path: resolvedPath })\n                    }];\n            }\n            var cleanedPattern = normalizeGlobPattern(searchPath);\n            return [{\n                    searchPath: workspaceUri,\n                    pattern: cleanedPattern\n                }];\n        }\n        else if (searchPath === './' || searchPath === '.\\\\') {\n            return []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces\n        }\n        else {\n            var relativeSearchPathMatch_1 = searchPath.match(/\\.[\\/\\\\]([^\\/\\\\]+)(?:[\\/\\\\](.+))?/);\n            if (relativeSearchPathMatch_1) {\n                var searchPathRoot_1 = relativeSearchPathMatch_1[1];\n                var matchingRoots = this.workspaceContextService.getWorkspace().folders.filter(function (folder) { return folder.name === searchPathRoot_1; });\n                if (matchingRoots.length) {\n                    return matchingRoots.map(function (root) {\n                        var patternMatch = relativeSearchPathMatch_1[2];\n                        return {\n                            searchPath: root.uri,\n                            pattern: patternMatch && normalizeGlobPattern(patternMatch)\n                        };\n                    });\n                }\n                else {\n                    // No root folder with name\n                    var searchPathNotFoundError = nls.localize('search.noWorkspaceWithName', \"No folder in workspace with name: {0}\", searchPathRoot_1);\n                    throw new Error(searchPathNotFoundError);\n                }\n            }\n            else {\n                // Malformed ./ search path, ignore\n            }\n        }\n        return [];\n    };\n    QueryBuilder.prototype.resolveOneSearchPathPattern = function (oneExpandedResult, globPortion) {\n        var pattern = oneExpandedResult.pattern && globPortion ?\n            oneExpandedResult.pattern + \"/\" + globPortion :\n            oneExpandedResult.pattern || globPortion;\n        var results = [\n            {\n                searchPath: oneExpandedResult.searchPath,\n                pattern: pattern\n            }\n        ];\n        if (pattern && !strings.endsWith(pattern, '**')) {\n            results.push({\n                searchPath: oneExpandedResult.searchPath,\n                pattern: pattern + '/**'\n            });\n        }\n        return results;\n    };\n    QueryBuilder.prototype.getFolderQueryForSearchPath = function (searchPath, options, searchPathExcludes) {\n        var rootConfig = this.getFolderQueryForRoot(searchPath.searchPath, options, searchPathExcludes);\n        if (!rootConfig) {\n            return null;\n        }\n        return tslib_1.__assign({}, rootConfig, {\n            includePattern: searchPath.pattern\n        });\n    };\n    QueryBuilder.prototype.getFolderQueryForRoot = function (folder, options, searchPathExcludes) {\n        var thisFolderExcludeSearchPathPattern;\n        if (searchPathExcludes.searchPaths) {\n            var thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(function (sp) { return resources_1.isEqual(sp.searchPath, folder); })[0];\n            if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {\n                // entire folder is excluded\n                return null;\n            }\n            else if (thisFolderExcludeSearchPath) {\n                thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;\n            }\n        }\n        var folderConfig = this.configurationService.getValue({ resource: folder });\n        var settingExcludes = this.getExcludesForFolder(folderConfig, options);\n        var excludePattern = tslib_1.__assign({}, (settingExcludes || {}), (thisFolderExcludeSearchPathPattern || {}));\n        return {\n            folder: folder,\n            excludePattern: Object.keys(excludePattern).length > 0 ? excludePattern : undefined,\n            fileEncoding: folderConfig.files && folderConfig.files.encoding,\n            disregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,\n            disregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,\n            ignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search.followSymlinks,\n        };\n    };\n    QueryBuilder = tslib_1.__decorate([\n        tslib_1.__param(0, configuration_1.IConfigurationService),\n        tslib_1.__param(1, workspace_1.IWorkspaceContextService),\n        tslib_1.__param(2, environment_1.IEnvironmentService)\n    ], QueryBuilder);\n    return QueryBuilder;\n}());\nexports.QueryBuilder = QueryBuilder;\nfunction splitGlobFromPath(searchPath) {\n    var globCharMatch = searchPath.match(/[\\*\\{\\}\\(\\)\\[\\]\\?]/);\n    if (globCharMatch) {\n        var globCharIdx = globCharMatch.index;\n        var lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\\\][^/\\\\]*$/);\n        if (lastSlashMatch) {\n            var pathPortion = searchPath.substr(0, lastSlashMatch.index);\n            if (!pathPortion.match(/[/\\\\]/)) {\n                // If the last slash was the only slash, then we now have '' or 'C:' or '.'. Append a slash.\n                pathPortion += '/';\n            }\n            return {\n                pathPortion: pathPortion,\n                globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)\n            };\n        }\n    }\n    // No glob char, or malformed\n    return {\n        pathPortion: searchPath\n    };\n}\nfunction patternListToIExpression() {\n    var patterns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        patterns[_i] = arguments[_i];\n    }\n    return patterns.length ?\n        patterns.reduce(function (glob, cur) { glob[cur] = true; return glob; }, Object.create(null)) :\n        undefined;\n}\nfunction splitGlobPattern(pattern) {\n    return glob.splitGlobAware(pattern, ',')\n        .map(function (s) { return s.trim(); })\n        .filter(function (s) { return !!s.length; });\n}\n/**\n * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/Microsoft/vscode/issues/32761\n */\nfunction expandGlobalGlob(pattern) {\n    var patterns = [\n        \"**/\" + pattern + \"/**\",\n        \"**/\" + pattern\n    ];\n    return patterns.map(function (p) { return p.replace(/\\*\\*\\/\\*\\*/g, '**'); });\n}\nfunction normalizeSlashes(pattern) {\n    return pattern.replace(/\\\\/g, '/');\n}\n/**\n * Normalize slashes, remove `./` and trailing slashes\n */\nfunction normalizeGlobPattern(pattern) {\n    return normalizeSlashes(pattern)\n        .replace(/^\\.\\//, '')\n        .replace(/\\/+$/g, '');\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/search/common/queryBuilder.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/search/common/queryBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport * as collections from 'vs/base/common/collections';\nimport * as glob from 'vs/base/common/glob';\nimport { untildify } from 'vs/base/common/labels';\nimport { values } from 'vs/base/common/map';\nimport * as path from 'vs/base/common/path';\nimport { isEqual } from 'vs/base/common/resources';\nimport * as strings from 'vs/base/common/strings';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { isMultilineRegexSource } from 'vs/editor/common/model/textModelSearch';\nimport * as nls from 'vs/nls';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IWorkspaceContextService, WorkbenchState } from 'vs/platform/workspace/common/workspace';\nimport { getExcludes, ICommonQueryProps, IFileQuery, IFolderQuery, IPatternInfo, ISearchConfiguration, ITextQuery, ITextSearchPreviewOptions, pathIncludedInQuery, QueryType } from 'vs/workbench/services/search/common/search';\nimport { Schemas } from 'vs/base/common/network';\n\n/**\n * One folder to search and a glob expression that should be applied.\n */\nexport interface IOneSearchPathPattern {\n\tsearchPath: uri;\n\tpattern?: string;\n}\n\n/**\n * One folder to search and a set of glob expressions that should be applied.\n */\nexport interface ISearchPathPattern {\n\tsearchPath: uri;\n\tpattern?: glob.IExpression;\n}\n\n/**\n * A set of search paths and a set of glob expressions that should be applied.\n */\nexport interface ISearchPathsInfo {\n\tsearchPaths?: ISearchPathPattern[];\n\tpattern?: glob.IExpression;\n}\n\nexport interface ICommonQueryBuilderOptions {\n\t_reason?: string;\n\texcludePattern?: string;\n\tincludePattern?: string;\n\textraFileResources?: uri[];\n\n\t/** Parse the special ./ syntax supported by the searchview, and expand foo to ** /foo */\n\texpandPatterns?: boolean;\n\n\tmaxResults?: number;\n\tmaxFileSize?: number;\n\tdisregardIgnoreFiles?: boolean;\n\tdisregardGlobalIgnoreFiles?: boolean;\n\tdisregardExcludeSettings?: boolean;\n\tdisregardSearchExcludeSettings?: boolean;\n\tignoreSymlinks?: boolean;\n}\n\nexport interface IFileQueryBuilderOptions extends ICommonQueryBuilderOptions {\n\tfilePattern?: string;\n\texists?: boolean;\n\tsortByScore?: boolean;\n\tcacheKey?: string;\n}\n\nexport interface ITextQueryBuilderOptions extends ICommonQueryBuilderOptions {\n\tpreviewOptions?: ITextSearchPreviewOptions;\n\tfileEncoding?: string;\n\tbeforeContext?: number;\n\tafterContext?: number;\n\tisSmartCase?: boolean;\n}\n\nexport class QueryBuilder {\n\n\tconstructor(\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IWorkspaceContextService private readonly workspaceContextService: IWorkspaceContextService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService\n\t) { }\n\n\ttext(contentPattern: IPatternInfo, folderResources?: uri[], options: ITextQueryBuilderOptions = {}): ITextQuery {\n\t\tcontentPattern = this.getContentPattern(contentPattern, options);\n\t\tconst searchConfig = this.configurationService.getValue<ISearchConfiguration>();\n\n\t\tconst fallbackToPCRE = folderResources && folderResources.some(folder => {\n\t\t\tconst folderConfig = this.configurationService.getValue<ISearchConfiguration>({ resource: folder });\n\t\t\treturn !folderConfig.search.useRipgrep;\n\t\t});\n\n\t\tconst commonQuery = this.commonQuery(folderResources, options);\n\t\treturn <ITextQuery>{\n\t\t\t...commonQuery,\n\t\t\ttype: QueryType.Text,\n\t\t\tcontentPattern,\n\t\t\tpreviewOptions: options.previewOptions,\n\t\t\tmaxFileSize: options.maxFileSize,\n\t\t\tusePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,\n\t\t\tbeforeContext: options.beforeContext,\n\t\t\tafterContext: options.afterContext,\n\t\t\tuserDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles\n\t\t};\n\t}\n\n\t/**\n\t * Adjusts input pattern for config\n\t */\n\tprivate getContentPattern(inputPattern: IPatternInfo, options: ITextQueryBuilderOptions): IPatternInfo {\n\t\tconst searchConfig = this.configurationService.getValue<ISearchConfiguration>();\n\n\t\tif (inputPattern.isRegExp) {\n\t\t\tinputPattern.pattern = inputPattern.pattern.replace(/\\r?\\n/g, '\\\\n');\n\t\t}\n\n\t\tconst newPattern = {\n\t\t\t...inputPattern,\n\t\t\twordSeparators: searchConfig.editor.wordSeparators\n\t\t};\n\n\t\tif (this.isCaseSensitive(inputPattern, options)) {\n\t\t\tnewPattern.isCaseSensitive = true;\n\t\t}\n\n\t\tif (this.isMultiline(inputPattern)) {\n\t\t\tnewPattern.isMultiline = true;\n\t\t}\n\n\t\treturn newPattern;\n\t}\n\n\tfile(folderResources: uri[] | undefined, options: IFileQueryBuilderOptions = {}): IFileQuery {\n\t\tconst commonQuery = this.commonQuery(folderResources, options);\n\t\treturn <IFileQuery>{\n\t\t\t...commonQuery,\n\t\t\ttype: QueryType.File,\n\t\t\tfilePattern: options.filePattern\n\t\t\t\t? options.filePattern.trim()\n\t\t\t\t: options.filePattern,\n\t\t\texists: options.exists,\n\t\t\tsortByScore: options.sortByScore,\n\t\t\tcacheKey: options.cacheKey\n\t\t};\n\t}\n\n\tprivate commonQuery(folderResources: uri[] = [], options: ICommonQueryBuilderOptions = {}): ICommonQueryProps<uri> {\n\t\tlet includeSearchPathsInfo: ISearchPathsInfo = {};\n\t\tif (options.includePattern) {\n\t\t\tincludeSearchPathsInfo = options.expandPatterns ?\n\t\t\t\tthis.parseSearchPaths(options.includePattern) :\n\t\t\t\t{ pattern: patternListToIExpression(options.includePattern) };\n\t\t}\n\n\t\tlet excludeSearchPathsInfo: ISearchPathsInfo = {};\n\t\tif (options.excludePattern) {\n\t\t\texcludeSearchPathsInfo = options.expandPatterns ?\n\t\t\t\tthis.parseSearchPaths(options.excludePattern) :\n\t\t\t\t{ pattern: patternListToIExpression(options.excludePattern) };\n\t\t}\n\n\t\t// Build folderQueries from searchPaths, if given, otherwise folderResources\n\t\tconst folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?\n\t\t\tincludeSearchPathsInfo.searchPaths.map(searchPath => this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo)) :\n\t\t\tfolderResources.map(uri => this.getFolderQueryForRoot(uri, options, excludeSearchPathsInfo)))\n\t\t\t.filter(query => !!query) as IFolderQuery[];\n\n\t\tconst queryProps: ICommonQueryProps<uri> = {\n\t\t\t_reason: options._reason,\n\t\t\tfolderQueries,\n\t\t\tusingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),\n\t\t\textraFileResources: options.extraFileResources,\n\n\t\t\texcludePattern: excludeSearchPathsInfo.pattern,\n\t\t\tincludePattern: includeSearchPathsInfo.pattern,\n\t\t\tmaxResults: options.maxResults\n\t\t};\n\n\t\t// Filter extraFileResources against global include/exclude patterns - they are already expected to not belong to a workspace\n\t\tconst extraFileResources = options.extraFileResources && options.extraFileResources.filter(extraFile => pathIncludedInQuery(queryProps, extraFile.fsPath));\n\t\tqueryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;\n\n\t\treturn queryProps;\n\t}\n\n\t/**\n\t * Resolve isCaseSensitive flag based on the query and the isSmartCase flag, for search providers that don't support smart case natively.\n\t */\n\tprivate isCaseSensitive(contentPattern: IPatternInfo, options: ITextQueryBuilderOptions): boolean {\n\t\tif (options.isSmartCase) {\n\t\t\tif (contentPattern.isRegExp) {\n\t\t\t\t// Consider it case sensitive if it contains an unescaped capital letter\n\t\t\t\tif (strings.containsUppercaseCharacter(contentPattern.pattern, true)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if (strings.containsUppercaseCharacter(contentPattern.pattern)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn !!contentPattern.isCaseSensitive;\n\t}\n\n\tprivate isMultiline(contentPattern: IPatternInfo): boolean {\n\t\tif (contentPattern.isMultiline) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (contentPattern.isRegExp && isMultilineRegexSource(contentPattern.pattern)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (contentPattern.pattern.indexOf('\\n') >= 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn !!contentPattern.isMultiline;\n\t}\n\n\t/**\n\t * Take the includePattern as seen in the search viewlet, and split into components that look like searchPaths, and\n\t * glob patterns. Glob patterns are expanded from 'foo/bar' to '{foo/bar/**, **\\/foo/bar}.\n\t *\n\t * Public for test.\n\t */\n\tparseSearchPaths(pattern: string): ISearchPathsInfo {\n\t\tconst isSearchPath = (segment: string) => {\n\t\t\t// A segment is a search path if it is an absolute path or starts with ./, ../, .\\, or ..\\\n\t\t\treturn path.isAbsolute(segment) || /^\\.\\.?([\\/\\\\]|$)/.test(segment);\n\t\t};\n\n\t\tconst segments = splitGlobPattern(pattern)\n\t\t\t.map(segment => untildify(segment, this.environmentService.userHome));\n\t\tconst groups = collections.groupBy(segments,\n\t\t\tsegment => isSearchPath(segment) ? 'searchPaths' : 'exprSegments');\n\n\t\tconst expandedExprSegments = (groups.exprSegments || [])\n\t\t\t.map(s => strings.rtrim(s, '/'))\n\t\t\t.map(s => strings.rtrim(s, '\\\\'))\n\t\t\t.map(p => {\n\t\t\t\tif (p[0] === '.') {\n\t\t\t\t\tp = '*' + p; // convert \".js\" to \"*.js\"\n\t\t\t\t}\n\n\t\t\t\treturn expandGlobalGlob(p);\n\t\t\t});\n\n\t\tconst result: ISearchPathsInfo = {};\n\t\tconst searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);\n\t\tif (searchPaths && searchPaths.length) {\n\t\t\tresult.searchPaths = searchPaths;\n\t\t}\n\n\t\tconst exprSegments = arrays.flatten(expandedExprSegments);\n\t\tconst includePattern = patternListToIExpression(...exprSegments);\n\t\tif (includePattern) {\n\t\t\tresult.pattern = includePattern;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate getExcludesForFolder(folderConfig: ISearchConfiguration, options: ICommonQueryBuilderOptions): glob.IExpression | undefined {\n\t\treturn options.disregardExcludeSettings ?\n\t\t\tundefined :\n\t\t\tgetExcludes(folderConfig, !options.disregardSearchExcludeSettings);\n\t}\n\n\t/**\n\t * Split search paths (./ or ../ or absolute paths in the includePatterns) into absolute paths and globs applied to those paths\n\t */\n\tprivate expandSearchPathPatterns(searchPaths: string[]): ISearchPathPattern[] {\n\t\tif (this.workspaceContextService.getWorkbenchState() === WorkbenchState.EMPTY || !searchPaths || !searchPaths.length) {\n\t\t\t// No workspace => ignore search paths\n\t\t\treturn [];\n\t\t}\n\n\t\tconst expandedSearchPaths = arrays.flatten(\n\t\t\tsearchPaths.map(searchPath => {\n\t\t\t\t// 1 open folder => just resolve the search paths to absolute paths\n\t\t\t\tlet { pathPortion, globPortion } = splitGlobFromPath(searchPath);\n\n\t\t\t\tif (globPortion) {\n\t\t\t\t\tglobPortion = normalizeGlobPattern(globPortion);\n\t\t\t\t}\n\n\t\t\t\t// One pathPortion to multiple expanded search paths (eg duplicate matching workspace folders)\n\t\t\t\tconst oneExpanded = this.expandOneSearchPath(pathPortion);\n\n\t\t\t\t// Expanded search paths to multiple resolved patterns (with ** and without)\n\t\t\t\treturn arrays.flatten(\n\t\t\t\t\toneExpanded.map(oneExpandedResult => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion)));\n\t\t\t}));\n\n\t\tconst searchPathPatternMap = new Map<string, ISearchPathPattern>();\n\t\texpandedSearchPaths.forEach(oneSearchPathPattern => {\n\t\t\tconst key = oneSearchPathPattern.searchPath.toString();\n\t\t\tconst existing = searchPathPatternMap.get(key);\n\t\t\tif (existing) {\n\t\t\t\tif (oneSearchPathPattern.pattern) {\n\t\t\t\t\texisting.pattern = existing.pattern || {};\n\t\t\t\t\texisting.pattern[oneSearchPathPattern.pattern] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsearchPathPatternMap.set(key, {\n\t\t\t\t\tsearchPath: oneSearchPathPattern.searchPath,\n\t\t\t\t\tpattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn values(searchPathPatternMap);\n\t}\n\n\t/**\n\t * Takes a searchPath like `./a/foo` or `../a/foo` and expands it to absolute paths for all the workspaces it matches.\n\t */\n\tprivate expandOneSearchPath(searchPath: string): IOneSearchPathPattern[] {\n\t\tif (path.isAbsolute(searchPath)) {\n\t\t\tconst workspaceFolders = this.workspaceContextService.getWorkspace().folders;\n\t\t\tif (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== Schemas.file) {\n\t\t\t\treturn [{\n\t\t\t\t\tsearchPath: workspaceFolders[0].uri.with({ path: searchPath })\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\t// Currently only local resources can be searched for with absolute search paths.\n\t\t\t// TODO convert this to a workspace folder + pattern, so excludes will be resolved properly for an absolute path inside a workspace folder\n\t\t\treturn [{\n\t\t\t\tsearchPath: uri.file(path.normalize(searchPath))\n\t\t\t}];\n\t\t}\n\n\t\tif (this.workspaceContextService.getWorkbenchState() === WorkbenchState.FOLDER) {\n\t\t\tconst workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;\n\n\t\t\tsearchPath = normalizeSlashes(searchPath);\n\t\t\tif (strings.startsWith(searchPath, '../') || searchPath === '..') {\n\t\t\t\tconst resolvedPath = path.posix.resolve(workspaceUri.path, searchPath);\n\t\t\t\treturn [{\n\t\t\t\t\tsearchPath: workspaceUri.with({ path: resolvedPath })\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tconst cleanedPattern = normalizeGlobPattern(searchPath);\n\t\t\treturn [{\n\t\t\t\tsearchPath: workspaceUri,\n\t\t\t\tpattern: cleanedPattern\n\t\t\t}];\n\t\t} else if (searchPath === './' || searchPath === '.\\\\') {\n\t\t\treturn []; // ./ or ./**/foo makes sense for single-folder but not multi-folder workspaces\n\t\t} else {\n\t\t\tconst relativeSearchPathMatch = searchPath.match(/\\.[\\/\\\\]([^\\/\\\\]+)(?:[\\/\\\\](.+))?/);\n\t\t\tif (relativeSearchPathMatch) {\n\t\t\t\tconst searchPathRoot = relativeSearchPathMatch[1];\n\t\t\t\tconst matchingRoots = this.workspaceContextService.getWorkspace().folders.filter(folder => folder.name === searchPathRoot);\n\t\t\t\tif (matchingRoots.length) {\n\t\t\t\t\treturn matchingRoots.map(root => {\n\t\t\t\t\t\tconst patternMatch = relativeSearchPathMatch[2];\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tsearchPath: root.uri,\n\t\t\t\t\t\t\tpattern: patternMatch && normalizeGlobPattern(patternMatch)\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// No root folder with name\n\t\t\t\t\tconst searchPathNotFoundError = nls.localize('search.noWorkspaceWithName', \"No folder in workspace with name: {0}\", searchPathRoot);\n\t\t\t\t\tthrow new Error(searchPathNotFoundError);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Malformed ./ search path, ignore\n\t\t\t}\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tprivate resolveOneSearchPathPattern(oneExpandedResult: IOneSearchPathPattern, globPortion?: string): IOneSearchPathPattern[] {\n\t\tconst pattern = oneExpandedResult.pattern && globPortion ?\n\t\t\t`${oneExpandedResult.pattern}/${globPortion}` :\n\t\t\toneExpandedResult.pattern || globPortion;\n\n\t\tconst results = [\n\t\t\t{\n\t\t\t\tsearchPath: oneExpandedResult.searchPath,\n\t\t\t\tpattern\n\t\t\t}];\n\n\t\tif (pattern && !strings.endsWith(pattern, '**')) {\n\t\t\tresults.push({\n\t\t\t\tsearchPath: oneExpandedResult.searchPath,\n\t\t\t\tpattern: pattern + '/**'\n\t\t\t});\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tprivate getFolderQueryForSearchPath(searchPath: ISearchPathPattern, options: ICommonQueryBuilderOptions, searchPathExcludes: ISearchPathsInfo): IFolderQuery | null {\n\t\tconst rootConfig = this.getFolderQueryForRoot(searchPath.searchPath, options, searchPathExcludes);\n\t\tif (!rootConfig) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\t...rootConfig,\n\t\t\t...{\n\t\t\t\tincludePattern: searchPath.pattern\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate getFolderQueryForRoot(folder: uri, options: ICommonQueryBuilderOptions, searchPathExcludes: ISearchPathsInfo): IFolderQuery | null {\n\t\tlet thisFolderExcludeSearchPathPattern: glob.IExpression | undefined;\n\t\tif (searchPathExcludes.searchPaths) {\n\t\t\tconst thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(sp => isEqual(sp.searchPath, folder))[0];\n\t\t\tif (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {\n\t\t\t\t// entire folder is excluded\n\t\t\t\treturn null;\n\t\t\t} else if (thisFolderExcludeSearchPath) {\n\t\t\t\tthisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;\n\t\t\t}\n\t\t}\n\n\t\tconst folderConfig = this.configurationService.getValue<ISearchConfiguration>({ resource: folder });\n\t\tconst settingExcludes = this.getExcludesForFolder(folderConfig, options);\n\t\tconst excludePattern: glob.IExpression = {\n\t\t\t...(settingExcludes || {}),\n\t\t\t...(thisFolderExcludeSearchPathPattern || {})\n\t\t};\n\n\t\treturn <IFolderQuery>{\n\t\t\tfolder,\n\t\t\texcludePattern: Object.keys(excludePattern).length > 0 ? excludePattern : undefined,\n\t\t\tfileEncoding: folderConfig.files && folderConfig.files.encoding,\n\t\t\tdisregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,\n\t\t\tdisregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,\n\t\t\tignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search.followSymlinks,\n\t\t};\n\t}\n}\n\nfunction splitGlobFromPath(searchPath: string): { pathPortion: string, globPortion?: string } {\n\tconst globCharMatch = searchPath.match(/[\\*\\{\\}\\(\\)\\[\\]\\?]/);\n\tif (globCharMatch) {\n\t\tconst globCharIdx = globCharMatch.index;\n\t\tconst lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\\\][^/\\\\]*$/);\n\t\tif (lastSlashMatch) {\n\t\t\tlet pathPortion = searchPath.substr(0, lastSlashMatch.index);\n\t\t\tif (!pathPortion.match(/[/\\\\]/)) {\n\t\t\t\t// If the last slash was the only slash, then we now have '' or 'C:' or '.'. Append a slash.\n\t\t\t\tpathPortion += '/';\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpathPortion,\n\t\t\t\tglobPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)\n\t\t\t};\n\t\t}\n\t}\n\n\t// No glob char, or malformed\n\treturn {\n\t\tpathPortion: searchPath\n\t};\n}\n\nfunction patternListToIExpression(...patterns: string[]): glob.IExpression {\n\treturn patterns.length ?\n\t\tpatterns.reduce((glob, cur) => { glob[cur] = true; return glob; }, Object.create(null)) :\n\t\tundefined;\n}\n\nfunction splitGlobPattern(pattern: string): string[] {\n\treturn glob.splitGlobAware(pattern, ',')\n\t\t.map(s => s.trim())\n\t\t.filter(s => !!s.length);\n}\n\n/**\n * Note - we used {} here previously but ripgrep can't handle nested {} patterns. See https://github.com/Microsoft/vscode/issues/32761\n */\nfunction expandGlobalGlob(pattern: string): string[] {\n\tconst patterns = [\n\t\t`**/${pattern}/**`,\n\t\t`**/${pattern}`\n\t];\n\n\treturn patterns.map(p => p.replace(/\\*\\*\\/\\*\\*/g, '**'));\n}\n\nfunction normalizeSlashes(pattern: string): string {\n\treturn pattern.replace(/\\\\/g, '/');\n}\n\n/**\n * Normalize slashes, remove `./` and trailing slashes\n */\nfunction normalizeGlobPattern(pattern: string): string {\n\treturn normalizeSlashes(pattern)\n\t\t.replace(/^\\.\\//, '')\n\t\t.replace(/\\/+$/g, '');\n}\n"]}]}