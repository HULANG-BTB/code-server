{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/common/contributions.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/common/contributions.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/registry/common/platform\", \"vs/base/common/async\"], function (require, exports, instantiation_1, lifecycle_1, platform_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Extensions;\n    (function (Extensions) {\n        Extensions.Workbench = 'workbench.contributions.kind';\n    })(Extensions = exports.Extensions || (exports.Extensions = {}));\n    class WorkbenchContributionsRegistry {\n        constructor() {\n            this.toBeInstantiated = new Map();\n        }\n        registerWorkbenchContribution(ctor, phase = lifecycle_1.LifecyclePhase.Starting) {\n            // Instantiate directly if we are already matching the provided phase\n            if (this.instantiationService && this.lifecycleService && this.lifecycleService.phase >= phase) {\n                this.instantiationService.createInstance(ctor);\n            }\n            // Otherwise keep contributions by lifecycle phase\n            else {\n                let toBeInstantiated = this.toBeInstantiated.get(phase);\n                if (!toBeInstantiated) {\n                    toBeInstantiated = [];\n                    this.toBeInstantiated.set(phase, toBeInstantiated);\n                }\n                toBeInstantiated.push(ctor);\n            }\n        }\n        start(accessor) {\n            this.instantiationService = accessor.get(instantiation_1.IInstantiationService);\n            this.lifecycleService = accessor.get(lifecycle_1.ILifecycleService);\n            [lifecycle_1.LifecyclePhase.Starting, lifecycle_1.LifecyclePhase.Ready, lifecycle_1.LifecyclePhase.Restored, lifecycle_1.LifecyclePhase.Eventually].forEach(phase => {\n                this.instantiateByPhase(this.instantiationService, this.lifecycleService, phase);\n            });\n        }\n        instantiateByPhase(instantiationService, lifecycleService, phase) {\n            // Instantiate contributions directly when phase is already reached\n            if (lifecycleService.phase >= phase) {\n                this.doInstantiateByPhase(instantiationService, phase);\n            }\n            // Otherwise wait for phase to be reached\n            else {\n                lifecycleService.when(phase).then(() => {\n                    this.doInstantiateByPhase(instantiationService, phase);\n                });\n            }\n        }\n        doInstantiateByPhase(instantiationService, phase) {\n            const toBeInstantiated = this.toBeInstantiated.get(phase);\n            if (toBeInstantiated) {\n                this.toBeInstantiated.delete(phase);\n                if (phase !== lifecycle_1.LifecyclePhase.Eventually) {\n                    // instantiate everything synchronously and blocking\n                    for (const ctor of toBeInstantiated) {\n                        instantiationService.createInstance(ctor);\n                    }\n                }\n                else {\n                    // for the Eventually-phase we instantiate contributions\n                    // only when idle. this might take a few idle-busy-cycles\n                    // but will finish within the timeouts\n                    let forcedTimeout = 3000;\n                    let i = 0;\n                    let instantiateSome = (idle) => {\n                        while (i < toBeInstantiated.length) {\n                            const ctor = toBeInstantiated[i++];\n                            instantiationService.createInstance(ctor);\n                            if (idle.timeRemaining() < 1) {\n                                // time is up -> reschedule\n                                async_1.runWhenIdle(instantiateSome, forcedTimeout);\n                                break;\n                            }\n                        }\n                    };\n                    async_1.runWhenIdle(instantiateSome, forcedTimeout);\n                }\n            }\n        }\n    }\n    platform_1.Registry.add(Extensions.Workbench, new WorkbenchContributionsRegistry());\n});\n",null]}