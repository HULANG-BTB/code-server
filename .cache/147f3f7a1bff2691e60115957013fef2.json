{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/node/configuration.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configuration/node/configuration.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"crypto\", \"vs/base/common/resources\", \"vs/base/common/event\", \"vs/base/node/pfs\", \"vs/base/common/errors\", \"vs/base/common/collections\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/platform/files/common/files\", \"vs/platform/configuration/common/configurationModels\", \"vs/workbench/services/configuration/common/configurationModels\", \"vs/workbench/services/configuration/common/configuration\", \"vs/base/node/extfs\", \"vs/platform/workspace/common/workspace\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/base/common/path\", \"vs/base/common/objects\", \"vs/base/common/network\", \"vs/platform/configuration/common/configuration\", \"vs/platform/configuration/node/configuration\"], function (require, exports, uri_1, crypto_1, resources, event_1, pfs, errors, collections, lifecycle_1, async_1, files_1, configurationModels_1, configurationModels_2, configuration_1, extfs, workspace_1, configurationRegistry_1, path_1, objects_1, network_1, configuration_2, configuration_3) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class LocalUserConfiguration extends lifecycle_1.Disposable {\n        constructor(environmentService) {\n            super();\n            this._onDidChangeConfiguration = this._register(new event_1.Emitter());\n            this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n            this.userConfiguration = this._register(new configuration_3.NodeBasedUserConfiguration(environmentService.appSettingsPath));\n            this._register(this.userConfiguration.onDidChangeConfiguration(configurationModel => this._onDidChangeConfiguration.fire(configurationModel)));\n        }\n        initialize() {\n            return this.userConfiguration.initialize();\n        }\n        reload() {\n            return this.userConfiguration.reload();\n        }\n        adopt(fileService) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return null;\n            });\n        }\n    }\n    exports.LocalUserConfiguration = LocalUserConfiguration;\n    class RemoteUserConfiguration extends lifecycle_1.Disposable {\n        constructor(remoteAuthority, environmentService) {\n            super();\n            this._onDidChangeConfiguration = this._register(new event_1.Emitter());\n            this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;\n            this._userConfiguration = this._cachedConfiguration = new CachedUserConfiguration(remoteAuthority, environmentService);\n        }\n        initialize() {\n            return this._userConfiguration.initialize();\n        }\n        reload() {\n            return this._userConfiguration.reload();\n        }\n        adopt(configurationResource, fileService) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (this._userConfiguration instanceof CachedUserConfiguration) {\n                    const oldConfigurationModel = this._userConfiguration.getConfigurationModel();\n                    let newConfigurationModel = new configurationModels_1.ConfigurationModel();\n                    if (configurationResource) {\n                        this._userConfiguration = new configuration_3.FileServiceBasedUserConfiguration(configurationResource, fileService);\n                        this._register(this._userConfiguration.onDidChangeConfiguration(configurationModel => this.onDidUserConfigurationChange(configurationModel)));\n                        newConfigurationModel = yield this._userConfiguration.initialize();\n                    }\n                    const { added, updated, removed } = configuration_2.compare(oldConfigurationModel, newConfigurationModel);\n                    if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n                        this.updateCache(newConfigurationModel);\n                        return newConfigurationModel;\n                    }\n                }\n                return null;\n            });\n        }\n        onDidUserConfigurationChange(configurationModel) {\n            this.updateCache(configurationModel);\n            this._onDidChangeConfiguration.fire(configurationModel);\n        }\n        updateCache(configurationModel) {\n            return this._cachedConfiguration.updateConfiguration(configurationModel);\n        }\n    }\n    exports.RemoteUserConfiguration = RemoteUserConfiguration;\n    class CachedUserConfiguration extends lifecycle_1.Disposable {\n        constructor(remoteAuthority, environmentService) {\n            super();\n            this.environmentService = environmentService;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this.cachedFolderPath = path_1.join(this.environmentService.userDataPath, 'CachedConfigurations', 'user', remoteAuthority);\n            this.cachedConfigurationPath = path_1.join(this.cachedFolderPath, 'configuration.json');\n            this.configurationModel = new configurationModels_1.ConfigurationModel();\n        }\n        getConfigurationModel() {\n            return this.configurationModel;\n        }\n        initialize() {\n            return this.reload();\n        }\n        reload() {\n            return pfs.readFile(this.cachedConfigurationPath)\n                .then(content => content.toString(), () => '')\n                .then(content => {\n                try {\n                    const parsed = JSON.parse(content);\n                    this.configurationModel = new configurationModels_1.ConfigurationModel(parsed.contents, parsed.keys, parsed.overrides);\n                }\n                catch (e) {\n                }\n                return this.configurationModel;\n            });\n        }\n        updateConfiguration(configurationModel) {\n            const raw = JSON.stringify(configurationModel.toJSON());\n            return this.createCachedFolder().then(created => {\n                if (created) {\n                    return configurationModel.keys.length ? pfs.writeFile(this.cachedConfigurationPath, raw) : pfs.rimraf(this.cachedFolderPath);\n                }\n                return undefined;\n            });\n        }\n        createCachedFolder() {\n            return Promise.resolve(pfs.exists(this.cachedFolderPath))\n                .then(undefined, () => false)\n                .then(exists => exists ? exists : pfs.mkdirp(this.cachedFolderPath).then(() => true, () => false));\n        }\n    }\n    class WorkspaceConfiguration extends lifecycle_1.Disposable {\n        constructor(environmentService) {\n            super();\n            this._workspaceIdentifier = null;\n            this._fileService = null;\n            this._onDidUpdateConfiguration = this._register(new event_1.Emitter());\n            this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;\n            this._cachedConfiguration = new CachedWorkspaceConfiguration(environmentService);\n            this._workspaceConfiguration = this._cachedConfiguration;\n        }\n        adopt(fileService) {\n            if (!this._fileService) {\n                this._fileService = fileService;\n                if (this.adoptWorkspaceConfiguration()) {\n                    if (this._workspaceIdentifier) {\n                        return this._workspaceConfiguration.load(this._workspaceIdentifier).then(() => true);\n                    }\n                }\n            }\n            return Promise.resolve(false);\n        }\n        load(workspaceIdentifier) {\n            this._workspaceIdentifier = workspaceIdentifier;\n            this.adoptWorkspaceConfiguration();\n            return this._workspaceConfiguration.load(this._workspaceIdentifier);\n        }\n        reload() {\n            return this._workspaceIdentifier ? this.load(this._workspaceIdentifier) : Promise.resolve();\n        }\n        getFolders() {\n            return this._workspaceConfiguration.getFolders();\n        }\n        setFolders(folders, jsonEditingService) {\n            if (this._workspaceIdentifier) {\n                return jsonEditingService.write(this._workspaceIdentifier.configPath, { key: 'folders', value: folders }, true)\n                    .then(() => this.reload());\n            }\n            return Promise.resolve();\n        }\n        getConfiguration() {\n            return this._workspaceConfiguration.getWorkspaceSettings();\n        }\n        reprocessWorkspaceSettings() {\n            this._workspaceConfiguration.reprocessWorkspaceSettings();\n            return this.getConfiguration();\n        }\n        adoptWorkspaceConfiguration() {\n            if (this._workspaceIdentifier) {\n                if (this._fileService) {\n                    if (!(this._workspaceConfiguration instanceof FileServiceBasedWorkspaceConfiguration)) {\n                        const oldWorkspaceConfiguration = this._workspaceConfiguration;\n                        this._workspaceConfiguration = new FileServiceBasedWorkspaceConfiguration(this._fileService, oldWorkspaceConfiguration);\n                        this._register(this._workspaceConfiguration.onDidChange(e => this.onDidWorkspaceConfigurationChange()));\n                        if (oldWorkspaceConfiguration instanceof CachedWorkspaceConfiguration) {\n                            this.updateCache();\n                            return true;\n                        }\n                        else {\n                            lifecycle_1.dispose(oldWorkspaceConfiguration);\n                            return false;\n                        }\n                    }\n                    return false;\n                }\n                if (this._workspaceIdentifier.configPath.scheme === network_1.Schemas.file) {\n                    if (!(this._workspaceConfiguration instanceof NodeBasedWorkspaceConfiguration)) {\n                        lifecycle_1.dispose(this._workspaceConfiguration);\n                        this._workspaceConfiguration = new NodeBasedWorkspaceConfiguration();\n                        return true;\n                    }\n                    return false;\n                }\n            }\n            return false;\n        }\n        onDidWorkspaceConfigurationChange() {\n            this.updateCache();\n            this.reload().then(() => this._onDidUpdateConfiguration.fire());\n        }\n        updateCache() {\n            if (this._workspaceIdentifier && this._workspaceIdentifier.configPath.scheme !== network_1.Schemas.file && this._workspaceConfiguration instanceof FileServiceBasedWorkspaceConfiguration) {\n                return this._workspaceConfiguration.load(this._workspaceIdentifier)\n                    .then(() => this._cachedConfiguration.updateWorkspace(this._workspaceIdentifier, this._workspaceConfiguration.getConfigurationModel()));\n            }\n            return Promise.resolve(undefined);\n        }\n    }\n    exports.WorkspaceConfiguration = WorkspaceConfiguration;\n    class AbstractWorkspaceConfiguration extends lifecycle_1.Disposable {\n        constructor(from) {\n            super();\n            this._workspaceIdentifier = null;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this.workspaceConfigurationModelParser = from ? from.workspaceConfigurationModelParser : new configurationModels_2.WorkspaceConfigurationModelParser('');\n            this.workspaceSettings = from ? from.workspaceSettings : new configurationModels_1.ConfigurationModel();\n        }\n        get workspaceIdentifier() {\n            return this._workspaceIdentifier;\n        }\n        load(workspaceIdentifier) {\n            this._workspaceIdentifier = workspaceIdentifier;\n            return this.loadWorkspaceConfigurationContents(workspaceIdentifier)\n                .then(contents => {\n                this.workspaceConfigurationModelParser = new configurationModels_2.WorkspaceConfigurationModelParser(workspaceIdentifier.id);\n                this.workspaceConfigurationModelParser.parse(contents);\n                this.consolidate();\n            });\n        }\n        getConfigurationModel() {\n            return this.workspaceConfigurationModelParser.configurationModel;\n        }\n        getFolders() {\n            return this.workspaceConfigurationModelParser.folders;\n        }\n        getWorkspaceSettings() {\n            return this.workspaceSettings;\n        }\n        reprocessWorkspaceSettings() {\n            this.workspaceConfigurationModelParser.reprocessWorkspaceSettings();\n            this.consolidate();\n            return this.getWorkspaceSettings();\n        }\n        consolidate() {\n            this.workspaceSettings = this.workspaceConfigurationModelParser.settingsModel.merge(this.workspaceConfigurationModelParser.launchModel);\n        }\n    }\n    class NodeBasedWorkspaceConfiguration extends AbstractWorkspaceConfiguration {\n        loadWorkspaceConfigurationContents(workspaceIdentifier) {\n            return pfs.readFile(workspaceIdentifier.configPath.fsPath)\n                .then(contents => contents.toString(), e => {\n                errors.onUnexpectedError(e);\n                return '';\n            });\n        }\n    }\n    class FileServiceBasedWorkspaceConfiguration extends AbstractWorkspaceConfiguration {\n        constructor(fileService, from) {\n            super(from);\n            this.fileService = fileService;\n            this.workspaceConfig = null;\n            this.workspaceConfig = from && from.workspaceIdentifier ? from.workspaceIdentifier.configPath : null;\n            this._register(fileService.onFileChanges(e => this.handleWorkspaceFileEvents(e)));\n            this.reloadConfigurationScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidChange.fire(), 50));\n            this.watchWorkspaceConfigurationFile();\n            this._register(lifecycle_1.toDisposable(() => this.unWatchWorkspaceConfigurtionFile()));\n        }\n        watchWorkspaceConfigurationFile() {\n            if (this.workspaceConfig) {\n                this.fileService.watchFileChanges(this.workspaceConfig);\n            }\n        }\n        unWatchWorkspaceConfigurtionFile() {\n            if (this.workspaceConfig) {\n                this.fileService.unwatchFileChanges(this.workspaceConfig);\n            }\n        }\n        loadWorkspaceConfigurationContents(workspaceIdentifier) {\n            if (!(this.workspaceConfig && resources.isEqual(this.workspaceConfig, workspaceIdentifier.configPath))) {\n                this.unWatchWorkspaceConfigurtionFile();\n                this.workspaceConfig = workspaceIdentifier.configPath;\n                this.watchWorkspaceConfigurationFile();\n            }\n            return this.fileService.resolveContent(this.workspaceConfig)\n                .then(content => content.value, e => {\n                errors.onUnexpectedError(e);\n                return '';\n            });\n        }\n        handleWorkspaceFileEvents(event) {\n            if (this.workspaceConfig) {\n                const events = event.changes;\n                let affectedByChanges = false;\n                // Find changes that affect workspace file\n                for (let i = 0, len = events.length; i < len && !affectedByChanges; i++) {\n                    affectedByChanges = resources.isEqual(this.workspaceConfig, events[i].resource);\n                }\n                if (affectedByChanges) {\n                    this.reloadConfigurationScheduler.schedule();\n                }\n            }\n        }\n    }\n    class CachedWorkspaceConfiguration extends lifecycle_1.Disposable {\n        constructor(environmentService) {\n            super();\n            this.environmentService = environmentService;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this.workspaceConfigurationModelParser = new configurationModels_2.WorkspaceConfigurationModelParser('');\n            this.workspaceSettings = new configurationModels_1.ConfigurationModel();\n        }\n        load(workspaceIdentifier) {\n            this.createPaths(workspaceIdentifier);\n            return pfs.readFile(this.cachedConfigurationPath)\n                .then(contents => {\n                this.workspaceConfigurationModelParser = new configurationModels_2.WorkspaceConfigurationModelParser(this.cachedConfigurationPath);\n                this.workspaceConfigurationModelParser.parse(contents.toString());\n                this.workspaceSettings = this.workspaceConfigurationModelParser.settingsModel.merge(this.workspaceConfigurationModelParser.launchModel);\n            }, () => { });\n        }\n        get workspaceIdentifier() {\n            return null;\n        }\n        getConfigurationModel() {\n            return this.workspaceConfigurationModelParser.configurationModel;\n        }\n        getFolders() {\n            return this.workspaceConfigurationModelParser.folders;\n        }\n        getWorkspaceSettings() {\n            return this.workspaceSettings;\n        }\n        reprocessWorkspaceSettings() {\n            return this.workspaceSettings;\n        }\n        updateWorkspace(workspaceIdentifier, configurationModel) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    this.createPaths(workspaceIdentifier);\n                    if (configurationModel.keys.length) {\n                        const exists = yield pfs.exists(this.cachedWorkspacePath);\n                        if (!exists) {\n                            yield pfs.mkdirp(this.cachedWorkspacePath);\n                        }\n                        const raw = JSON.stringify(configurationModel.toJSON().contents);\n                        yield pfs.writeFile(this.cachedConfigurationPath, raw);\n                    }\n                    else {\n                        pfs.rimraf(this.cachedWorkspacePath);\n                    }\n                }\n                catch (error) {\n                    errors.onUnexpectedError(error);\n                }\n            });\n        }\n        createPaths(workspaceIdentifier) {\n            this.cachedWorkspacePath = path_1.join(this.environmentService.userDataPath, 'CachedConfigurations', 'workspaces', workspaceIdentifier.id);\n            this.cachedConfigurationPath = path_1.join(this.cachedWorkspacePath, 'workspace.json');\n        }\n    }\n    function isFolderConfigurationFile(resource) {\n        const configurationNameResource = uri_1.URI.from({ scheme: resource.scheme, path: resources.basename(resource) });\n        return [`${configuration_1.FOLDER_SETTINGS_NAME}.json`, `${configuration_1.TASKS_CONFIGURATION_KEY}.json`, `${configuration_1.LAUNCH_CONFIGURATION_KEY}.json`].some(configurationFileName => resources.isEqual(configurationNameResource, uri_1.URI.from({ scheme: resource.scheme, path: configurationFileName }))); // only workspace config files\n    }\n    function isFolderSettingsConfigurationFile(resource) {\n        return resources.isEqual(uri_1.URI.from({ scheme: resource.scheme, path: resources.basename(resource) }), uri_1.URI.from({ scheme: resource.scheme, path: `${configuration_1.FOLDER_SETTINGS_NAME}.json` }));\n    }\n    class AbstractFolderConfiguration extends lifecycle_1.Disposable {\n        constructor(folder, workbenchState, from) {\n            super();\n            this.folder = folder;\n            this._loaded = false;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this._folderSettingsModelParser = from ? from._folderSettingsModelParser : new configurationModels_2.FolderSettingsModelParser(configuration_1.FOLDER_SETTINGS_PATH, workspace_1.WorkbenchState.WORKSPACE === workbenchState ? [configurationRegistry_1.ConfigurationScope.RESOURCE] : [configurationRegistry_1.ConfigurationScope.WINDOW, configurationRegistry_1.ConfigurationScope.RESOURCE]);\n            this._standAloneConfigurations = from ? from._standAloneConfigurations : [];\n            this._cache = from ? from._cache : new configurationModels_1.ConfigurationModel();\n        }\n        get loaded() {\n            return this._loaded;\n        }\n        loadConfiguration() {\n            return this.loadFolderConfigurationContents()\n                .then((contents) => {\n                // reset\n                this._standAloneConfigurations = [];\n                this._folderSettingsModelParser.parse('');\n                // parse\n                this.parseContents(contents);\n                // Consolidate (support *.json files in the workspace settings folder)\n                this.consolidate();\n                this._loaded = true;\n                return this._cache;\n            });\n        }\n        reprocess() {\n            const oldContents = this._folderSettingsModelParser.configurationModel.contents;\n            this._folderSettingsModelParser.reprocess();\n            if (!objects_1.equals(oldContents, this._folderSettingsModelParser.configurationModel.contents)) {\n                this.consolidate();\n            }\n            return this._cache;\n        }\n        consolidate() {\n            this._cache = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);\n        }\n        parseContents(contents) {\n            for (const content of contents) {\n                if (isFolderSettingsConfigurationFile(content.resource)) {\n                    this._folderSettingsModelParser.parse(content.value);\n                }\n                else {\n                    const name = resources.basename(content.resource);\n                    const matches = /([^\\.]*)*\\.json/.exec(name);\n                    if (matches && matches[1]) {\n                        const standAloneConfigurationModelParser = new configurationModels_2.StandaloneConfigurationModelParser(content.resource.toString(), matches[1]);\n                        standAloneConfigurationModelParser.parse(content.value);\n                        this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);\n                    }\n                }\n            }\n        }\n    }\n    exports.AbstractFolderConfiguration = AbstractFolderConfiguration;\n    class NodeBasedFolderConfiguration extends AbstractFolderConfiguration {\n        constructor(folder, configFolderRelativePath, workbenchState) {\n            super(folder, workbenchState);\n            this.folderConfigurationPath = resources.joinPath(folder, configFolderRelativePath);\n        }\n        loadFolderConfigurationContents() {\n            return this.resolveStat(this.folderConfigurationPath).then(stat => {\n                if (!stat.isDirectory || !stat.children) {\n                    return Promise.resolve([]);\n                }\n                return this.resolveContents(stat.children.filter(stat => isFolderConfigurationFile(stat.resource))\n                    .map(stat => stat.resource));\n            }, err => [] /* never fail this call */)\n                .then(undefined, e => {\n                errors.onUnexpectedError(e);\n                return [];\n            });\n        }\n        resolveContents(resources) {\n            return Promise.all(resources.map(resource => pfs.readFile(resource.fsPath)\n                .then(contents => ({ resource, value: contents.toString() }))));\n        }\n        resolveStat(resource) {\n            return new Promise((c, e) => {\n                extfs.readdir(resource.fsPath, (error, children) => {\n                    if (error) {\n                        if (error.code === 'ENOTDIR') {\n                            c({ resource });\n                        }\n                        else {\n                            e(error);\n                        }\n                    }\n                    else {\n                        c({\n                            resource,\n                            isDirectory: true,\n                            children: children.map(child => { return { resource: resources.joinPath(resource, child) }; })\n                        });\n                    }\n                });\n            });\n        }\n    }\n    exports.NodeBasedFolderConfiguration = NodeBasedFolderConfiguration;\n    class FileServiceBasedFolderConfiguration extends AbstractFolderConfiguration {\n        constructor(folder, configFolderRelativePath, workbenchState, fileService, from) {\n            super(folder, workbenchState, from);\n            this.configFolderRelativePath = configFolderRelativePath;\n            this.fileService = fileService;\n            this.loadConfigurationDelayer = new async_1.Delayer(50);\n            this.folderConfigurationPath = resources.joinPath(folder, configFolderRelativePath);\n            this.reloadConfigurationScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidChange.fire(), 50));\n            this._register(fileService.onFileChanges(e => this.handleWorkspaceFileEvents(e)));\n        }\n        loadFolderConfigurationContents() {\n            return Promise.resolve(this.loadConfigurationDelayer.trigger(() => this.doLoadFolderConfigurationContents()));\n        }\n        doLoadFolderConfigurationContents() {\n            const workspaceFilePathToConfiguration = Object.create(null);\n            const bulkContentFetchromise = Promise.resolve(this.fileService.resolveFile(this.folderConfigurationPath))\n                .then(stat => {\n                if (stat.isDirectory && stat.children) {\n                    stat.children\n                        .filter(child => isFolderConfigurationFile(child.resource))\n                        .forEach(child => {\n                        const folderRelativePath = this.toFolderRelativePath(child.resource);\n                        if (folderRelativePath) {\n                            workspaceFilePathToConfiguration[folderRelativePath] = Promise.resolve(this.fileService.resolveContent(child.resource)).then(undefined, errors.onUnexpectedError);\n                        }\n                    });\n                }\n            }).then(undefined, err => [] /* never fail this call */);\n            return bulkContentFetchromise.then(() => Promise.all(collections.values(workspaceFilePathToConfiguration))).then(contents => contents.filter(content => content !== undefined));\n        }\n        handleWorkspaceFileEvents(event) {\n            const events = event.changes;\n            let affectedByChanges = false;\n            // Find changes that affect workspace configuration files\n            for (let i = 0, len = events.length; i < len; i++) {\n                const resource = events[i].resource;\n                const basename = resources.basename(resource);\n                const isJson = path_1.extname(basename) === '.json';\n                const isDeletedSettingsFolder = (events[i].type === files_1.FileChangeType.DELETED && basename === this.configFolderRelativePath);\n                if (!isJson && !isDeletedSettingsFolder) {\n                    continue; // only JSON files or the actual settings folder\n                }\n                const folderRelativePath = this.toFolderRelativePath(resource);\n                if (!folderRelativePath) {\n                    continue; // event is not inside folder\n                }\n                // Handle case where \".vscode\" got deleted\n                if (isDeletedSettingsFolder) {\n                    affectedByChanges = true;\n                    break;\n                }\n                // only valid workspace config files\n                if (!isFolderConfigurationFile(resource)) {\n                    continue;\n                }\n                affectedByChanges = true;\n                break;\n            }\n            if (affectedByChanges) {\n                this.reloadConfigurationScheduler.schedule();\n            }\n        }\n        toFolderRelativePath(resource) {\n            if (resources.isEqualOrParent(resource, this.folderConfigurationPath)) {\n                return resources.relativePath(this.folderConfigurationPath, resource);\n            }\n            return undefined;\n        }\n    }\n    exports.FileServiceBasedFolderConfiguration = FileServiceBasedFolderConfiguration;\n    class CachedFolderConfiguration extends lifecycle_1.Disposable {\n        constructor(folder, configFolderRelativePath, environmentService) {\n            super();\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this.loaded = false;\n            this.cachedFolderPath = path_1.join(environmentService.userDataPath, 'CachedConfigurations', 'folders', crypto_1.createHash('md5').update(path_1.join(folder.path, configFolderRelativePath)).digest('hex'));\n            this.cachedConfigurationPath = path_1.join(this.cachedFolderPath, 'configuration.json');\n            this.configurationModel = new configurationModels_1.ConfigurationModel();\n        }\n        loadConfiguration() {\n            return pfs.readFile(this.cachedConfigurationPath)\n                .then(contents => {\n                const parsed = JSON.parse(contents.toString());\n                this.configurationModel = new configurationModels_1.ConfigurationModel(parsed.contents, parsed.keys, parsed.overrides);\n                this.loaded = true;\n                return this.configurationModel;\n            }, () => this.configurationModel);\n        }\n        updateConfiguration(configurationModel) {\n            const raw = JSON.stringify(configurationModel.toJSON());\n            return this.createCachedFolder().then(created => {\n                if (created) {\n                    return configurationModel.keys.length ? pfs.writeFile(this.cachedConfigurationPath, raw) : pfs.rimraf(this.cachedFolderPath);\n                }\n                return undefined;\n            });\n        }\n        reprocess() {\n            return this.configurationModel;\n        }\n        getUnsupportedKeys() {\n            return [];\n        }\n        createCachedFolder() {\n            return Promise.resolve(pfs.exists(this.cachedFolderPath))\n                .then(undefined, () => false)\n                .then(exists => exists ? exists : pfs.mkdirp(this.cachedFolderPath).then(() => true, () => false));\n        }\n    }\n    exports.CachedFolderConfiguration = CachedFolderConfiguration;\n    class FolderConfiguration extends lifecycle_1.Disposable {\n        constructor(workspaceFolder, configFolderRelativePath, workbenchState, environmentService, fileService) {\n            super();\n            this.workspaceFolder = workspaceFolder;\n            this.configFolderRelativePath = configFolderRelativePath;\n            this.workbenchState = workbenchState;\n            this.environmentService = environmentService;\n            this._onDidChange = this._register(new event_1.Emitter());\n            this.onDidChange = this._onDidChange.event;\n            this._loaded = false;\n            this.cachedFolderConfiguration = new CachedFolderConfiguration(this.workspaceFolder.uri, this.configFolderRelativePath, this.environmentService);\n            this.folderConfiguration = this.cachedFolderConfiguration;\n            if (fileService) {\n                this.folderConfiguration = new FileServiceBasedFolderConfiguration(this.workspaceFolder.uri, this.configFolderRelativePath, this.workbenchState, fileService);\n            }\n            else if (this.workspaceFolder.uri.scheme === network_1.Schemas.file) {\n                this.folderConfiguration = new NodeBasedFolderConfiguration(this.workspaceFolder.uri, this.configFolderRelativePath, this.workbenchState);\n            }\n            this._register(this.folderConfiguration.onDidChange(e => this.onDidFolderConfigurationChange()));\n        }\n        loadConfiguration() {\n            return this.folderConfiguration.loadConfiguration()\n                .then(model => {\n                this._loaded = this.folderConfiguration.loaded;\n                return model;\n            });\n        }\n        reprocess() {\n            return this.folderConfiguration.reprocess();\n        }\n        get loaded() {\n            return this._loaded;\n        }\n        adopt(fileService) {\n            if (fileService) {\n                if (this.folderConfiguration instanceof CachedFolderConfiguration) {\n                    return this.adoptFromCachedConfiguration(fileService);\n                }\n                if (this.folderConfiguration instanceof NodeBasedFolderConfiguration) {\n                    return this.adoptFromNodeBasedConfiguration(fileService);\n                }\n            }\n            return Promise.resolve(false);\n        }\n        adoptFromCachedConfiguration(fileService) {\n            const folderConfiguration = new FileServiceBasedFolderConfiguration(this.workspaceFolder.uri, this.configFolderRelativePath, this.workbenchState, fileService);\n            return folderConfiguration.loadConfiguration()\n                .then(() => {\n                this.folderConfiguration = folderConfiguration;\n                this._register(this.folderConfiguration.onDidChange(e => this.onDidFolderConfigurationChange()));\n                this.updateCache();\n                return true;\n            });\n        }\n        adoptFromNodeBasedConfiguration(fileService) {\n            const oldFolderConfiguration = this.folderConfiguration;\n            this.folderConfiguration = new FileServiceBasedFolderConfiguration(this.workspaceFolder.uri, this.configFolderRelativePath, this.workbenchState, fileService, oldFolderConfiguration);\n            oldFolderConfiguration.dispose();\n            this._register(this.folderConfiguration.onDidChange(e => this.onDidFolderConfigurationChange()));\n            return Promise.resolve(false);\n        }\n        onDidFolderConfigurationChange() {\n            this.updateCache();\n            this._onDidChange.fire();\n        }\n        updateCache() {\n            if (this.workspaceFolder.uri.scheme !== network_1.Schemas.file && this.folderConfiguration instanceof FileServiceBasedFolderConfiguration) {\n                return this.folderConfiguration.loadConfiguration()\n                    .then(configurationModel => this.cachedFolderConfiguration.updateConfiguration(configurationModel));\n            }\n            return Promise.resolve(undefined);\n        }\n    }\n    exports.FolderConfiguration = FolderConfiguration;\n});\n",null]}