{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleWordWrap.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleWordWrap.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls = require(\"vs/nls\");\nvar keyCodes_1 = require(\"vs/base/common/keyCodes\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar editorExtensions_1 = require(\"vs/editor/browser/editorExtensions\");\nvar codeEditorService_1 = require(\"vs/editor/browser/services/codeEditorService\");\nvar editorOptions_1 = require(\"vs/editor/common/config/editorOptions\");\nvar resourceConfiguration_1 = require(\"vs/editor/common/services/resourceConfiguration\");\nvar actions_1 = require(\"vs/platform/actions/common/actions\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar keybindingsRegistry_1 = require(\"vs/platform/keybinding/common/keybindingsRegistry\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar transientWordWrapState = 'transientWordWrapState';\nvar isWordWrapMinifiedKey = 'isWordWrapMinified';\nvar isDominatedByLongLinesKey = 'isDominatedByLongLines';\nvar inDiffEditorKey = 'inDiffEditor';\n/**\n * Store (in memory) the word wrap state for a particular model.\n */\nfunction writeTransientState(model, state, codeEditorService) {\n    codeEditorService.setTransientModelProperty(model, transientWordWrapState, state);\n}\nexports.writeTransientState = writeTransientState;\n/**\n * Read (in memory) the word wrap state for a particular model.\n */\nfunction readTransientState(model, codeEditorService) {\n    return codeEditorService.getTransientModelProperty(model, transientWordWrapState);\n}\nfunction readWordWrapState(model, configurationService, codeEditorService) {\n    var editorConfig = configurationService.getValue(model.uri, 'editor');\n    var _configuredWordWrap = editorConfig && (typeof editorConfig.wordWrap === 'string' || typeof editorConfig.wordWrap === 'boolean') ? editorConfig.wordWrap : undefined;\n    // Compatibility with old true or false values\n    if (_configuredWordWrap === true) {\n        _configuredWordWrap = 'on';\n    }\n    else if (_configuredWordWrap === false) {\n        _configuredWordWrap = 'off';\n    }\n    var _configuredWordWrapMinified = editorConfig && typeof editorConfig.wordWrapMinified === 'boolean' ? editorConfig.wordWrapMinified : undefined;\n    var _transientState = readTransientState(model, codeEditorService);\n    return {\n        configuredWordWrap: _configuredWordWrap,\n        configuredWordWrapMinified: (typeof _configuredWordWrapMinified === 'boolean' ? _configuredWordWrapMinified : editorOptions_1.EDITOR_DEFAULTS.wordWrapMinified),\n        transientState: _transientState\n    };\n}\nfunction toggleWordWrap(editor, state) {\n    if (state.transientState) {\n        // toggle off => go to null\n        return {\n            configuredWordWrap: state.configuredWordWrap,\n            configuredWordWrapMinified: state.configuredWordWrapMinified,\n            transientState: null\n        };\n    }\n    var config = editor.getConfiguration();\n    var transientState;\n    var actualWrappingInfo = config.wrappingInfo;\n    if (actualWrappingInfo.isWordWrapMinified) {\n        // => wrapping due to minified file\n        transientState = {\n            forceWordWrap: 'off',\n            forceWordWrapMinified: false\n        };\n    }\n    else if (state.configuredWordWrap !== 'off') {\n        // => wrapping is configured to be on (or some variant)\n        transientState = {\n            forceWordWrap: 'off',\n            forceWordWrapMinified: false\n        };\n    }\n    else {\n        // => wrapping is configured to be off\n        transientState = {\n            forceWordWrap: 'on',\n            forceWordWrapMinified: state.configuredWordWrapMinified\n        };\n    }\n    return {\n        configuredWordWrap: state.configuredWordWrap,\n        configuredWordWrapMinified: state.configuredWordWrapMinified,\n        transientState: transientState\n    };\n}\nvar TOGGLE_WORD_WRAP_ID = 'editor.action.toggleWordWrap';\nvar ToggleWordWrapAction = /** @class */ (function (_super) {\n    tslib_1.__extends(ToggleWordWrapAction, _super);\n    function ToggleWordWrapAction() {\n        return _super.call(this, {\n            id: TOGGLE_WORD_WRAP_ID,\n            label: nls.localize('toggle.wordwrap', \"View: Toggle Word Wrap\"),\n            alias: 'View: Toggle Word Wrap',\n            precondition: null,\n            kbOpts: {\n                kbExpr: null,\n                primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_Z,\n                weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n            }\n        }) || this;\n    }\n    ToggleWordWrapAction.prototype.run = function (accessor, editor) {\n        if (!editor.hasModel()) {\n            return;\n        }\n        var editorConfiguration = editor.getConfiguration();\n        if (editorConfiguration.wrappingInfo.inDiffEditor) {\n            // Cannot change wrapping settings inside the diff editor\n            var notificationService = accessor.get(notification_1.INotificationService);\n            notificationService.info(nls.localize('wordWrap.notInDiffEditor', \"Cannot toggle word wrap in a diff editor.\"));\n            return;\n        }\n        var textResourceConfigurationService = accessor.get(resourceConfiguration_1.ITextResourceConfigurationService);\n        var codeEditorService = accessor.get(codeEditorService_1.ICodeEditorService);\n        var model = editor.getModel();\n        if (!canToggleWordWrap(model.uri)) {\n            return;\n        }\n        // Read the current state\n        var currentState = readWordWrapState(model, textResourceConfigurationService, codeEditorService);\n        // Compute the new state\n        var newState = toggleWordWrap(editor, currentState);\n        // Write the new state\n        // (this will cause an event and the controller will apply the state)\n        writeTransientState(model, newState.transientState, codeEditorService);\n    };\n    return ToggleWordWrapAction;\n}(editorExtensions_1.EditorAction));\nvar ToggleWordWrapController = /** @class */ (function (_super) {\n    tslib_1.__extends(ToggleWordWrapController, _super);\n    function ToggleWordWrapController(editor, contextKeyService, configurationService, codeEditorService) {\n        var _this = _super.call(this) || this;\n        _this.editor = editor;\n        _this.contextKeyService = contextKeyService;\n        _this.configurationService = configurationService;\n        _this.codeEditorService = codeEditorService;\n        var configuration = _this.editor.getConfiguration();\n        var isWordWrapMinified = _this.contextKeyService.createKey(isWordWrapMinifiedKey, _this._isWordWrapMinified(configuration));\n        var isDominatedByLongLines = _this.contextKeyService.createKey(isDominatedByLongLinesKey, _this._isDominatedByLongLines(configuration));\n        var inDiffEditor = _this.contextKeyService.createKey(inDiffEditorKey, _this._inDiffEditor(configuration));\n        var currentlyApplyingEditorConfig = false;\n        _this._register(editor.onDidChangeConfiguration(function (e) {\n            if (!e.wrappingInfo) {\n                return;\n            }\n            var configuration = _this.editor.getConfiguration();\n            isWordWrapMinified.set(_this._isWordWrapMinified(configuration));\n            isDominatedByLongLines.set(_this._isDominatedByLongLines(configuration));\n            inDiffEditor.set(_this._inDiffEditor(configuration));\n            if (!currentlyApplyingEditorConfig) {\n                // I am not the cause of the word wrap getting changed\n                ensureWordWrapSettings();\n            }\n        }));\n        _this._register(editor.onDidChangeModel(function (e) {\n            ensureWordWrapSettings();\n        }));\n        _this._register(codeEditorService.onDidChangeTransientModelProperty(function () {\n            ensureWordWrapSettings();\n        }));\n        var ensureWordWrapSettings = function () {\n            // Ensure correct word wrap settings\n            var newModel = _this.editor.getModel();\n            if (!newModel) {\n                return;\n            }\n            var configuration = _this.editor.getConfiguration();\n            if (_this._inDiffEditor(configuration)) {\n                return;\n            }\n            if (!canToggleWordWrap(newModel.uri)) {\n                return;\n            }\n            // Read current configured values and toggle state\n            var desiredState = readWordWrapState(newModel, _this.configurationService, _this.codeEditorService);\n            // Apply the state\n            try {\n                currentlyApplyingEditorConfig = true;\n                _this._applyWordWrapState(desiredState);\n            }\n            finally {\n                currentlyApplyingEditorConfig = false;\n            }\n        };\n        return _this;\n    }\n    ToggleWordWrapController.prototype._applyWordWrapState = function (state) {\n        if (state.transientState) {\n            // toggle is on\n            this.editor.updateOptions({\n                wordWrap: state.transientState.forceWordWrap,\n                wordWrapMinified: state.transientState.forceWordWrapMinified\n            });\n            return;\n        }\n        // toggle is off\n        this.editor.updateOptions({\n            wordWrap: state.configuredWordWrap,\n            wordWrapMinified: state.configuredWordWrapMinified\n        });\n    };\n    ToggleWordWrapController.prototype._isWordWrapMinified = function (config) {\n        return config.wrappingInfo.isWordWrapMinified;\n    };\n    ToggleWordWrapController.prototype._isDominatedByLongLines = function (config) {\n        return config.wrappingInfo.isDominatedByLongLines;\n    };\n    ToggleWordWrapController.prototype._inDiffEditor = function (config) {\n        return config.wrappingInfo.inDiffEditor;\n    };\n    ToggleWordWrapController.prototype.getId = function () {\n        return ToggleWordWrapController._ID;\n    };\n    ToggleWordWrapController._ID = 'editor.contrib.toggleWordWrapController';\n    ToggleWordWrapController = tslib_1.__decorate([\n        tslib_1.__param(1, contextkey_1.IContextKeyService),\n        tslib_1.__param(2, resourceConfiguration_1.ITextResourceConfigurationService),\n        tslib_1.__param(3, codeEditorService_1.ICodeEditorService)\n    ], ToggleWordWrapController);\n    return ToggleWordWrapController;\n}(lifecycle_1.Disposable));\nfunction canToggleWordWrap(uri) {\n    if (!uri) {\n        return false;\n    }\n    return (uri.scheme !== 'output' && uri.scheme !== 'vscode');\n}\neditorExtensions_1.registerEditorContribution(ToggleWordWrapController);\neditorExtensions_1.registerEditorAction(ToggleWordWrapAction);\nactions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorTitle, {\n    command: {\n        id: TOGGLE_WORD_WRAP_ID,\n        title: nls.localize('unwrapMinified', \"Disable wrapping for this file\"),\n        iconLocation: { dark: uri_1.URI.parse(require.toUrl('vs/workbench/contrib/codeEditor/browser/WordWrap_16x.svg')) }\n    },\n    group: 'navigation',\n    order: 1,\n    when: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.not(inDiffEditorKey), contextkey_1.ContextKeyExpr.has(isDominatedByLongLinesKey), contextkey_1.ContextKeyExpr.has(isWordWrapMinifiedKey))\n});\nactions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorTitle, {\n    command: {\n        id: TOGGLE_WORD_WRAP_ID,\n        title: nls.localize('wrapMinified', \"Enable wrapping for this file\"),\n        iconLocation: { dark: uri_1.URI.parse(require.toUrl('vs/workbench/contrib/codeEditor/browser/WordWrap_16x.svg')) }\n    },\n    group: 'navigation',\n    order: 1,\n    when: contextkey_1.ContextKeyExpr.and(contextkey_1.ContextKeyExpr.not(inDiffEditorKey), contextkey_1.ContextKeyExpr.has(isDominatedByLongLinesKey), contextkey_1.ContextKeyExpr.not(isWordWrapMinifiedKey))\n});\n// View menu\nactions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarViewMenu, {\n    group: '5_editor',\n    command: {\n        id: TOGGLE_WORD_WRAP_ID,\n        title: nls.localize({ key: 'miToggleWordWrap', comment: ['&& denotes a mnemonic'] }, \"Toggle &&Word Wrap\")\n    },\n    order: 1\n});\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleWordWrap.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeEditor/browser/toggleWordWrap.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\nimport { KeyCode, KeyMod } from 'vs/base/common/keyCodes';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { ICodeEditor } from 'vs/editor/browser/editorBrowser';\nimport { EditorAction, ServicesAccessor, registerEditorAction, registerEditorContribution } from 'vs/editor/browser/editorExtensions';\nimport { ICodeEditorService } from 'vs/editor/browser/services/codeEditorService';\nimport { EDITOR_DEFAULTS, InternalEditorOptions } from 'vs/editor/common/config/editorOptions';\nimport { IEditorContribution } from 'vs/editor/common/editorCommon';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { ITextResourceConfigurationService } from 'vs/editor/common/services/resourceConfiguration';\nimport { MenuId, MenuRegistry } from 'vs/platform/actions/common/actions';\nimport { ContextKeyExpr, IContextKeyService } from 'vs/platform/contextkey/common/contextkey';\nimport { KeybindingWeight } from 'vs/platform/keybinding/common/keybindingsRegistry';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\n\nconst transientWordWrapState = 'transientWordWrapState';\nconst isWordWrapMinifiedKey = 'isWordWrapMinified';\nconst isDominatedByLongLinesKey = 'isDominatedByLongLines';\nconst inDiffEditorKey = 'inDiffEditor';\n\n/**\n * State written/read by the toggle word wrap action and associated with a particular model.\n */\ninterface IWordWrapTransientState {\n\treadonly forceWordWrap: 'on' | 'off' | 'wordWrapColumn' | 'bounded';\n\treadonly forceWordWrapMinified: boolean;\n}\n\ninterface IWordWrapState {\n\treadonly configuredWordWrap: 'on' | 'off' | 'wordWrapColumn' | 'bounded' | undefined;\n\treadonly configuredWordWrapMinified: boolean;\n\treadonly transientState: IWordWrapTransientState | null;\n}\n\n/**\n * Store (in memory) the word wrap state for a particular model.\n */\nexport function writeTransientState(model: ITextModel, state: IWordWrapTransientState | null, codeEditorService: ICodeEditorService): void {\n\tcodeEditorService.setTransientModelProperty(model, transientWordWrapState, state);\n}\n\n/**\n * Read (in memory) the word wrap state for a particular model.\n */\nfunction readTransientState(model: ITextModel, codeEditorService: ICodeEditorService): IWordWrapTransientState {\n\treturn codeEditorService.getTransientModelProperty(model, transientWordWrapState);\n}\n\nfunction readWordWrapState(model: ITextModel, configurationService: ITextResourceConfigurationService, codeEditorService: ICodeEditorService): IWordWrapState {\n\tconst editorConfig = configurationService.getValue(model.uri, 'editor') as { wordWrap: 'on' | 'off' | 'wordWrapColumn' | 'bounded'; wordWrapMinified: boolean };\n\tlet _configuredWordWrap = editorConfig && (typeof editorConfig.wordWrap === 'string' || typeof editorConfig.wordWrap === 'boolean') ? editorConfig.wordWrap : undefined;\n\n\t// Compatibility with old true or false values\n\tif (<any>_configuredWordWrap === true) {\n\t\t_configuredWordWrap = 'on';\n\t} else if (<any>_configuredWordWrap === false) {\n\t\t_configuredWordWrap = 'off';\n\t}\n\n\tconst _configuredWordWrapMinified = editorConfig && typeof editorConfig.wordWrapMinified === 'boolean' ? editorConfig.wordWrapMinified : undefined;\n\tconst _transientState = readTransientState(model, codeEditorService);\n\treturn {\n\t\tconfiguredWordWrap: _configuredWordWrap,\n\t\tconfiguredWordWrapMinified: (typeof _configuredWordWrapMinified === 'boolean' ? _configuredWordWrapMinified : EDITOR_DEFAULTS.wordWrapMinified),\n\t\ttransientState: _transientState\n\t};\n}\n\nfunction toggleWordWrap(editor: ICodeEditor, state: IWordWrapState): IWordWrapState {\n\tif (state.transientState) {\n\t\t// toggle off => go to null\n\t\treturn {\n\t\t\tconfiguredWordWrap: state.configuredWordWrap,\n\t\t\tconfiguredWordWrapMinified: state.configuredWordWrapMinified,\n\t\t\ttransientState: null\n\t\t};\n\t}\n\n\tconst config = editor.getConfiguration();\n\tlet transientState: IWordWrapTransientState;\n\n\tconst actualWrappingInfo = config.wrappingInfo;\n\tif (actualWrappingInfo.isWordWrapMinified) {\n\t\t// => wrapping due to minified file\n\t\ttransientState = {\n\t\t\tforceWordWrap: 'off',\n\t\t\tforceWordWrapMinified: false\n\t\t};\n\t} else if (state.configuredWordWrap !== 'off') {\n\t\t// => wrapping is configured to be on (or some variant)\n\t\ttransientState = {\n\t\t\tforceWordWrap: 'off',\n\t\t\tforceWordWrapMinified: false\n\t\t};\n\t} else {\n\t\t// => wrapping is configured to be off\n\t\ttransientState = {\n\t\t\tforceWordWrap: 'on',\n\t\t\tforceWordWrapMinified: state.configuredWordWrapMinified\n\t\t};\n\t}\n\n\treturn {\n\t\tconfiguredWordWrap: state.configuredWordWrap,\n\t\tconfiguredWordWrapMinified: state.configuredWordWrapMinified,\n\t\ttransientState: transientState\n\t};\n}\n\nconst TOGGLE_WORD_WRAP_ID = 'editor.action.toggleWordWrap';\nclass ToggleWordWrapAction extends EditorAction {\n\n\tconstructor() {\n\t\tsuper({\n\t\t\tid: TOGGLE_WORD_WRAP_ID,\n\t\t\tlabel: nls.localize('toggle.wordwrap', \"View: Toggle Word Wrap\"),\n\t\t\talias: 'View: Toggle Word Wrap',\n\t\t\tprecondition: null,\n\t\t\tkbOpts: {\n\t\t\t\tkbExpr: null,\n\t\t\t\tprimary: KeyMod.Alt | KeyCode.KEY_Z,\n\t\t\t\tweight: KeybindingWeight.EditorContrib\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic run(accessor: ServicesAccessor, editor: ICodeEditor): void {\n\t\tif (!editor.hasModel()) {\n\t\t\treturn;\n\t\t}\n\t\tconst editorConfiguration = editor.getConfiguration();\n\t\tif (editorConfiguration.wrappingInfo.inDiffEditor) {\n\t\t\t// Cannot change wrapping settings inside the diff editor\n\t\t\tconst notificationService = accessor.get(INotificationService);\n\t\t\tnotificationService.info(nls.localize('wordWrap.notInDiffEditor', \"Cannot toggle word wrap in a diff editor.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst textResourceConfigurationService = accessor.get(ITextResourceConfigurationService);\n\t\tconst codeEditorService = accessor.get(ICodeEditorService);\n\t\tconst model = editor.getModel();\n\n\t\tif (!canToggleWordWrap(model.uri)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Read the current state\n\t\tconst currentState = readWordWrapState(model, textResourceConfigurationService, codeEditorService);\n\t\t// Compute the new state\n\t\tconst newState = toggleWordWrap(editor, currentState);\n\t\t// Write the new state\n\t\t// (this will cause an event and the controller will apply the state)\n\t\twriteTransientState(model, newState.transientState, codeEditorService);\n\t}\n}\n\nclass ToggleWordWrapController extends Disposable implements IEditorContribution {\n\n\tprivate static readonly _ID = 'editor.contrib.toggleWordWrapController';\n\n\tconstructor(\n\t\tprivate readonly editor: ICodeEditor,\n\t\t@IContextKeyService readonly contextKeyService: IContextKeyService,\n\t\t@ITextResourceConfigurationService readonly configurationService: ITextResourceConfigurationService,\n\t\t@ICodeEditorService readonly codeEditorService: ICodeEditorService\n\t) {\n\t\tsuper();\n\n\t\tconst configuration = this.editor.getConfiguration();\n\t\tconst isWordWrapMinified = this.contextKeyService.createKey(isWordWrapMinifiedKey, this._isWordWrapMinified(configuration));\n\t\tconst isDominatedByLongLines = this.contextKeyService.createKey(isDominatedByLongLinesKey, this._isDominatedByLongLines(configuration));\n\t\tconst inDiffEditor = this.contextKeyService.createKey(inDiffEditorKey, this._inDiffEditor(configuration));\n\t\tlet currentlyApplyingEditorConfig = false;\n\n\t\tthis._register(editor.onDidChangeConfiguration((e) => {\n\t\t\tif (!e.wrappingInfo) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst configuration = this.editor.getConfiguration();\n\t\t\tisWordWrapMinified.set(this._isWordWrapMinified(configuration));\n\t\t\tisDominatedByLongLines.set(this._isDominatedByLongLines(configuration));\n\t\t\tinDiffEditor.set(this._inDiffEditor(configuration));\n\t\t\tif (!currentlyApplyingEditorConfig) {\n\t\t\t\t// I am not the cause of the word wrap getting changed\n\t\t\t\tensureWordWrapSettings();\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(editor.onDidChangeModel((e) => {\n\t\t\tensureWordWrapSettings();\n\t\t}));\n\n\t\tthis._register(codeEditorService.onDidChangeTransientModelProperty(() => {\n\t\t\tensureWordWrapSettings();\n\t\t}));\n\n\t\tconst ensureWordWrapSettings = () => {\n\t\t\t// Ensure correct word wrap settings\n\t\t\tconst newModel = this.editor.getModel();\n\t\t\tif (!newModel) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst configuration = this.editor.getConfiguration();\n\t\t\tif (this._inDiffEditor(configuration)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!canToggleWordWrap(newModel.uri)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Read current configured values and toggle state\n\t\t\tconst desiredState = readWordWrapState(newModel, this.configurationService, this.codeEditorService);\n\n\t\t\t// Apply the state\n\t\t\ttry {\n\t\t\t\tcurrentlyApplyingEditorConfig = true;\n\t\t\t\tthis._applyWordWrapState(desiredState);\n\t\t\t} finally {\n\t\t\t\tcurrentlyApplyingEditorConfig = false;\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate _applyWordWrapState(state: IWordWrapState): void {\n\t\tif (state.transientState) {\n\t\t\t// toggle is on\n\t\t\tthis.editor.updateOptions({\n\t\t\t\twordWrap: state.transientState.forceWordWrap,\n\t\t\t\twordWrapMinified: state.transientState.forceWordWrapMinified\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// toggle is off\n\t\tthis.editor.updateOptions({\n\t\t\twordWrap: state.configuredWordWrap,\n\t\t\twordWrapMinified: state.configuredWordWrapMinified\n\t\t});\n\t}\n\n\tprivate _isWordWrapMinified(config: InternalEditorOptions): boolean {\n\t\treturn config.wrappingInfo.isWordWrapMinified;\n\t}\n\n\tprivate _isDominatedByLongLines(config: InternalEditorOptions): boolean {\n\t\treturn config.wrappingInfo.isDominatedByLongLines;\n\t}\n\n\tprivate _inDiffEditor(config: InternalEditorOptions): boolean {\n\t\treturn config.wrappingInfo.inDiffEditor;\n\t}\n\n\tpublic getId(): string {\n\t\treturn ToggleWordWrapController._ID;\n\t}\n}\n\nfunction canToggleWordWrap(uri: URI): boolean {\n\tif (!uri) {\n\t\treturn false;\n\t}\n\treturn (uri.scheme !== 'output' && uri.scheme !== 'vscode');\n}\n\n\nregisterEditorContribution(ToggleWordWrapController);\n\nregisterEditorAction(ToggleWordWrapAction);\n\nMenuRegistry.appendMenuItem(MenuId.EditorTitle, {\n\tcommand: {\n\t\tid: TOGGLE_WORD_WRAP_ID,\n\t\ttitle: nls.localize('unwrapMinified', \"Disable wrapping for this file\"),\n\t\ticonLocation: { dark: URI.parse(require.toUrl('vs/workbench/contrib/codeEditor/browser/WordWrap_16x.svg')) }\n\t},\n\tgroup: 'navigation',\n\torder: 1,\n\twhen: ContextKeyExpr.and(\n\t\tContextKeyExpr.not(inDiffEditorKey),\n\t\tContextKeyExpr.has(isDominatedByLongLinesKey),\n\t\tContextKeyExpr.has(isWordWrapMinifiedKey)\n\t)\n});\nMenuRegistry.appendMenuItem(MenuId.EditorTitle, {\n\tcommand: {\n\t\tid: TOGGLE_WORD_WRAP_ID,\n\t\ttitle: nls.localize('wrapMinified', \"Enable wrapping for this file\"),\n\t\ticonLocation: { dark: URI.parse(require.toUrl('vs/workbench/contrib/codeEditor/browser/WordWrap_16x.svg')) }\n\t},\n\tgroup: 'navigation',\n\torder: 1,\n\twhen: ContextKeyExpr.and(\n\t\tContextKeyExpr.not(inDiffEditorKey),\n\t\tContextKeyExpr.has(isDominatedByLongLinesKey),\n\t\tContextKeyExpr.not(isWordWrapMinifiedKey)\n\t)\n});\n\n\n// View menu\nMenuRegistry.appendMenuItem(MenuId.MenubarViewMenu, {\n\tgroup: '5_editor',\n\tcommand: {\n\t\tid: TOGGLE_WORD_WRAP_ID,\n\t\ttitle: nls.localize({ key: 'miToggleWordWrap', comment: ['&& denotes a mnemonic'] }, \"Toggle &&Word Wrap\")\n\t},\n\torder: 1\n});\n"]}]}