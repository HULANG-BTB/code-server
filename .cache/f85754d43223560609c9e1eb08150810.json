{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/abstractDebugAdapter.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\"], function (require, exports, event_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Abstract implementation of the low level API for a debug adapter.\n     * Missing is how this API communicates with the debug adapter.\n     */\n    class AbstractDebugAdapter {\n        constructor() {\n            this.sequence = 1;\n            this.pendingRequests = new Map();\n            this._onError = new event_1.Emitter();\n            this._onExit = new event_1.Emitter();\n        }\n        get onError() {\n            return this._onError.event;\n        }\n        get onExit() {\n            return this._onExit.event;\n        }\n        onMessage(callback) {\n            if (this.eventCallback) {\n                this._onError.fire(new Error(`attempt to set more than one 'Message' callback`));\n            }\n            this.messageCallback = callback;\n        }\n        onEvent(callback) {\n            if (this.eventCallback) {\n                this._onError.fire(new Error(`attempt to set more than one 'Event' callback`));\n            }\n            this.eventCallback = callback;\n        }\n        onRequest(callback) {\n            if (this.requestCallback) {\n                this._onError.fire(new Error(`attempt to set more than one 'Request' callback`));\n            }\n            this.requestCallback = callback;\n        }\n        sendResponse(response) {\n            if (response.seq > 0) {\n                this._onError.fire(new Error(`attempt to send more than one response for command ${response.command}`));\n            }\n            else {\n                this.internalSend('response', response);\n            }\n        }\n        sendRequest(command, args, clb, timeout) {\n            const request = {\n                command: command\n            };\n            if (args && Object.keys(args).length > 0) {\n                request.arguments = args;\n            }\n            this.internalSend('request', request);\n            if (typeof timeout === 'number') {\n                const timer = setTimeout(() => {\n                    clearTimeout(timer);\n                    const clb = this.pendingRequests.get(request.seq);\n                    if (clb) {\n                        this.pendingRequests.delete(request.seq);\n                        const err = {\n                            type: 'response',\n                            seq: 0,\n                            request_seq: request.seq,\n                            success: false,\n                            command,\n                            message: `timeout after ${timeout} ms`\n                        };\n                        clb(err);\n                    }\n                }, timeout);\n            }\n            if (clb) {\n                // store callback for this request\n                this.pendingRequests.set(request.seq, clb);\n            }\n        }\n        acceptMessage(message) {\n            if (this.messageCallback) {\n                this.messageCallback(message);\n            }\n            else {\n                switch (message.type) {\n                    case 'event':\n                        if (this.eventCallback) {\n                            this.eventCallback(message);\n                        }\n                        break;\n                    case 'request':\n                        if (this.requestCallback) {\n                            this.requestCallback(message);\n                        }\n                        break;\n                    case 'response':\n                        const response = message;\n                        const clb = this.pendingRequests.get(response.request_seq);\n                        if (clb) {\n                            this.pendingRequests.delete(response.request_seq);\n                            clb(response);\n                        }\n                        break;\n                }\n            }\n        }\n        internalSend(typ, message) {\n            message.type = typ;\n            message.seq = this.sequence++;\n            this.sendMessage(message);\n        }\n        cancelPending() {\n            const pending = this.pendingRequests;\n            this.pendingRequests = new Map();\n            setTimeout(_ => {\n                pending.forEach((callback, request_seq) => {\n                    const err = {\n                        type: 'response',\n                        seq: 0,\n                        request_seq,\n                        success: false,\n                        command: 'canceled',\n                        message: 'canceled'\n                    };\n                    callback(err);\n                });\n            }, 1000);\n        }\n        dispose() {\n            this.cancelPending();\n        }\n    }\n    exports.AbstractDebugAdapter = AbstractDebugAdapter;\n});\n",null]}