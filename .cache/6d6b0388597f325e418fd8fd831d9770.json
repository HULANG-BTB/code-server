{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/debugSession.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/electron-browser/debugSession.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/resources\", \"vs/nls\", \"vs/base/common/platform\", \"vs/base/common/severity\", \"vs/base/common/event\", \"vs/editor/common/modes\", \"vs/base/browser/ui/aria/aria\", \"vs/workbench/contrib/debug/common/debug\", \"vs/workbench/contrib/debug/common/debugSource\", \"vs/base/common/objects\", \"vs/workbench/contrib/debug/common/debugModel\", \"vs/workbench/contrib/debug/electron-browser/rawDebugSession\", \"vs/platform/product/node/product\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/base/common/uuid\", \"vs/platform/windows/common/windows\", \"vs/platform/telemetry/common/telemetry\", \"vs/base/common/labels\", \"vs/workbench/contrib/output/common/output\", \"vs/editor/common/core/range\", \"vs/platform/configuration/common/configuration\", \"vs/workbench/services/viewlet/browser/viewlet\", \"vs/workbench/contrib/debug/common/replModel\", \"vs/base/common/errors\", \"vs/platform/environment/common/environment\", \"vs/platform/notification/common/notification\"], function (require, exports, resources, nls, platform, severity_1, event_1, modes_1, aria, debug_1, debugSource_1, objects_1, debugModel_1, rawDebugSession_1, product_1, workspace_1, lifecycle_1, async_1, uuid_1, windows_1, telemetry_1, labels_1, output_1, range_1, configuration_1, viewlet_1, replModel_1, errors_1, environment_1, notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let DebugSession = class DebugSession {\n        constructor(_configuration, root, model, _parentSession, debugService, telemetryService, outputService, windowService, configurationService, viewletService, workspaceContextService, environmentService, notificationService) {\n            this._configuration = _configuration;\n            this.root = root;\n            this.model = model;\n            this._parentSession = _parentSession;\n            this.debugService = debugService;\n            this.telemetryService = telemetryService;\n            this.outputService = outputService;\n            this.windowService = windowService;\n            this.configurationService = configurationService;\n            this.viewletService = viewletService;\n            this.workspaceContextService = workspaceContextService;\n            this.environmentService = environmentService;\n            this.notificationService = notificationService;\n            this.initialized = false;\n            this.sources = new Map();\n            this.threads = new Map();\n            this.rawListeners = [];\n            this._onDidChangeState = new event_1.Emitter();\n            this._onDidEndAdapter = new event_1.Emitter();\n            this._onDidLoadedSource = new event_1.Emitter();\n            this._onDidCustomEvent = new event_1.Emitter();\n            this._onDidChangeREPLElements = new event_1.Emitter();\n            this.id = uuid_1.generateUuid();\n            this.repl = new replModel_1.ReplModel(this);\n        }\n        getId() {\n            return this.id;\n        }\n        get configuration() {\n            return this._configuration.resolved;\n        }\n        get unresolvedConfiguration() {\n            return this._configuration.unresolved;\n        }\n        get parentSession() {\n            return this._parentSession;\n        }\n        setConfiguration(configuration) {\n            this._configuration = configuration;\n        }\n        getLabel() {\n            const includeRoot = this.workspaceContextService.getWorkspace().folders.length > 1;\n            return includeRoot && this.root ? `${this.configuration.name} (${resources.basenameOrAuthority(this.root.uri)})` : this.configuration.name;\n        }\n        get state() {\n            if (!this.initialized) {\n                return debug_1.State.Initializing;\n            }\n            if (!this.raw) {\n                return debug_1.State.Inactive;\n            }\n            const focusedThread = this.debugService.getViewModel().focusedThread;\n            if (focusedThread && focusedThread.session === this) {\n                return focusedThread.stopped ? debug_1.State.Stopped : debug_1.State.Running;\n            }\n            if (this.getAllThreads().some(t => t.stopped)) {\n                return debug_1.State.Stopped;\n            }\n            return debug_1.State.Running;\n        }\n        get capabilities() {\n            return this.raw ? this.raw.capabilities : Object.create(null);\n        }\n        //---- events\n        get onDidChangeState() {\n            return this._onDidChangeState.event;\n        }\n        get onDidEndAdapter() {\n            return this._onDidEndAdapter.event;\n        }\n        get onDidChangeReplElements() {\n            return this._onDidChangeREPLElements.event;\n        }\n        //---- DAP events\n        get onDidCustomEvent() {\n            return this._onDidCustomEvent.event;\n        }\n        get onDidLoadedSource() {\n            return this._onDidLoadedSource.event;\n        }\n        //---- DAP requests\n        /**\n         * create and initialize a new debug adapter for this session\n         */\n        initialize(dbgr) {\n            if (this.raw) {\n                // if there was already a connection make sure to remove old listeners\n                this.shutdown();\n            }\n            return dbgr.getCustomTelemetryService().then(customTelemetryService => {\n                return dbgr.createDebugAdapter(this, this.outputService).then(debugAdapter => {\n                    this.raw = new rawDebugSession_1.RawDebugSession(debugAdapter, dbgr, this.telemetryService, customTelemetryService, this.environmentService);\n                    return this.raw.start().then(() => {\n                        this.registerListeners();\n                        return this.raw.initialize({\n                            clientID: 'vscode',\n                            clientName: product_1.default.nameLong,\n                            adapterID: this.configuration.type,\n                            pathFormat: 'path',\n                            linesStartAt1: true,\n                            columnsStartAt1: true,\n                            supportsVariableType: true,\n                            supportsVariablePaging: true,\n                            supportsRunInTerminalRequest: true,\n                            locale: platform.locale\n                        }).then(() => {\n                            this.initialized = true;\n                            this._onDidChangeState.fire();\n                            this.model.setExceptionBreakpoints(this.raw.capabilities.exceptionBreakpointFilters || []);\n                        });\n                    });\n                });\n            }).then(undefined, err => {\n                this.initialized = true;\n                this._onDidChangeState.fire();\n                return Promise.reject(err);\n            });\n        }\n        /**\n         * launch or attach to the debuggee\n         */\n        launchOrAttach(config) {\n            if (this.raw) {\n                // __sessionID only used for EH debugging (but we add it always for now...)\n                config.__sessionId = this.getId();\n                return this.raw.launchOrAttach(config).then(result => {\n                    return undefined;\n                });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        /**\n         * end the current debug adapter session\n         */\n        terminate(restart = false) {\n            if (this.raw) {\n                if (this.raw.capabilities.supportsTerminateRequest && this._configuration.resolved.request === 'launch') {\n                    return this.raw.terminate(restart).then(response => {\n                        return undefined;\n                    });\n                }\n                return this.raw.disconnect(restart).then(response => {\n                    return undefined;\n                });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        /**\n         * end the current debug adapter session\n         */\n        disconnect(restart = false) {\n            if (this.raw) {\n                return this.raw.disconnect(restart).then(response => {\n                    return undefined;\n                });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        /**\n         * restart debug adapter session\n         */\n        restart() {\n            if (this.raw) {\n                return this.raw.restart().then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        sendBreakpoints(modelUri, breakpointsToSend, sourceModified) {\n            if (!this.raw) {\n                return Promise.reject(new Error('no debug adapter'));\n            }\n            if (!this.raw.readyForBreakpoints) {\n                return Promise.resolve(undefined);\n            }\n            const source = this.getSourceForUri(modelUri);\n            let rawSource;\n            if (source) {\n                rawSource = source.raw;\n            }\n            else {\n                const data = debugSource_1.Source.getEncodedDebugData(modelUri);\n                rawSource = { name: data.name, path: data.path, sourceReference: data.sourceReference };\n            }\n            if (breakpointsToSend.length && !rawSource.adapterData) {\n                rawSource.adapterData = breakpointsToSend[0].adapterData;\n            }\n            // Normalize all drive letters going out from vscode to debug adapters so we are consistent with our resolving #43959\n            if (rawSource.path) {\n                rawSource.path = labels_1.normalizeDriveLetter(rawSource.path);\n            }\n            return this.raw.setBreakpoints({\n                source: rawSource,\n                lines: breakpointsToSend.map(bp => bp.lineNumber),\n                breakpoints: breakpointsToSend.map(bp => ({ line: bp.lineNumber, column: bp.column, condition: bp.condition, hitCondition: bp.hitCondition, logMessage: bp.logMessage })),\n                sourceModified\n            }).then(response => {\n                if (response && response.body) {\n                    const data = Object.create(null);\n                    for (let i = 0; i < breakpointsToSend.length; i++) {\n                        data[breakpointsToSend[i].getId()] = response.body.breakpoints[i];\n                    }\n                    this.model.setBreakpointSessionData(this.getId(), data);\n                }\n            });\n        }\n        sendFunctionBreakpoints(fbpts) {\n            if (this.raw) {\n                if (this.raw.readyForBreakpoints) {\n                    return this.raw.setFunctionBreakpoints({ breakpoints: fbpts }).then(response => {\n                        if (response && response.body) {\n                            const data = Object.create(null);\n                            for (let i = 0; i < fbpts.length; i++) {\n                                data[fbpts[i].getId()] = response.body.breakpoints[i];\n                            }\n                            this.model.setBreakpointSessionData(this.getId(), data);\n                        }\n                    });\n                }\n                return Promise.resolve(undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        sendExceptionBreakpoints(exbpts) {\n            if (this.raw) {\n                if (this.raw.readyForBreakpoints) {\n                    return this.raw.setExceptionBreakpoints({ filters: exbpts.map(exb => exb.filter) }).then(() => undefined);\n                }\n                return Promise.resolve(undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        customRequest(request, args) {\n            if (this.raw) {\n                return this.raw.custom(request, args);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        stackTrace(threadId, startFrame, levels) {\n            if (this.raw) {\n                return this.raw.stackTrace({ threadId, startFrame, levels });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        exceptionInfo(threadId) {\n            if (this.raw) {\n                return this.raw.exceptionInfo({ threadId }).then(response => {\n                    if (response) {\n                        return {\n                            id: response.body.exceptionId,\n                            description: response.body.description,\n                            breakMode: response.body.breakMode,\n                            details: response.body.details\n                        };\n                    }\n                    return undefined;\n                });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        scopes(frameId) {\n            if (this.raw) {\n                return this.raw.scopes({ frameId });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        variables(variablesReference, filter, start, count) {\n            if (this.raw) {\n                return this.raw.variables({ variablesReference, filter, start, count });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        evaluate(expression, frameId, context) {\n            if (this.raw) {\n                return this.raw.evaluate({ expression, frameId, context });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        restartFrame(frameId, threadId) {\n            if (this.raw) {\n                return this.raw.restartFrame({ frameId }, threadId).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        next(threadId) {\n            if (this.raw) {\n                return this.raw.next({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        stepIn(threadId) {\n            if (this.raw) {\n                return this.raw.stepIn({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        stepOut(threadId) {\n            if (this.raw) {\n                return this.raw.stepOut({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        stepBack(threadId) {\n            if (this.raw) {\n                return this.raw.stepBack({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        continue(threadId) {\n            if (this.raw) {\n                return this.raw.continue({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        reverseContinue(threadId) {\n            if (this.raw) {\n                return this.raw.reverseContinue({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        pause(threadId) {\n            if (this.raw) {\n                return this.raw.pause({ threadId }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        terminateThreads(threadIds) {\n            if (this.raw) {\n                return this.raw.terminateThreads({ threadIds }).then(() => undefined);\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        setVariable(variablesReference, name, value) {\n            if (this.raw) {\n                return this.raw.setVariable({ variablesReference, name, value });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        loadSource(resource) {\n            if (!this.raw) {\n                return Promise.reject(new Error('no debug adapter'));\n            }\n            const source = this.getSourceForUri(resource);\n            let rawSource;\n            if (source) {\n                rawSource = source.raw;\n            }\n            else {\n                // create a Source\n                let sourceRef;\n                if (resource.query) {\n                    const data = debugSource_1.Source.getEncodedDebugData(resource);\n                    sourceRef = data.sourceReference;\n                }\n                rawSource = {\n                    path: resource.with({ scheme: '', query: '' }).toString(true),\n                    sourceReference: sourceRef\n                };\n            }\n            return this.raw.source({ sourceReference: rawSource.sourceReference || 0, source: rawSource });\n        }\n        getLoadedSources() {\n            if (this.raw) {\n                return this.raw.loadedSources({}).then(response => {\n                    if (response.body && response.body.sources) {\n                        return response.body.sources.map(src => this.getSource(src));\n                    }\n                    else {\n                        return [];\n                    }\n                }, () => {\n                    return [];\n                });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        completions(frameId, text, position, overwriteBefore) {\n            if (this.raw) {\n                return this.raw.completions({\n                    frameId,\n                    text,\n                    column: position.column,\n                    line: position.lineNumber\n                }).then(response => {\n                    const result = [];\n                    if (response && response.body && response.body.targets) {\n                        response.body.targets.forEach(item => {\n                            if (item && item.label) {\n                                result.push({\n                                    label: item.label,\n                                    insertText: item.text || item.label,\n                                    kind: modes_1.completionKindFromString(item.type || 'property'),\n                                    filterText: (item.start && item.length) ? text.substr(item.start, item.length).concat(item.label) : undefined,\n                                    range: range_1.Range.fromPositions(position.delta(0, -(item.length || overwriteBefore)), position)\n                                });\n                            }\n                        });\n                    }\n                    return result;\n                });\n            }\n            return Promise.reject(new Error('no debug adapter'));\n        }\n        //---- threads\n        getThread(threadId) {\n            return this.threads.get(threadId);\n        }\n        getAllThreads() {\n            const result = [];\n            this.threads.forEach(t => result.push(t));\n            return result;\n        }\n        clearThreads(removeThreads, reference = undefined) {\n            if (reference !== undefined && reference !== null) {\n                const thread = this.threads.get(reference);\n                if (thread) {\n                    thread.clearCallStack();\n                    thread.stoppedDetails = undefined;\n                    thread.stopped = false;\n                    if (removeThreads) {\n                        this.threads.delete(reference);\n                    }\n                }\n            }\n            else {\n                this.threads.forEach(thread => {\n                    thread.clearCallStack();\n                    thread.stoppedDetails = undefined;\n                    thread.stopped = false;\n                });\n                if (removeThreads) {\n                    this.threads.clear();\n                    debugModel_1.ExpressionContainer.allValues.clear();\n                }\n            }\n        }\n        rawUpdate(data) {\n            data.threads.forEach(thread => {\n                if (!this.threads.has(thread.id)) {\n                    // A new thread came in, initialize it.\n                    this.threads.set(thread.id, new debugModel_1.Thread(this, thread.name, thread.id));\n                }\n                else if (thread.name) {\n                    // Just the thread name got updated #18244\n                    const oldThread = this.threads.get(thread.id);\n                    if (oldThread) {\n                        oldThread.name = thread.name;\n                    }\n                }\n            });\n            const stoppedDetails = data.stoppedDetails;\n            if (stoppedDetails) {\n                // Set the availability of the threads' callstacks depending on\n                // whether the thread is stopped or not\n                if (stoppedDetails.allThreadsStopped) {\n                    this.threads.forEach(thread => {\n                        thread.stoppedDetails = thread.threadId === stoppedDetails.threadId ? stoppedDetails : { reason: undefined };\n                        thread.stopped = true;\n                        thread.clearCallStack();\n                    });\n                }\n                else {\n                    const thread = typeof stoppedDetails.threadId === 'number' ? this.threads.get(stoppedDetails.threadId) : undefined;\n                    if (thread) {\n                        // One thread is stopped, only update that thread.\n                        thread.stoppedDetails = stoppedDetails;\n                        thread.clearCallStack();\n                        thread.stopped = true;\n                    }\n                }\n            }\n        }\n        fetchThreads(stoppedDetails) {\n            return this.raw ? this.raw.threads().then(response => {\n                if (response && response.body && response.body.threads) {\n                    this.model.rawUpdate({\n                        sessionId: this.getId(),\n                        threads: response.body.threads,\n                        stoppedDetails\n                    });\n                }\n            }) : Promise.resolve(undefined);\n        }\n        //---- private\n        registerListeners() {\n            if (!this.raw) {\n                return;\n            }\n            this.rawListeners.push(this.raw.onDidInitialize(() => {\n                aria.status(nls.localize('debuggingStarted', \"Debugging started.\"));\n                const sendConfigurationDone = () => {\n                    if (this.raw && this.raw.capabilities.supportsConfigurationDoneRequest) {\n                        return this.raw.configurationDone().then(undefined, e => {\n                            // Disconnect the debug session on configuration done error #10596\n                            if (this.raw) {\n                                this.raw.disconnect();\n                            }\n                            if (e.command !== 'canceled' && e.message !== 'canceled') {\n                                this.notificationService.error(e);\n                            }\n                        });\n                    }\n                    return undefined;\n                };\n                // Send all breakpoints\n                this.debugService.sendAllBreakpoints(this).then(sendConfigurationDone, sendConfigurationDone)\n                    .then(() => this.fetchThreads());\n            }));\n            this.rawListeners.push(this.raw.onDidStop(event => {\n                this.fetchThreads(event.body).then(() => {\n                    const thread = typeof event.body.threadId === 'number' ? this.getThread(event.body.threadId) : undefined;\n                    if (thread) {\n                        // Call fetch call stack twice, the first only return the top stack frame.\n                        // Second retrieves the rest of the call stack. For performance reasons #25605\n                        const promises = this.model.fetchCallStack(thread);\n                        const focus = () => {\n                            if (!event.body.preserveFocusHint && thread.getCallStack().length) {\n                                this.debugService.focusStackFrame(undefined, thread);\n                                if (thread.stoppedDetails) {\n                                    if (this.configurationService.getValue('debug').openDebug === 'openOnDebugBreak') {\n                                        this.viewletService.openViewlet(debug_1.VIEWLET_ID);\n                                    }\n                                    this.windowService.focusWindow();\n                                }\n                            }\n                        };\n                        promises.topCallStack.then(focus);\n                        promises.wholeCallStack.then(() => {\n                            if (!this.debugService.getViewModel().focusedStackFrame) {\n                                // The top stack frame can be deemphesized so try to focus again #68616\n                                focus();\n                            }\n                        });\n                    }\n                }).then(() => this._onDidChangeState.fire());\n            }));\n            this.rawListeners.push(this.raw.onDidThread(event => {\n                if (event.body.reason === 'started') {\n                    // debounce to reduce threadsRequest frequency and improve performance\n                    if (!this.fetchThreadsScheduler) {\n                        this.fetchThreadsScheduler = new async_1.RunOnceScheduler(() => {\n                            this.fetchThreads();\n                        }, 100);\n                        this.rawListeners.push(this.fetchThreadsScheduler);\n                    }\n                    if (!this.fetchThreadsScheduler.isScheduled()) {\n                        this.fetchThreadsScheduler.schedule();\n                    }\n                }\n                else if (event.body.reason === 'exited') {\n                    this.model.clearThreads(this.getId(), true, event.body.threadId);\n                }\n            }));\n            this.rawListeners.push(this.raw.onDidTerminateDebugee(event => {\n                aria.status(nls.localize('debuggingStopped', \"Debugging stopped.\"));\n                if (event.body && event.body.restart) {\n                    this.debugService.restartSession(this, event.body.restart).then(undefined, errors_1.onUnexpectedError);\n                }\n                else if (this.raw) {\n                    this.raw.disconnect();\n                }\n            }));\n            this.rawListeners.push(this.raw.onDidContinued(event => {\n                const threadId = event.body.allThreadsContinued !== false ? undefined : event.body.threadId;\n                this.model.clearThreads(this.getId(), false, threadId);\n                this._onDidChangeState.fire();\n            }));\n            let outpuPromises = [];\n            this.rawListeners.push(this.raw.onDidOutput(event => {\n                if (!event.body || !this.raw) {\n                    return;\n                }\n                const outputSeverity = event.body.category === 'stderr' ? severity_1.default.Error : event.body.category === 'console' ? severity_1.default.Warning : severity_1.default.Info;\n                if (event.body.category === 'telemetry') {\n                    // only log telemetry events from debug adapter if the debug extension provided the telemetry key\n                    // and the user opted in telemetry\n                    if (this.raw.customTelemetryService && this.telemetryService.isOptedIn) {\n                        // __GDPR__TODO__ We're sending events in the name of the debug extension and we can not ensure that those are declared correctly.\n                        this.raw.customTelemetryService.publicLog(event.body.output, event.body.data);\n                    }\n                    return;\n                }\n                // Make sure to append output in the correct order by properly waiting on preivous promises #33822\n                const waitFor = outpuPromises.slice();\n                const source = event.body.source && event.body.line ? {\n                    lineNumber: event.body.line,\n                    column: event.body.column ? event.body.column : 1,\n                    source: this.getSource(event.body.source)\n                } : undefined;\n                if (event.body.variablesReference) {\n                    const container = new debugModel_1.ExpressionContainer(this, event.body.variablesReference, uuid_1.generateUuid());\n                    outpuPromises.push(container.getChildren().then(children => {\n                        return Promise.all(waitFor).then(() => children.forEach(child => {\n                            // Since we can not display multiple trees in a row, we are displaying these variables one after the other (ignoring their names)\n                            child.name = null;\n                            this.appendToRepl(child, outputSeverity, source);\n                        }));\n                    }));\n                }\n                else if (typeof event.body.output === 'string') {\n                    Promise.all(waitFor).then(() => this.appendToRepl(event.body.output, outputSeverity, source));\n                }\n                Promise.all(outpuPromises).then(() => outpuPromises = []);\n            }));\n            this.rawListeners.push(this.raw.onDidBreakpoint(event => {\n                const id = event.body && event.body.breakpoint ? event.body.breakpoint.id : undefined;\n                const breakpoint = this.model.getBreakpoints().filter(bp => bp.idFromAdapter === id).pop();\n                const functionBreakpoint = this.model.getFunctionBreakpoints().filter(bp => bp.idFromAdapter === id).pop();\n                if (event.body.reason === 'new' && event.body.breakpoint.source && event.body.breakpoint.line) {\n                    const source = this.getSource(event.body.breakpoint.source);\n                    const bps = this.model.addBreakpoints(source.uri, [{\n                            column: event.body.breakpoint.column,\n                            enabled: true,\n                            lineNumber: event.body.breakpoint.line,\n                        }], false);\n                    if (bps.length === 1) {\n                        this.model.setBreakpointSessionData(this.getId(), { [bps[0].getId()]: event.body.breakpoint });\n                    }\n                }\n                if (event.body.reason === 'removed') {\n                    if (breakpoint) {\n                        this.model.removeBreakpoints([breakpoint]);\n                    }\n                    if (functionBreakpoint) {\n                        this.model.removeFunctionBreakpoints(functionBreakpoint.getId());\n                    }\n                }\n                if (event.body.reason === 'changed') {\n                    if (breakpoint) {\n                        if (!breakpoint.column) {\n                            event.body.breakpoint.column = undefined;\n                        }\n                        this.model.setBreakpointSessionData(this.getId(), { [breakpoint.getId()]: event.body.breakpoint });\n                    }\n                    if (functionBreakpoint) {\n                        this.model.setBreakpointSessionData(this.getId(), { [functionBreakpoint.getId()]: event.body.breakpoint });\n                    }\n                }\n            }));\n            this.rawListeners.push(this.raw.onDidLoadedSource(event => {\n                this._onDidLoadedSource.fire({\n                    reason: event.body.reason,\n                    source: this.getSource(event.body.source)\n                });\n            }));\n            this.rawListeners.push(this.raw.onDidCustomEvent(event => {\n                this._onDidCustomEvent.fire(event);\n            }));\n            this.rawListeners.push(this.raw.onDidExitAdapter(event => {\n                this._onDidEndAdapter.fire(event);\n            }));\n        }\n        shutdown() {\n            lifecycle_1.dispose(this.rawListeners);\n            if (this.raw) {\n                this.raw.disconnect();\n            }\n            this.raw = undefined;\n            this.model.clearThreads(this.getId(), true);\n            this._onDidChangeState.fire();\n        }\n        //---- sources\n        getSourceForUri(uri) {\n            return this.sources.get(this.getUriKey(uri));\n        }\n        getSource(raw) {\n            let source = new debugSource_1.Source(raw, this.getId());\n            const uriKey = this.getUriKey(source.uri);\n            const found = this.sources.get(uriKey);\n            if (found) {\n                source = found;\n                // merge attributes of new into existing\n                source.raw = objects_1.mixin(source.raw, raw);\n                if (source.raw && raw) {\n                    // Always take the latest presentation hint from adapter #42139\n                    source.raw.presentationHint = raw.presentationHint;\n                }\n            }\n            else {\n                this.sources.set(uriKey, source);\n            }\n            return source;\n        }\n        getUriKey(uri) {\n            // TODO: the following code does not make sense if uri originates from a different platform\n            return platform.isLinux ? uri.toString() : uri.toString().toLowerCase();\n        }\n        // REPL\n        getReplElements() {\n            return this.repl.getReplElements();\n        }\n        removeReplExpressions() {\n            this.repl.removeReplExpressions();\n            this._onDidChangeREPLElements.fire();\n        }\n        addReplExpression(stackFrame, name) {\n            const viewModel = this.debugService.getViewModel();\n            return this.repl.addReplExpression(stackFrame, name)\n                .then(() => this._onDidChangeREPLElements.fire())\n                // Evaluate all watch expressions and fetch variables again since repl evaluation might have changed some.\n                .then(() => this.debugService.focusStackFrame(viewModel.focusedStackFrame, viewModel.focusedThread, viewModel.focusedSession));\n        }\n        appendToRepl(data, severity, source) {\n            this.repl.appendToRepl(data, severity, source);\n            this._onDidChangeREPLElements.fire();\n        }\n        logToRepl(sev, args, frame) {\n            this.repl.logToRepl(sev, args, frame);\n            this._onDidChangeREPLElements.fire();\n        }\n    };\n    DebugSession = __decorate([\n        __param(4, debug_1.IDebugService),\n        __param(5, telemetry_1.ITelemetryService),\n        __param(6, output_1.IOutputService),\n        __param(7, windows_1.IWindowService),\n        __param(8, configuration_1.IConfigurationService),\n        __param(9, viewlet_1.IViewletService),\n        __param(10, workspace_1.IWorkspaceContextService),\n        __param(11, environment_1.IEnvironmentService),\n        __param(12, notification_1.INotificationService)\n    ], DebugSession);\n    exports.DebugSession = DebugSession;\n});\n",null]}