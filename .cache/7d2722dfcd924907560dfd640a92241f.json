{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar position_1 = require(\"vs/editor/common/core/position\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar model_1 = require(\"vs/editor/common/model\");\nvar rbTreeBase_1 = require(\"vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase\");\nvar textModelSearch_1 = require(\"vs/editor/common/model/textModelSearch\");\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexports.AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    var r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nexports.createUintArray = createUintArray;\nvar LineStarts = /** @class */ (function () {\n    function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n    return LineStarts;\n}());\nexports.LineStarts = LineStarts;\nfunction createLineStartsFast(str, readonly) {\n    if (readonly === void 0) { readonly = true; }\n    var r = [0], rLength = 1;\n    for (var i = 0, len = str.length; i < len; i++) {\n        var chr = str.charCodeAt(i);\n        if (chr === charCode_1.CharCode.CarriageReturn) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === charCode_1.CharCode.LineFeed) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexports.createLineStartsFast = createLineStartsFast;\nfunction createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    var rLength = 1;\n    var cr = 0, lf = 0, crlf = 0;\n    var isBasicASCII = true;\n    for (var i = 0, len = str.length; i < len; i++) {\n        var chr = str.charCodeAt(i);\n        if (chr === charCode_1.CharCode.CarriageReturn) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === charCode_1.CharCode.LineFeed) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === charCode_1.CharCode.LineFeed) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== charCode_1.CharCode.Tab && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexports.createLineStarts = createLineStarts;\nvar Piece = /** @class */ (function () {\n    function Piece(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n    return Piece;\n}());\nexports.Piece = Piece;\nvar StringBuffer = /** @class */ (function () {\n    function StringBuffer(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n    return StringBuffer;\n}());\nexports.StringBuffer = StringBuffer;\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nvar PieceTreeSnapshot = /** @class */ (function () {\n    function PieceTreeSnapshot(tree, BOM) {\n        var _this = this;\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== rbTreeBase_1.SENTINEL) {\n            tree.iterate(tree.root, function (node) {\n                if (node !== rbTreeBase_1.SENTINEL) {\n                    _this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    PieceTreeSnapshot.prototype.read = function () {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    };\n    return PieceTreeSnapshot;\n}());\nvar PieceTreeSearchCache = /** @class */ (function () {\n    function PieceTreeSearchCache(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    PieceTreeSearchCache.prototype.get = function (offset) {\n        for (var i = this._cache.length - 1; i >= 0; i--) {\n            var nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    };\n    PieceTreeSearchCache.prototype.get2 = function (lineNumber) {\n        for (var i = this._cache.length - 1; i >= 0; i--) {\n            var nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    };\n    PieceTreeSearchCache.prototype.set = function (nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    };\n    PieceTreeSearchCache.prototype.valdiate = function (offset) {\n        var hasInvalidVal = false;\n        var tmp = this._cache;\n        for (var i = 0; i < tmp.length; i++) {\n            var nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            var newArr = [];\n            for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {\n                var entry = tmp_1[_i];\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    };\n    return PieceTreeSearchCache;\n}());\nvar PieceTreeBase = /** @class */ (function () {\n    function PieceTreeBase(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    PieceTreeBase.prototype.create = function (chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = rbTreeBase_1.SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        var lastNode = null;\n        for (var i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                var piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    };\n    PieceTreeBase.prototype.normalizeEOL = function (eol) {\n        var _this = this;\n        var averageBufferSize = exports.AverageBufferSize;\n        var min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        var max = min * 2;\n        var tempChunk = '';\n        var tempChunkLen = 0;\n        var chunks = [];\n        this.iterate(this.root, function (node) {\n            var str = _this.getNodeContent(node);\n            var len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    };\n    // #region Buffer API\n    PieceTreeBase.prototype.getEOL = function () {\n        return this._EOL;\n    };\n    PieceTreeBase.prototype.setEOL = function (newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    };\n    PieceTreeBase.prototype.createSnapshot = function (BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    };\n    PieceTreeBase.prototype.equal = function (other) {\n        var _this = this;\n        if (this.getLength() !== other.getLength()) {\n            return false;\n        }\n        if (this.getLineCount() !== other.getLineCount()) {\n            return false;\n        }\n        var offset = 0;\n        var ret = this.iterate(this.root, function (node) {\n            if (node === rbTreeBase_1.SENTINEL) {\n                return true;\n            }\n            var str = _this.getNodeContent(node);\n            var len = str.length;\n            var startPosition = other.nodeAt(offset);\n            var endPosition = other.nodeAt(offset + len);\n            var val = other.getValueInRange2(startPosition, endPosition);\n            return str === val;\n        });\n        return ret;\n    };\n    PieceTreeBase.prototype.getOffsetAt = function (lineNumber, column) {\n        var leftLen = 0; // inorder\n        var x = this.root;\n        while (x !== rbTreeBase_1.SENTINEL) {\n            if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    };\n    PieceTreeBase.prototype.getPositionAt = function (offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        var x = this.root;\n        var lfCnt = 0;\n        var originalOffset = offset;\n        while (x !== rbTreeBase_1.SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                var out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    var column = originalOffset - lineStartOffset;\n                    return new position_1.Position(lfCnt + 1, column + 1);\n                }\n                return new position_1.Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === rbTreeBase_1.SENTINEL) {\n                    // last node\n                    var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    var column = originalOffset - offset - lineStartOffset;\n                    return new position_1.Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new position_1.Position(1, 1);\n    };\n    PieceTreeBase.prototype.getValueInRange = function (range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        var value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    };\n    PieceTreeBase.prototype.getValueInRange2 = function (startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            var node = startPosition.node;\n            var buffer_1 = this._buffers[node.piece.bufferIndex].buffer;\n            var startOffset_1 = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer_1.substring(startOffset_1 + startPosition.remainder, startOffset_1 + endPosition.remainder);\n        }\n        var x = startPosition.node;\n        var buffer = this._buffers[x.piece.bufferIndex].buffer;\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== rbTreeBase_1.SENTINEL) {\n            var buffer_2 = this._buffers[x.piece.bufferIndex].buffer;\n            var startOffset_2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer_2.substring(startOffset_2, startOffset_2 + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer_2.substr(startOffset_2, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    };\n    PieceTreeBase.prototype.getLinesContent = function () {\n        return this.getContentOfSubTree(this.root).split(/\\r\\n|\\r|\\n/);\n    };\n    PieceTreeBase.prototype.getLength = function () {\n        return this._length;\n    };\n    PieceTreeBase.prototype.getLineCount = function () {\n        return this._lineCnt;\n    };\n    PieceTreeBase.prototype.getLineContent = function (lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    };\n    PieceTreeBase.prototype.getLineCharCode = function (lineNumber, index) {\n        var nodePos = this.nodeAt2(lineNumber, index + 1);\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            var matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            var buffer = this._buffers[matchingNode.piece.bufferIndex];\n            var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            var buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            var startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            var targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    };\n    PieceTreeBase.prototype.getLineLength = function (lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            var startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    };\n    PieceTreeBase.prototype.findMatchesInNode = function (node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        var buffer = this._buffers[node.piece.bufferIndex];\n        var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        var m;\n        // Reset regex to search from the beginning\n        searcher.reset(start);\n        var ret = { line: 0, column: 0 };\n        do {\n            m = searcher.next(buffer.buffer);\n            if (m) {\n                if (m.index >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, m.index - startOffsetInBuffer, ret);\n                var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                var retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = textModelSearch_1.createFindMatch(new range_1.Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (m.index + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    };\n    PieceTreeBase.prototype.findMatchesLineByLine = function (searchRange, searchData, captureMatches, limitResultCount) {\n        var result = [];\n        var resultLen = 0;\n        var searcher = new textModelSearch_1.Searcher(searchData.wordSeparators, searchData.regex);\n        var startPostion = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPostion === null) {\n            return [];\n        }\n        var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        var start = this.positionInBuffer(startPostion.node, startPostion.remainder);\n        var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPostion.node === endPosition.node) {\n            this.findMatchesInNode(startPostion.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        var startLineNumber = searchRange.startLineNumber;\n        var currentNode = startPostion.node;\n        while (currentNode !== endPosition.node) {\n            var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                var startColumn_1 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn_1, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            var startColumn_2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                var text = this.getLineContent(startLineNumber).substring(startColumn_2, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn_2), startLineNumber, startColumn_2, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPostion = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPostion.node;\n            start = this.positionInBuffer(startPostion.node, startPostion.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            var startColumn_3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            var text = this.getLineContent(startLineNumber).substring(startColumn_3, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn_3, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    };\n    PieceTreeBase.prototype._findMatchesInLine = function (searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        var wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            var searchString = searchData.simpleSearch;\n            var searchStringLen = searchString.length;\n            var textLength = text.length;\n            var lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || textModelSearch_1.isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new model_1.FindMatch(new range_1.Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        var m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = textModelSearch_1.createFindMatch(new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    };\n    // #endregion\n    // #region Piece Table\n    PieceTreeBase.prototype.insert = function (offset, value, eolNormalized) {\n        if (eolNormalized === void 0) { eolNormalized = false; }\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== rbTreeBase_1.SENTINEL) {\n            var _a = this.nodeAt(offset), node = _a.node, remainder = _a.remainder, nodeStartOffset = _a.nodeStartOffset;\n            var piece = node.piece;\n            var bufferIndex = piece.bufferIndex;\n            var insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < exports.AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.valdiate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                var nodesToDel = [];\n                var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    var headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        var newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        var previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                var newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                var tmpNode = node;\n                for (var k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            var pieces = this.createNewPieces(value);\n            var node = this.rbInsertLeft(null, pieces[0]);\n            for (var k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    };\n    PieceTreeBase.prototype.delete = function (offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === rbTreeBase_1.SENTINEL) {\n            return;\n        }\n        var startPosition = this.nodeAt(offset);\n        var endPosition = this.nodeAt(offset + cnt);\n        var startNode = startPosition.node;\n        var endNode = endPosition.node;\n        if (startNode === endNode) {\n            var startSplitPosInBuffer_1 = this.positionInBuffer(startNode, startPosition.remainder);\n            var endSplitPosInBuffer_1 = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    var next = startNode.next();\n                    rbTreeBase_1.rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer_1);\n                this._searchCache.valdiate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer_1);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer_1, endSplitPosInBuffer_1);\n            this.computeBufferMetadata();\n            return;\n        }\n        var nodesToDel = [];\n        var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.valdiate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        var secondNode = startNode.next();\n        for (var node = secondNode; node !== rbTreeBase_1.SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    };\n    PieceTreeBase.prototype.insertContentToNodeLeft = function (value, node) {\n        // we are inserting content to the beginning of node\n        var nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            var piece = node.piece;\n            var newStart = { line: piece.start.line + 1, column: 0 };\n            var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            rbTreeBase_1.updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        var newPieces = this.createNewPieces(value);\n        var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (var k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    };\n    PieceTreeBase.prototype.insertContentToNodeRight = function (value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        var newPieces = this.createNewPieces(value);\n        var newNode = this.rbInsertRight(node, newPieces[0]);\n        var tmpNode = newNode;\n        for (var k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    };\n    PieceTreeBase.prototype.positionInBuffer = function (node, remainder, ret) {\n        var piece = node.piece;\n        var bufferIndex = node.piece.bufferIndex;\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\n        var startOffset = lineStarts[piece.start.line] + piece.start.column;\n        var offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        var low = piece.start.line;\n        var high = piece.end.line;\n        var mid = 0;\n        var midStop = 0;\n        var midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    };\n    PieceTreeBase.prototype.getLineFeedCnt = function (bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        var nextLineStartOffset = lineStarts[end.line + 1];\n        var endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        var buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    };\n    PieceTreeBase.prototype.offsetInBuffer = function (bufferIndex, cursor) {\n        var lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    };\n    PieceTreeBase.prototype.deleteNodes = function (nodes) {\n        for (var i = 0; i < nodes.length; i++) {\n            rbTreeBase_1.rbDelete(this, nodes[i]);\n        }\n    };\n    PieceTreeBase.prototype.createNewPieces = function (text) {\n        if (text.length > exports.AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            var newPieces = [];\n            while (text.length > exports.AverageBufferSize) {\n                var lastChar = text.charCodeAt(exports.AverageBufferSize - 1);\n                var splitText = void 0;\n                if (lastChar === charCode_1.CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, exports.AverageBufferSize - 1);\n                    text = text.substring(exports.AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, exports.AverageBufferSize);\n                    text = text.substring(exports.AverageBufferSize);\n                }\n                var lineStarts_1 = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_1.length - 1, column: splitText.length - lineStarts_1[lineStarts_1.length - 1] }, lineStarts_1.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts_1));\n            }\n            var lineStarts_2 = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts_2.length - 1, column: text.length - lineStarts_2[lineStarts_2.length - 1] }, lineStarts_2.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts_2));\n            return newPieces;\n        }\n        var startOffset = this._buffers[0].buffer.length;\n        var lineStarts = createLineStartsFast(text, false);\n        var start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (var i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (var i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        var endOffset = this._buffers[0].buffer.length;\n        var endIndex = this._buffers[0].lineStarts.length - 1;\n        var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        var endPos = { line: endIndex, column: endColumn };\n        var newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    };\n    PieceTreeBase.prototype.getLinesRawContent = function () {\n        return this.getContentOfSubTree(this.root);\n    };\n    PieceTreeBase.prototype.getLineRawContent = function (lineNumber, endOffset) {\n        if (endOffset === void 0) { endOffset = 0; }\n        var x = this.root;\n        var ret = '';\n        var cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            var buffer = this._buffers[x.piece.bufferIndex].buffer;\n            var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n            }\n            else {\n                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n            }\n        }\n        else {\n            var nodeStartOffset = 0;\n            var originalLineNumber = lineNumber;\n            while (x !== rbTreeBase_1.SENTINEL) {\n                if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    var buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset: nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    var buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== rbTreeBase_1.SENTINEL) {\n            var buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                var accumualtedValue = this.getAccumulatedValue(x, 0);\n                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\n                return ret;\n            }\n            else {\n                var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    };\n    PieceTreeBase.prototype.computeBufferMetadata = function () {\n        var x = this.root;\n        var lfCnt = 1;\n        var len = 0;\n        while (x !== rbTreeBase_1.SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.valdiate(this._length);\n    };\n    // #region node operations\n    PieceTreeBase.prototype.getIndexOf = function (node, accumulatedValue) {\n        var piece = node.piece;\n        var pos = this.positionInBuffer(node, accumulatedValue);\n        var lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    };\n    PieceTreeBase.prototype.getAccumulatedValue = function (node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        var piece = node.piece;\n        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        var expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    };\n    PieceTreeBase.prototype.deleteNodeTail = function (node, pos) {\n        var piece = node.piece;\n        var originalLFCnt = piece.lineFeedCnt;\n        var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        var newEnd = pos;\n        var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        var lf_delta = newLineFeedCnt - originalLFCnt;\n        var size_delta = newEndOffset - originalEndOffset;\n        var newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        rbTreeBase_1.updateTreeMetadata(this, node, size_delta, lf_delta);\n    };\n    PieceTreeBase.prototype.deleteNodeHead = function (node, pos) {\n        var piece = node.piece;\n        var originalLFCnt = piece.lineFeedCnt;\n        var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        var newStart = pos;\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        var lf_delta = newLineFeedCnt - originalLFCnt;\n        var size_delta = originalStartOffset - newStartOffset;\n        var newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        rbTreeBase_1.updateTreeMetadata(this, node, size_delta, lf_delta);\n    };\n    PieceTreeBase.prototype.shrinkNode = function (node, start, end) {\n        var piece = node.piece;\n        var originalStartPos = piece.start;\n        var originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        var oldLength = piece.length;\n        var oldLFCnt = piece.lineFeedCnt;\n        var newEnd = start;\n        var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        rbTreeBase_1.updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        var newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    };\n    PieceTreeBase.prototype.appendToNode = function (node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        var startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        var lineStarts = createLineStartsFast(value, false);\n        for (var i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        var endIndex = this._buffers[0].lineStarts.length - 1;\n        var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        var newEnd = { line: endIndex, column: endColumn };\n        var newLength = node.piece.length + value.length;\n        var oldLineFeedCnt = node.piece.lineFeedCnt;\n        var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        var lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        rbTreeBase_1.updateTreeMetadata(this, node, value.length, lf_delta);\n    };\n    PieceTreeBase.prototype.nodeAt = function (offset) {\n        var x = this.root;\n        var cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        var nodeStartOffset = 0;\n        while (x !== rbTreeBase_1.SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                var ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset: nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    };\n    PieceTreeBase.prototype.nodeAt2 = function (lineNumber, column) {\n        var x = this.root;\n        var nodeStartOffset = 0;\n        while (x !== rbTreeBase_1.SENTINEL) {\n            if (x.left !== rbTreeBase_1.SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                var accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\n                    nodeStartOffset: nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset: nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== rbTreeBase_1.SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                var accumualtedValue = this.getAccumulatedValue(x, 0);\n                var nodeStartOffset_1 = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumualtedValue),\n                    nodeStartOffset: nodeStartOffset_1\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    var nodeStartOffset_2 = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset: nodeStartOffset_2\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    };\n    PieceTreeBase.prototype.nodeCharCodeAt = function (node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        var buffer = this._buffers[node.piece.bufferIndex];\n        var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    };\n    PieceTreeBase.prototype.offsetOfNode = function (node) {\n        if (!node) {\n            return 0;\n        }\n        var pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    };\n    // #endregion\n    // #region CRLF\n    PieceTreeBase.prototype.shouldCheckCRLF = function () {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    };\n    PieceTreeBase.prototype.startWithLF = function (val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === rbTreeBase_1.SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        var piece = val.piece;\n        var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        var line = piece.start.line;\n        var startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        var nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    };\n    PieceTreeBase.prototype.endWithCR = function (val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === rbTreeBase_1.SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    };\n    PieceTreeBase.prototype.validateCRLFWithPrevNode = function (nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            var node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    };\n    PieceTreeBase.prototype.validateCRLFWithNextNode = function (node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            var nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    };\n    PieceTreeBase.prototype.fixCRLF = function (prev, next) {\n        var nodesToDel = [];\n        // update node\n        var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        var newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        var prevNewLength = prev.piece.length - 1;\n        var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        rbTreeBase_1.updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        var newStart = { line: next.piece.start.line + 1, column: 0 };\n        var newLength = next.piece.length - 1;\n        var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        rbTreeBase_1.updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        var pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (var i = 0; i < nodesToDel.length; i++) {\n            rbTreeBase_1.rbDelete(this, nodesToDel[i]);\n        }\n    };\n    PieceTreeBase.prototype.adjustCarriageReturnFromNext = function (value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            var nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbTreeBase_1.rbDelete(this, nextNode);\n                }\n                else {\n                    var piece = nextNode.piece;\n                    var newStart = { line: piece.start.line + 1, column: 0 };\n                    var newLength = piece.length - 1;\n                    var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    rbTreeBase_1.updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    PieceTreeBase.prototype.iterate = function (node, callback) {\n        if (node === rbTreeBase_1.SENTINEL) {\n            return callback(rbTreeBase_1.SENTINEL);\n        }\n        var leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    };\n    PieceTreeBase.prototype.getNodeContent = function (node) {\n        if (node === rbTreeBase_1.SENTINEL) {\n            return '';\n        }\n        var buffer = this._buffers[node.piece.bufferIndex];\n        var currentContent;\n        var piece = node.piece;\n        var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    };\n    PieceTreeBase.prototype.getPieceContent = function (piece) {\n        var buffer = this._buffers[piece.bufferIndex];\n        var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        var currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    };\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    PieceTreeBase.prototype.rbInsertRight = function (node, p) {\n        var z = new rbTreeBase_1.TreeNode(p, rbTreeBase_1.NodeColor.Red);\n        z.left = rbTreeBase_1.SENTINEL;\n        z.right = rbTreeBase_1.SENTINEL;\n        z.parent = rbTreeBase_1.SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        var x = this.root;\n        if (x === rbTreeBase_1.SENTINEL) {\n            this.root = z;\n            z.color = rbTreeBase_1.NodeColor.Black;\n        }\n        else if (node.right === rbTreeBase_1.SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            var nextNode = rbTreeBase_1.leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        rbTreeBase_1.fixInsert(this, z);\n        return z;\n    };\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    PieceTreeBase.prototype.rbInsertLeft = function (node, p) {\n        var z = new rbTreeBase_1.TreeNode(p, rbTreeBase_1.NodeColor.Red);\n        z.left = rbTreeBase_1.SENTINEL;\n        z.right = rbTreeBase_1.SENTINEL;\n        z.parent = rbTreeBase_1.SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === rbTreeBase_1.SENTINEL) {\n            this.root = z;\n            z.color = rbTreeBase_1.NodeColor.Black;\n        }\n        else if (node.left === rbTreeBase_1.SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            var prevNode = rbTreeBase_1.righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        rbTreeBase_1.fixInsert(this, z);\n        return z;\n    };\n    PieceTreeBase.prototype.getContentOfSubTree = function (node) {\n        var _this = this;\n        var str = '';\n        this.iterate(node, function (node) {\n            str += _this.getNodeContent(node);\n            return true;\n        });\n        return str;\n    };\n    return PieceTreeBase;\n}());\nexports.PieceTreeBase = PieceTreeBase;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Range } from 'vs/editor/common/core/range';\nimport { FindMatch } from 'vs/editor/common/model';\nimport { NodeColor, SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from 'vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase';\nimport { SearchData, Searcher, createFindMatch, isValidMatch } from 'vs/editor/common/model/textModelSearch';\nimport { ITextSnapshot } from 'vs/platform/files/common/files';\n\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\n\nexport function createUintArray(arr: number[]): Uint32Array | Uint16Array {\n\tlet r;\n\tif (arr[arr.length - 1] < 65536) {\n\t\tr = new Uint16Array(arr.length);\n\t} else {\n\t\tr = new Uint32Array(arr.length);\n\t}\n\tr.set(arr, 0);\n\treturn r;\n}\n\nexport class LineStarts {\n\tconstructor(\n\t\tpublic readonly lineStarts: Uint32Array | Uint16Array | number[],\n\t\tpublic readonly cr: number,\n\t\tpublic readonly lf: number,\n\t\tpublic readonly crlf: number,\n\t\tpublic readonly isBasicASCII: boolean\n\t) { }\n}\n\nexport function createLineStartsFast(str: string, readonly: boolean = true): Uint32Array | Uint16Array | number[] {\n\tlet r: number[] = [0], rLength = 1;\n\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tr[rLength++] = i + 1;\n\t\t}\n\t}\n\tif (readonly) {\n\t\treturn createUintArray(r);\n\t} else {\n\t\treturn r;\n\t}\n}\n\nexport function createLineStarts(r: number[], str: string): LineStarts {\n\tr.length = 0;\n\tr[0] = 0;\n\tlet rLength = 1;\n\tlet cr = 0, lf = 0, crlf = 0;\n\tlet isBasicASCII = true;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chr = str.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (i + 1 < len && str.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\tcrlf++;\n\t\t\t\tr[rLength++] = i + 2;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\tcr++;\n\t\t\t\t// \\r... case\n\t\t\t\tr[rLength++] = i + 1;\n\t\t\t}\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\tlf++;\n\t\t\tr[rLength++] = i + 1;\n\t\t} else {\n\t\t\tif (isBasicASCII) {\n\t\t\t\tif (chr !== CharCode.Tab && (chr < 32 || chr > 126)) {\n\t\t\t\t\tisBasicASCII = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tconst result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n\tr.length = 0;\n\n\treturn result;\n}\n\nexport interface NodePosition {\n\t/**\n\t * Piece Index\n\t */\n\tnode: TreeNode;\n\t/**\n\t * remainer in current piece.\n\t*/\n\tremainder: number;\n\t/**\n\t * node start offset in document.\n\t */\n\tnodeStartOffset: number;\n}\n\nexport interface BufferCursor {\n\t/**\n\t * Line number in current buffer\n\t */\n\tline: number;\n\t/**\n\t * Column number in current buffer\n\t */\n\tcolumn: number;\n}\n\nexport class Piece {\n\treadonly bufferIndex: number;\n\treadonly start: BufferCursor;\n\treadonly end: BufferCursor;\n\treadonly length: number;\n\treadonly lineFeedCnt: number;\n\n\tconstructor(bufferIndex: number, start: BufferCursor, end: BufferCursor, lineFeedCnt: number, length: number) {\n\t\tthis.bufferIndex = bufferIndex;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.lineFeedCnt = lineFeedCnt;\n\t\tthis.length = length;\n\t}\n}\n\nexport class StringBuffer {\n\tbuffer: string;\n\tlineStarts: Uint32Array | Uint16Array | number[];\n\n\tconstructor(buffer: string, lineStarts: Uint32Array | Uint16Array | number[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.lineStarts = lineStarts;\n\t}\n}\n\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot implements ITextSnapshot {\n\tprivate readonly _pieces: Piece[];\n\tprivate _index: number;\n\tprivate readonly _tree: PieceTreeBase;\n\tprivate readonly _BOM: string;\n\n\tconstructor(tree: PieceTreeBase, BOM: string) {\n\t\tthis._pieces = [];\n\t\tthis._tree = tree;\n\t\tthis._BOM = BOM;\n\t\tthis._index = 0;\n\t\tif (tree.root !== SENTINEL) {\n\t\t\ttree.iterate(tree.root, node => {\n\t\t\t\tif (node !== SENTINEL) {\n\t\t\t\t\tthis._pieces.push(node.piece);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\t}\n\n\tread(): string | null {\n\t\tif (this._pieces.length === 0) {\n\t\t\tif (this._index === 0) {\n\t\t\t\tthis._index++;\n\t\t\t\treturn this._BOM;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tif (this._index > this._pieces.length - 1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this._index === 0) {\n\t\t\treturn this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n\t\t}\n\t\treturn this._tree.getPieceContent(this._pieces[this._index++]);\n\t}\n}\n\ninterface CacheEntry {\n\tnode: TreeNode;\n\tnodeStartOffset: number;\n\tnodeStartLineNumber?: number;\n}\n\nclass PieceTreeSearchCache {\n\tprivate readonly _limit: number;\n\tprivate _cache: CacheEntry[];\n\n\tconstructor(limit: number) {\n\t\tthis._limit = limit;\n\t\tthis._cache = [];\n\t}\n\n\tpublic get(offset: number): CacheEntry | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tlet nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n\t\t\t\treturn nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic get2(lineNumber: number): { node: TreeNode, nodeStartOffset: number, nodeStartLineNumber: number } | null {\n\t\tfor (let i = this._cache.length - 1; i >= 0; i--) {\n\t\t\tlet nodePos = this._cache[i];\n\t\t\tif (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n\t\t\t\treturn <{ node: TreeNode, nodeStartOffset: number, nodeStartLineNumber: number }>nodePos;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic set(nodePosition: CacheEntry) {\n\t\tif (this._cache.length >= this._limit) {\n\t\t\tthis._cache.shift();\n\t\t}\n\t\tthis._cache.push(nodePosition);\n\t}\n\n\tpublic valdiate(offset: number) {\n\t\tlet hasInvalidVal = false;\n\t\tlet tmp: Array<CacheEntry | null> = this._cache;\n\t\tfor (let i = 0; i < tmp.length; i++) {\n\t\t\tlet nodePos = tmp[i]!;\n\t\t\tif (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n\t\t\t\ttmp[i] = null;\n\t\t\t\thasInvalidVal = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (hasInvalidVal) {\n\t\t\tlet newArr: CacheEntry[] = [];\n\t\t\tfor (const entry of tmp) {\n\t\t\t\tif (entry !== null) {\n\t\t\t\t\tnewArr.push(entry);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._cache = newArr;\n\t\t}\n\t}\n}\n\nexport class PieceTreeBase {\n\troot: TreeNode;\n\tprotected _buffers: StringBuffer[]; // 0 is change buffer, others are readonly original buffer.\n\tprotected _lineCnt: number;\n\tprotected _length: number;\n\tprotected _EOL: string;\n\tprotected _EOLLength: number;\n\tprotected _EOLNormalized: boolean;\n\tprivate _lastChangeBufferPos: BufferCursor;\n\tprivate _searchCache: PieceTreeSearchCache;\n\tprivate _lastVisitedLine: { lineNumber: number; value: string; };\n\n\tconstructor(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis.create(chunks, eol, eolNormalized);\n\t}\n\n\tcreate(chunks: StringBuffer[], eol: '\\r\\n' | '\\n', eolNormalized: boolean) {\n\t\tthis._buffers = [\n\t\t\tnew StringBuffer('', [0])\n\t\t];\n\t\tthis._lastChangeBufferPos = { line: 0, column: 0 };\n\t\tthis.root = SENTINEL;\n\t\tthis._lineCnt = 1;\n\t\tthis._length = 0;\n\t\tthis._EOL = eol;\n\t\tthis._EOLLength = eol.length;\n\t\tthis._EOLNormalized = eolNormalized;\n\n\t\tlet lastNode: TreeNode | null = null;\n\t\tfor (let i = 0, len = chunks.length; i < len; i++) {\n\t\t\tif (chunks[i].buffer.length > 0) {\n\t\t\t\tif (!chunks[i].lineStarts) {\n\t\t\t\t\tchunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n\t\t\t\t}\n\n\t\t\t\tlet piece = new Piece(\n\t\t\t\t\ti + 1,\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] },\n\t\t\t\t\tchunks[i].lineStarts.length - 1,\n\t\t\t\t\tchunks[i].buffer.length\n\t\t\t\t);\n\t\t\t\tthis._buffers.push(chunks[i]);\n\t\t\t\tlastNode = this.rbInsertRight(lastNode, piece);\n\t\t\t}\n\t\t}\n\n\t\tthis._searchCache = new PieceTreeSearchCache(1);\n\t\tthis._lastVisitedLine = { lineNumber: 0, value: '' };\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tnormalizeEOL(eol: '\\r\\n' | '\\n') {\n\t\tlet averageBufferSize = AverageBufferSize;\n\t\tlet min = averageBufferSize - Math.floor(averageBufferSize / 3);\n\t\tlet max = min * 2;\n\n\t\tlet tempChunk = '';\n\t\tlet tempChunkLen = 0;\n\t\tlet chunks: StringBuffer[] = [];\n\n\t\tthis.iterate(this.root, node => {\n\t\t\tlet str = this.getNodeContent(node);\n\t\t\tlet len = str.length;\n\t\t\tif (tempChunkLen <= min || tempChunkLen + len < max) {\n\t\t\t\ttempChunk += str;\n\t\t\t\ttempChunkLen += len;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// flush anyways\n\t\t\tlet text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t\ttempChunk = str;\n\t\t\ttempChunkLen = len;\n\t\t\treturn true;\n\t\t});\n\n\t\tif (tempChunkLen > 0) {\n\t\t\tlet text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\tchunks.push(new StringBuffer(text, createLineStartsFast(text)));\n\t\t}\n\n\t\tthis.create(chunks, eol, true);\n\t}\n\n\t// #region Buffer API\n\tpublic getEOL(): string {\n\t\treturn this._EOL;\n\t}\n\n\tpublic setEOL(newEOL: '\\r\\n' | '\\n'): void {\n\t\tthis._EOL = newEOL;\n\t\tthis._EOLLength = this._EOL.length;\n\t\tthis.normalizeEOL(newEOL);\n\t}\n\n\tpublic createSnapshot(BOM: string): ITextSnapshot {\n\t\treturn new PieceTreeSnapshot(this, BOM);\n\t}\n\n\tpublic equal(other: PieceTreeBase): boolean {\n\t\tif (this.getLength() !== other.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.getLineCount() !== other.getLineCount()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet offset = 0;\n\t\tlet ret = this.iterate(this.root, node => {\n\t\t\tif (node === SENTINEL) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tlet str = this.getNodeContent(node);\n\t\t\tlet len = str.length;\n\t\t\tlet startPosition = other.nodeAt(offset);\n\t\t\tlet endPosition = other.nodeAt(offset + len);\n\t\t\tlet val = other.getValueInRange2(startPosition, endPosition);\n\n\t\t\treturn str === val;\n\t\t});\n\n\t\treturn ret;\n\t}\n\n\tpublic getOffsetAt(lineNumber: number, column: number): number {\n\t\tlet leftLen = 0; // inorder\n\n\t\tlet x = this.root;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n\t\t\t\tleftLen += x.size_left;\n\t\t\t\t// lineNumber >= 2\n\t\t\t\tlet accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\treturn leftLen += accumualtedValInCurrentIndex + column - 1;\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tleftLen += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn leftLen;\n\t}\n\n\tpublic getPositionAt(offset: number): Position {\n\t\toffset = Math.floor(offset);\n\t\toffset = Math.max(0, offset);\n\n\t\tlet x = this.root;\n\t\tlet lfCnt = 0;\n\t\tlet originalOffset = offset;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left !== 0 && x.size_left >= offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tlet out = this.getIndexOf(x, offset - x.size_left);\n\n\t\t\t\tlfCnt += x.lf_left + out.index;\n\n\t\t\t\tif (out.index === 0) {\n\t\t\t\t\tlet lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tlet column = originalOffset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t}\n\n\t\t\t\treturn new Position(lfCnt + 1, out.remainder + 1);\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n\t\t\t\tif (x.right === SENTINEL) {\n\t\t\t\t\t// last node\n\t\t\t\t\tlet lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\t\t\t\t\tlet column = originalOffset - offset - lineStartOffset;\n\t\t\t\t\treturn new Position(lfCnt + 1, column + 1);\n\t\t\t\t} else {\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn new Position(1, 1);\n\t}\n\n\tpublic getValueInRange(range: Range, eol?: string): string {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\treturn '';\n\t\t}\n\n\t\tlet startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n\t\tlet endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n\n\t\tlet value = this.getValueInRange2(startPosition, endPosition);\n\t\tif (eol) {\n\t\t\tif (eol !== this._EOL || !this._EOLNormalized) {\n\t\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t\t}\n\n\t\t\tif (eol === this.getEOL() && this._EOLNormalized) {\n\t\t\t\tif (eol === '\\r\\n') {\n\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\treturn value.replace(/\\r\\n|\\r|\\n/g, eol);\n\t\t}\n\t\treturn value;\n\t}\n\n\tpublic getValueInRange2(startPosition: NodePosition, endPosition: NodePosition): string {\n\t\tif (startPosition.node === endPosition.node) {\n\t\t\tlet node = startPosition.node;\n\t\t\tlet buffer = this._buffers[node.piece.bufferIndex].buffer;\n\t\t\tlet startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\t\treturn buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n\t\t}\n\n\t\tlet x = startPosition.node;\n\t\tlet buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\tlet ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tlet buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\tif (x === endPosition.node) {\n\t\t\t\tret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this.getContentOfSubTree(this.root).split(/\\r\\n|\\r|\\n/);\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this._length;\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lineCnt;\n\t}\n\n\tpublic getLineContent(lineNumber: number): string {\n\t\tif (this._lastVisitedLine.lineNumber === lineNumber) {\n\t\t\treturn this._lastVisitedLine.value;\n\t\t}\n\n\t\tthis._lastVisitedLine.lineNumber = lineNumber;\n\n\t\tif (lineNumber === this._lineCnt) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n\t\t} else if (this._EOLNormalized) {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n\t\t} else {\n\t\t\tthis._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n\t\t}\n\n\t\treturn this._lastVisitedLine.value;\n\t}\n\n\tpublic getLineCharCode(lineNumber: number, index: number): number {\n\t\tlet nodePos = this.nodeAt2(lineNumber, index + 1);\n\t\tif (nodePos.remainder === nodePos.node.piece.length) {\n\t\t\t// the char we want to fetch is at the head of next node.\n\t\t\tlet matchingNode = nodePos.node.next();\n\t\t\tif (!matchingNode) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlet buffer = this._buffers[matchingNode.piece.bufferIndex];\n\t\t\tlet startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n\t\t\treturn buffer.buffer.charCodeAt(startOffset);\n\t\t} else {\n\t\t\tlet buffer = this._buffers[nodePos.node.piece.bufferIndex];\n\t\t\tlet startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\t\t\tlet targetOffset = startOffset + nodePos.remainder;\n\n\t\t\treturn buffer.buffer.charCodeAt(targetOffset);\n\t\t}\n\t}\n\n\tpublic getLineLength(lineNumber: number): number {\n\t\tif (lineNumber === this.getLineCount()) {\n\t\t\tlet startOffset = this.getOffsetAt(lineNumber, 1);\n\t\t\treturn this.getLength() - startOffset;\n\t\t}\n\t\treturn this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n\t}\n\n\tpublic findMatchesInNode(node: TreeNode, searcher: Searcher, startLineNumber: number, startColumn: number, startCursor: BufferCursor, endCursor: BufferCursor, searchData: SearchData, captureMatches: boolean, limitResultCount: number, resultLen: number, result: FindMatch[]) {\n\t\tlet buffer = this._buffers[node.piece.bufferIndex];\n\t\tlet startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\t\tlet start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n\t\tlet end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(start);\n\t\tlet ret: BufferCursor = { line: 0, column: 0 };\n\n\t\tdo {\n\t\t\tm = searcher.next(buffer.buffer);\n\n\t\t\tif (m) {\n\t\t\t\tif (m.index >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tthis.positionInBuffer(node, m.index - startOffsetInBuffer, ret);\n\t\t\t\tlet lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n\t\t\t\tlet retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n\t\t\t\tlet retEndColumn = retStartColumn + m[0].length;\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n\t\t\t\tif (m.index + m[0].length >= end) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (m);\n\n\t\treturn resultLen;\n\t}\n\n\tpublic findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[] {\n\t\tconst result: FindMatch[] = [];\n\t\tlet resultLen = 0;\n\t\tconst searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n\t\tlet startPostion = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\t\tif (startPostion === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\t\tif (endPosition === null) {\n\t\t\treturn [];\n\t\t}\n\t\tlet start = this.positionInBuffer(startPostion.node, startPostion.remainder);\n\t\tlet end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n\t\tif (startPostion.node === endPosition.node) {\n\t\t\tthis.findMatchesInNode(startPostion.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startLineNumber = searchRange.startLineNumber;\n\n\t\tlet currentNode = startPostion.node;\n\t\twhile (currentNode !== endPosition.node) {\n\t\t\tlet lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n\t\t\tif (lineBreakCnt >= 1) {\n\t\t\t\t// last line break position\n\t\t\t\tlet lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n\t\t\t\tlet startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n\t\t\t\tlet nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\t\t\t\tlet startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\t\t\tresultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tstartLineNumber += lineBreakCnt;\n\t\t\t}\n\n\t\t\tlet startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\t// search for the remaining content\n\t\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\n\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tstartLineNumber++;\n\t\t\tstartPostion = this.nodeAt2(startLineNumber, 1);\n\t\t\tcurrentNode = startPostion.node;\n\t\t\tstart = this.positionInBuffer(startPostion.node, startPostion.remainder);\n\t\t}\n\n\t\tif (startLineNumber === searchRange.endLineNumber) {\n\t\t\tlet startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\t\t\tconst text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n\t\t\tresultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n\t\t\treturn result;\n\t\t}\n\n\t\tlet startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\t\tresultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n\t\treturn result;\n\t}\n\n\tprivate _findMatchesInLine(searchData: SearchData, searcher: Searcher, text: string, lineNumber: number, deltaOffset: number, resultLen: number, result: FindMatch[], captureMatches: boolean, limitResultCount: number): number {\n\t\tconst wordSeparators = searchData.wordSeparators;\n\t\tif (!captureMatches && searchData.simpleSearch) {\n\t\t\tconst searchString = searchData.simpleSearch;\n\t\t\tconst searchStringLen = searchString.length;\n\t\t\tconst textLength = text.length;\n\n\t\t\tlet lastMatchIndex = -searchStringLen;\n\t\t\twhile ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n\t\t\t\tif (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n\t\t\t\t\tresult[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\t\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\t\treturn resultLen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn resultLen;\n\t\t}\n\n\t\tlet m: RegExpExecArray | null;\n\t\t// Reset regex to search from the beginning\n\t\tsearcher.reset(0);\n\t\tdo {\n\t\t\tm = searcher.next(text);\n\t\t\tif (m) {\n\t\t\t\tresult[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\t\t\t\tif (resultLen >= limitResultCount) {\n\t\t\t\t\treturn resultLen;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (m);\n\t\treturn resultLen;\n\t}\n\n\t// #endregion\n\n\t// #region Piece Table\n\tinsert(offset: number, value: string, eolNormalized: boolean = false): void {\n\t\tthis._EOLNormalized = this._EOLNormalized && eolNormalized;\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (this.root !== SENTINEL) {\n\t\t\tlet { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n\t\t\tlet piece = node.piece;\n\t\t\tlet bufferIndex = piece.bufferIndex;\n\t\t\tlet insertPosInBuffer = this.positionInBuffer(node, remainder);\n\t\t\tif (node.piece.bufferIndex === 0 &&\n\t\t\t\tpiece.end.line === this._lastChangeBufferPos.line &&\n\t\t\t\tpiece.end.column === this._lastChangeBufferPos.column &&\n\t\t\t\t(nodeStartOffset + piece.length === offset) &&\n\t\t\t\tvalue.length < AverageBufferSize\n\t\t\t) {\n\t\t\t\t// changed buffer\n\t\t\t\tthis.appendToNode(node, value);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nodeStartOffset === offset) {\n\t\t\t\tthis.insertContentToNodeLeft(value, node);\n\t\t\t\tthis._searchCache.valdiate(offset);\n\t\t\t} else if (nodeStartOffset + node.piece.length > offset) {\n\t\t\t\t// we are inserting into the middle of a node.\n\t\t\t\tlet nodesToDel: TreeNode[] = [];\n\t\t\t\tlet newRightPiece = new Piece(\n\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\tinsertPosInBuffer,\n\t\t\t\t\tpiece.end,\n\t\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end),\n\t\t\t\t\tthis.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer)\n\t\t\t\t);\n\n\t\t\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\t\t\tlet headOfRight = this.nodeCharCodeAt(node, remainder);\n\n\t\t\t\t\tif (headOfRight === 10 /** \\n */) {\n\t\t\t\t\t\tlet newStart: BufferCursor = { line: newRightPiece.start.line + 1, column: 0 };\n\t\t\t\t\t\tnewRightPiece = new Piece(\n\t\t\t\t\t\t\tnewRightPiece.bufferIndex,\n\t\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\t\tnewRightPiece.end,\n\t\t\t\t\t\t\tthis.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end),\n\t\t\t\t\t\t\tnewRightPiece.length - 1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tvalue += '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// reuse node for content before insertion point.\n\t\t\t\tif (this.shouldCheckCRLF() && this.startWithLF(value)) {\n\t\t\t\t\tlet tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\t\t\t\t\tif (tailOfLeft === 13 /** \\r */) {\n\t\t\t\t\t\tlet previousPos = this.positionInBuffer(node, remainder - 1);\n\t\t\t\t\t\tthis.deleteNodeTail(node, previousPos);\n\t\t\t\t\t\tvalue = '\\r' + value;\n\n\t\t\t\t\t\tif (node.piece.length === 0) {\n\t\t\t\t\t\t\tnodesToDel.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deleteNodeTail(node, insertPosInBuffer);\n\t\t\t\t}\n\n\t\t\t\tlet newPieces = this.createNewPieces(value);\n\t\t\t\tif (newRightPiece.length > 0) {\n\t\t\t\t\tthis.rbInsertRight(node, newRightPiece);\n\t\t\t\t}\n\n\t\t\t\tlet tmpNode = node;\n\t\t\t\tfor (let k = 0; k < newPieces.length; k++) {\n\t\t\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t\t\t}\n\t\t\t\tthis.deleteNodes(nodesToDel);\n\t\t\t} else {\n\t\t\t\tthis.insertContentToNodeRight(value, node);\n\t\t\t}\n\t\t} else {\n\t\t\t// insert new node\n\t\t\tlet pieces = this.createNewPieces(value);\n\t\t\tlet node = this.rbInsertLeft(null, pieces[0]);\n\n\t\t\tfor (let k = 1; k < pieces.length; k++) {\n\t\t\t\tnode = this.rbInsertRight(node, pieces[k]);\n\t\t\t}\n\t\t}\n\n\t\t// todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tdelete(offset: number, cnt: number): void {\n\t\tthis._lastVisitedLine.lineNumber = 0;\n\t\tthis._lastVisitedLine.value = '';\n\n\t\tif (cnt <= 0 || this.root === SENTINEL) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet startPosition = this.nodeAt(offset);\n\t\tlet endPosition = this.nodeAt(offset + cnt);\n\t\tlet startNode = startPosition.node;\n\t\tlet endNode = endPosition.node;\n\n\t\tif (startNode === endNode) {\n\t\t\tlet startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\t\tlet endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n\t\t\tif (startPosition.nodeStartOffset === offset) {\n\t\t\t\tif (cnt === startNode.piece.length) { // delete node\n\t\t\t\t\tlet next = startNode.next();\n\t\t\t\t\trbDelete(this, startNode);\n\t\t\t\t\tthis.validateCRLFWithPrevNode(next);\n\t\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.deleteNodeHead(startNode, endSplitPosInBuffer);\n\t\t\t\tthis._searchCache.valdiate(offset);\n\t\t\t\tthis.validateCRLFWithPrevNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n\t\t\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\t\t\tthis.validateCRLFWithNextNode(startNode);\n\t\t\t\tthis.computeBufferMetadata();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// delete content in the middle, this node will be splitted to nodes\n\t\t\tthis.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n\t\t\tthis.computeBufferMetadata();\n\t\t\treturn;\n\t\t}\n\n\t\tlet nodesToDel: TreeNode[] = [];\n\n\t\tlet startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\t\tthis.deleteNodeTail(startNode, startSplitPosInBuffer);\n\t\tthis._searchCache.valdiate(offset);\n\t\tif (startNode.piece.length === 0) {\n\t\t\tnodesToDel.push(startNode);\n\t\t}\n\n\t\t// update last touched node\n\t\tlet endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n\t\tthis.deleteNodeHead(endNode, endSplitPosInBuffer);\n\t\tif (endNode.piece.length === 0) {\n\t\t\tnodesToDel.push(endNode);\n\t\t}\n\n\t\t// delete nodes in between\n\t\tlet secondNode = startNode.next();\n\t\tfor (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n\t\t\tnodesToDel.push(node);\n\t\t}\n\n\t\tlet prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n\t\tthis.deleteNodes(nodesToDel);\n\t\tthis.validateCRLFWithNextNode(prev);\n\t\tthis.computeBufferMetadata();\n\t}\n\n\tinsertContentToNodeLeft(value: string, node: TreeNode) {\n\t\t// we are inserting content to the beginning of node\n\t\tlet nodesToDel: TreeNode[] = [];\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n\t\t\t// move `\\n` to new node.\n\n\t\t\tlet piece = node.piece;\n\t\t\tlet newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\tlet nPiece = new Piece(\n\t\t\t\tpiece.bufferIndex,\n\t\t\t\tnewStart,\n\t\t\t\tpiece.end,\n\t\t\t\tthis.getLineFeedCnt(piece.bufferIndex, newStart, piece.end),\n\t\t\t\tpiece.length - 1\n\t\t\t);\n\n\t\t\tnode.piece = nPiece;\n\n\t\t\tvalue += '\\n';\n\t\t\tupdateTreeMetadata(this, node, -1, -1);\n\n\t\t\tif (node.piece.length === 0) {\n\t\t\t\tnodesToDel.push(node);\n\t\t\t}\n\t\t}\n\n\t\tlet newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\t\tfor (let k = newPieces.length - 2; k >= 0; k--) {\n\t\t\tnewNode = this.rbInsertLeft(newNode, newPieces[k]);\n\t\t}\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t\tthis.deleteNodes(nodesToDel);\n\t}\n\n\tinsertContentToNodeRight(value: string, node: TreeNode) {\n\t\t// we are inserting to the right of this node.\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\t// move \\n to the new node.\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tlet newPieces = this.createNewPieces(value);\n\t\tlet newNode = this.rbInsertRight(node, newPieces[0]);\n\t\tlet tmpNode = newNode;\n\n\t\tfor (let k = 1; k < newPieces.length; k++) {\n\t\t\ttmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n\t\t}\n\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tpositionInBuffer(node: TreeNode, remainder: number): BufferCursor;\n\tpositionInBuffer(node: TreeNode, remainder: number, ret: BufferCursor): null;\n\tpositionInBuffer(node: TreeNode, remainder: number, ret?: BufferCursor): BufferCursor | null {\n\t\tlet piece = node.piece;\n\t\tlet bufferIndex = node.piece.bufferIndex;\n\t\tlet lineStarts = this._buffers[bufferIndex].lineStarts;\n\n\t\tlet startOffset = lineStarts[piece.start.line] + piece.start.column;\n\n\t\tlet offset = startOffset + remainder;\n\n\t\t// binary search offset between startOffset and endOffset\n\t\tlet low = piece.start.line;\n\t\tlet high = piece.end.line;\n\n\t\tlet mid: number = 0;\n\t\tlet midStop: number = 0;\n\t\tlet midStart: number = 0;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ((high - low) / 2) | 0;\n\t\t\tmidStart = lineStarts[mid];\n\n\t\t\tif (mid === high) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmidStop = lineStarts[mid + 1];\n\n\t\t\tif (offset < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (offset >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret.line = mid;\n\t\t\tret.column = offset - midStart;\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\tline: mid,\n\t\t\tcolumn: offset - midStart\n\t\t};\n\t}\n\n\tgetLineFeedCnt(bufferIndex: number, start: BufferCursor, end: BufferCursor): number {\n\t\t// we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n\t\t// now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n\t\tif (end.column === 0) {\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tlet lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\tif (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n\t\t\treturn end.line - start.line;\n\t\t}\n\n\t\tlet nextLineStartOffset = lineStarts[end.line + 1];\n\t\tlet endOffset = lineStarts[end.line] + end.column;\n\t\tif (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n\t\t\treturn end.line - start.line;\n\t\t}\n\t\t// endOffset + 1 === nextLineStartOffset\n\t\t// character at endOffset is \\n, so we check the character before first\n\t\t// if character at endOffset is \\r, end.column is 0 and we can't get here.\n\t\tlet previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\t\tlet buffer = this._buffers[bufferIndex].buffer;\n\n\t\tif (buffer.charCodeAt(previousCharOffset) === 13) {\n\t\t\treturn end.line - start.line + 1;\n\t\t} else {\n\t\t\treturn end.line - start.line;\n\t\t}\n\t}\n\n\toffsetInBuffer(bufferIndex: number, cursor: BufferCursor): number {\n\t\tlet lineStarts = this._buffers[bufferIndex].lineStarts;\n\t\treturn lineStarts[cursor.line] + cursor.column;\n\t}\n\n\tdeleteNodes(nodes: TreeNode[]): void {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\trbDelete(this, nodes[i]);\n\t\t}\n\t}\n\n\tcreateNewPieces(text: string): Piece[] {\n\t\tif (text.length > AverageBufferSize) {\n\t\t\t// the content is large, operations like substring, charCode becomes slow\n\t\t\t// so here we split it into smaller chunks, just like what we did for CR/LF normalization\n\t\t\tlet newPieces: Piece[] = [];\n\t\t\twhile (text.length > AverageBufferSize) {\n\t\t\t\tconst lastChar = text.charCodeAt(AverageBufferSize - 1);\n\t\t\t\tlet splitText;\n\t\t\t\tif (lastChar === CharCode.CarriageReturn || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n\t\t\t\t\t// last character is \\r or a high surrogate => keep it back\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize - 1);\n\t\t\t\t\ttext = text.substring(AverageBufferSize - 1);\n\t\t\t\t} else {\n\t\t\t\t\tsplitText = text.substring(0, AverageBufferSize);\n\t\t\t\t\ttext = text.substring(AverageBufferSize);\n\t\t\t\t}\n\n\t\t\t\tlet lineStarts = createLineStartsFast(splitText);\n\t\t\t\tnewPieces.push(new Piece(\n\t\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t\t{ line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\t\tlineStarts.length - 1,\n\t\t\t\t\tsplitText.length\n\t\t\t\t));\n\t\t\t\tthis._buffers.push(new StringBuffer(splitText, lineStarts));\n\t\t\t}\n\n\t\t\tlet lineStarts = createLineStartsFast(text);\n\t\t\tnewPieces.push(new Piece(\n\t\t\t\tthis._buffers.length, /* buffer index */\n\t\t\t\t{ line: 0, column: 0 },\n\t\t\t\t{ line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] },\n\t\t\t\tlineStarts.length - 1,\n\t\t\t\ttext.length\n\t\t\t));\n\t\t\tthis._buffers.push(new StringBuffer(text, lineStarts));\n\n\t\t\treturn newPieces;\n\t\t}\n\n\t\tlet startOffset = this._buffers[0].buffer.length;\n\t\tconst lineStarts = createLineStartsFast(text, false);\n\n\t\tlet start = this._lastChangeBufferPos;\n\t\tif (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n\t\t\t&& startOffset !== 0\n\t\t\t&& this.startWithLF(text)\n\t\t\t&& this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n\t\t) {\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n\t\t\tstart = this._lastChangeBufferPos;\n\n\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\tlineStarts[i] += startOffset + 1;\n\t\t\t}\n\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += '_' + text;\n\t\t\tstartOffset += 1;\n\t\t} else {\n\t\t\tif (startOffset !== 0) {\n\t\t\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\t\t\tlineStarts[i] += startOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\t\tthis._buffers[0].buffer += text;\n\t\t}\n\n\t\tconst endOffset = this._buffers[0].buffer.length;\n\t\tlet endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tlet endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n\t\tlet endPos = { line: endIndex, column: endColumn };\n\t\tlet newPiece = new Piece(\n\t\t\t0, /** todo@peng */\n\t\t\tstart,\n\t\t\tendPos,\n\t\t\tthis.getLineFeedCnt(0, start, endPos),\n\t\t\tendOffset - startOffset\n\t\t);\n\t\tthis._lastChangeBufferPos = endPos;\n\t\treturn [newPiece];\n\t}\n\n\tgetLinesRawContent(): string {\n\t\treturn this.getContentOfSubTree(this.root);\n\t}\n\n\tgetLineRawContent(lineNumber: number, endOffset: number = 0): string {\n\t\tlet x = this.root;\n\n\t\tlet ret = '';\n\t\tlet cache = this._searchCache.get2(lineNumber);\n\t\tif (cache) {\n\t\t\tx = cache.node;\n\t\t\tlet prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n\t\t\tlet buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\tif (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n\t\t\t\tret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n\t\t\t} else {\n\t\t\t\tlet accumualtedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n\t\t\t\treturn buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n\t\t\t}\n\t\t} else {\n\t\t\tlet nodeStartOffset = 0;\n\t\t\tconst originalLineNumber = lineNumber;\n\t\t\twhile (x !== SENTINEL) {\n\t\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\t\tx = x.left;\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\t\tlet prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tlet accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\t\tlet buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\t\tthis._searchCache.set({\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tnodeStartOffset,\n\t\t\t\t\t\tnodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n\t\t\t\t\t});\n\n\t\t\t\t\treturn buffer.substring(startOffset + prevAccumualtedValue, startOffset + accumualtedValue - endOffset);\n\t\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\t\tlet prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\t\tlet buffer = this._buffers[x.piece.bufferIndex].buffer;\n\t\t\t\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\t\tret = buffer.substring(startOffset + prevAccumualtedValue, startOffset + x.piece.length);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\t\tx = x.right;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains end column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\t\t\tlet buffer = this._buffers[x.piece.bufferIndex].buffer;\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tlet accumualtedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n\t\t\t\tret += buffer.substring(startOffset, startOffset + accumualtedValue - endOffset);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tlet startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\t\t\t\tret += buffer.substr(startOffset, x.piece.length);\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tcomputeBufferMetadata() {\n\t\tlet x = this.root;\n\n\t\tlet lfCnt = 1;\n\t\tlet len = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tlfCnt += x.lf_left + x.piece.lineFeedCnt;\n\t\t\tlen += x.size_left + x.piece.length;\n\t\t\tx = x.right;\n\t\t}\n\n\t\tthis._lineCnt = lfCnt;\n\t\tthis._length = len;\n\t\tthis._searchCache.valdiate(this._length);\n\t}\n\n\t// #region node operations\n\tgetIndexOf(node: TreeNode, accumulatedValue: number): { index: number, remainder: number } {\n\t\tlet piece = node.piece;\n\t\tlet pos = this.positionInBuffer(node, accumulatedValue);\n\t\tlet lineCnt = pos.line - piece.start.line;\n\n\t\tif (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n\t\t\t// we are checking the end of this node, so a CRLF check is necessary.\n\t\t\tlet realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\t\t\tif (realLineCnt !== lineCnt) {\n\t\t\t\t// aha yes, CRLF\n\t\t\t\treturn { index: realLineCnt, remainder: 0 };\n\t\t\t}\n\t\t}\n\n\t\treturn { index: lineCnt, remainder: pos.column };\n\t}\n\n\tgetAccumulatedValue(node: TreeNode, index: number) {\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet piece = node.piece;\n\t\tlet lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tlet expectedLineStartIndex = piece.start.line + index + 1;\n\t\tif (expectedLineStartIndex > piece.end.line) {\n\t\t\treturn lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n\t\t} else {\n\t\t\treturn lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n\t\t}\n\t}\n\n\tdeleteNodeTail(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\n\t\tconst newEnd = pos;\n\t\tconst newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = newEndOffset - originalEndOffset;\n\t\tconst newLength = piece.length + size_delta;\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tdeleteNodeHead(node: TreeNode, pos: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalLFCnt = piece.lineFeedCnt;\n\t\tconst originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\n\t\tconst newStart = pos;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\tconst newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n\t\tconst lf_delta = newLineFeedCnt - originalLFCnt;\n\t\tconst size_delta = originalStartOffset - newStartOffset;\n\t\tconst newLength = piece.length + size_delta;\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tpiece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, size_delta, lf_delta);\n\t}\n\n\tshrinkNode(node: TreeNode, start: BufferCursor, end: BufferCursor) {\n\t\tconst piece = node.piece;\n\t\tconst originalStartPos = piece.start;\n\t\tconst originalEndPos = piece.end;\n\n\t\t// old piece, originalStartPos, start\n\t\tconst oldLength = piece.length;\n\t\tconst oldLFCnt = piece.lineFeedCnt;\n\t\tconst newEnd = start;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n\t\tconst newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n\n\t\tnode.piece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tpiece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n\n\t\t// new right piece, end, originalEndPos\n\t\tlet newPiece = new Piece(\n\t\t\tpiece.bufferIndex,\n\t\t\tend,\n\t\t\toriginalEndPos,\n\t\t\tthis.getLineFeedCnt(piece.bufferIndex, end, originalEndPos),\n\t\t\tthis.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end)\n\t\t);\n\n\t\tlet newNode = this.rbInsertRight(node, newPiece);\n\t\tthis.validateCRLFWithPrevNode(newNode);\n\t}\n\n\tappendToNode(node: TreeNode, value: string): void {\n\t\tif (this.adjustCarriageReturnFromNext(value, node)) {\n\t\t\tvalue += '\\n';\n\t\t}\n\n\t\tconst hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n\t\tconst startOffset = this._buffers[0].buffer.length;\n\t\tthis._buffers[0].buffer += value;\n\t\tconst lineStarts = createLineStartsFast(value, false);\n\t\tfor (let i = 0; i < lineStarts.length; i++) {\n\t\t\tlineStarts[i] += startOffset;\n\t\t}\n\t\tif (hitCRLF) {\n\t\t\tlet prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\t\t\t(<number[]>this._buffers[0].lineStarts).pop();\n\t\t\t// _lastChangeBufferPos is already wrong\n\t\t\tthis._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n\t\t}\n\n\t\tthis._buffers[0].lineStarts = (<number[]>this._buffers[0].lineStarts).concat(<number[]>lineStarts.slice(1));\n\t\tconst endIndex = this._buffers[0].lineStarts.length - 1;\n\t\tconst endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n\t\tconst newEnd = { line: endIndex, column: endColumn };\n\t\tconst newLength = node.piece.length + value.length;\n\t\tconst oldLineFeedCnt = node.piece.lineFeedCnt;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n\t\tconst lf_delta = newLineFeedCnt - oldLineFeedCnt;\n\n\t\tnode.piece = new Piece(\n\t\t\tnode.piece.bufferIndex,\n\t\t\tnode.piece.start,\n\t\t\tnewEnd,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tthis._lastChangeBufferPos = newEnd;\n\t\tupdateTreeMetadata(this, node, value.length, lf_delta);\n\t}\n\n\tnodeAt(offset: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet cache = this._searchCache.get(offset);\n\t\tif (cache) {\n\t\t\treturn {\n\t\t\t\tnode: cache.node,\n\t\t\t\tnodeStartOffset: cache.nodeStartOffset,\n\t\t\t\tremainder: offset - cache.nodeStartOffset\n\t\t\t};\n\t\t}\n\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.size_left > offset) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.size_left + x.piece.length >= offset) {\n\t\t\t\tnodeStartOffset += x.size_left;\n\t\t\t\tlet ret = {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: offset - x.size_left,\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t\tthis._searchCache.set(ret);\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\toffset -= x.size_left + x.piece.length;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tnodeAt2(lineNumber: number, column: number): NodePosition {\n\t\tlet x = this.root;\n\t\tlet nodeStartOffset = 0;\n\n\t\twhile (x !== SENTINEL) {\n\t\t\tif (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n\t\t\t\tx = x.left;\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n\t\t\t\tlet prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tlet accumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\t\t\t\tnodeStartOffset += x.size_left;\n\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(prevAccumualtedValue + column - 1, accumualtedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n\t\t\t\tlet prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\t\t\t\tif (prevAccumualtedValue + column - 1 <= x.piece.length) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: prevAccumualtedValue + column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length - prevAccumualtedValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlineNumber -= x.lf_left + x.piece.lineFeedCnt;\n\t\t\t\tnodeStartOffset += x.size_left + x.piece.length;\n\t\t\t\tx = x.right;\n\t\t\t}\n\t\t}\n\n\t\t// search in order, to find the node contains position.column\n\t\tx = x.next();\n\t\twhile (x !== SENTINEL) {\n\n\t\t\tif (x.piece.lineFeedCnt > 0) {\n\t\t\t\tlet accumualtedValue = this.getAccumulatedValue(x, 0);\n\t\t\t\tlet nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\treturn {\n\t\t\t\t\tnode: x,\n\t\t\t\t\tremainder: Math.min(column - 1, accumualtedValue),\n\t\t\t\t\tnodeStartOffset\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (x.piece.length >= column - 1) {\n\t\t\t\t\tlet nodeStartOffset = this.offsetOfNode(x);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tnode: x,\n\t\t\t\t\t\tremainder: column - 1,\n\t\t\t\t\t\tnodeStartOffset\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcolumn -= x.piece.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = x.next();\n\t\t}\n\n\t\treturn null!;\n\t}\n\n\tnodeCharCodeAt(node: TreeNode, offset: number): number {\n\t\tif (node.piece.lineFeedCnt < 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet buffer = this._buffers[node.piece.bufferIndex];\n\t\tlet newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n\t\treturn buffer.buffer.charCodeAt(newOffset);\n\t}\n\n\toffsetOfNode(node: TreeNode): number {\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet pos = node.size_left;\n\t\twhile (node !== this.root) {\n\t\t\tif (node.parent.right === node) {\n\t\t\t\tpos += node.parent.size_left + node.parent.piece.length;\n\t\t\t}\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t// #endregion\n\n\t// #region CRLF\n\tshouldCheckCRLF() {\n\t\treturn !(this._EOLNormalized && this._EOL === '\\n');\n\t}\n\n\tstartWithLF(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(0) === 10;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet piece = val.piece;\n\t\tlet lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n\t\tlet line = piece.start.line;\n\t\tlet startOffset = lineStarts[line] + piece.start.column;\n\t\tif (line === lineStarts.length - 1) {\n\t\t\t// last line, so there is no line feed at the end of this line\n\t\t\treturn false;\n\t\t}\n\t\tlet nextLineOffset = lineStarts[line + 1];\n\t\tif (nextLineOffset > startOffset + 1) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n\t}\n\n\tendWithCR(val: string | TreeNode): boolean {\n\t\tif (typeof val === 'string') {\n\t\t\treturn val.charCodeAt(val.length - 1) === 13;\n\t\t}\n\n\t\tif (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n\t}\n\n\tvalidateCRLFWithPrevNode(nextNode: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n\t\t\tlet node = nextNode.prev();\n\t\t\tif (this.endWithCR(node)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tvalidateCRLFWithNextNode(node: TreeNode) {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(node)) {\n\t\t\tlet nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\tthis.fixCRLF(node, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tfixCRLF(prev: TreeNode, next: TreeNode) {\n\t\tlet nodesToDel: TreeNode[] = [];\n\t\t// update node\n\t\tlet lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n\t\tlet newEnd: BufferCursor;\n\t\tif (prev.piece.end.column === 0) {\n\t\t\t// it means, last line ends with \\r, not \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n\t\t} else {\n\t\t\t// \\r\\n\n\t\t\tnewEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n\t\t}\n\n\t\tconst prevNewLength = prev.piece.length - 1;\n\t\tconst prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n\t\tprev.piece = new Piece(\n\t\t\tprev.piece.bufferIndex,\n\t\t\tprev.piece.start,\n\t\t\tnewEnd,\n\t\t\tprevNewLFCnt,\n\t\t\tprevNewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, prev, - 1, -1);\n\t\tif (prev.piece.length === 0) {\n\t\t\tnodesToDel.push(prev);\n\t\t}\n\n\t\t// update nextNode\n\t\tlet newStart: BufferCursor = { line: next.piece.start.line + 1, column: 0 };\n\t\tconst newLength = next.piece.length - 1;\n\t\tconst newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n\t\tnext.piece = new Piece(\n\t\t\tnext.piece.bufferIndex,\n\t\t\tnewStart,\n\t\t\tnext.piece.end,\n\t\t\tnewLineFeedCnt,\n\t\t\tnewLength\n\t\t);\n\n\t\tupdateTreeMetadata(this, next, - 1, -1);\n\t\tif (next.piece.length === 0) {\n\t\t\tnodesToDel.push(next);\n\t\t}\n\n\t\t// create new piece which contains \\r\\n\n\t\tlet pieces = this.createNewPieces('\\r\\n');\n\t\tthis.rbInsertRight(prev, pieces[0]);\n\t\t// delete empty nodes\n\n\t\tfor (let i = 0; i < nodesToDel.length; i++) {\n\t\t\trbDelete(this, nodesToDel[i]);\n\t\t}\n\t}\n\n\tadjustCarriageReturnFromNext(value: string, node: TreeNode): boolean {\n\t\tif (this.shouldCheckCRLF() && this.endWithCR(value)) {\n\t\t\tlet nextNode = node.next();\n\t\t\tif (this.startWithLF(nextNode)) {\n\t\t\t\t// move `\\n` forward\n\t\t\t\tvalue += '\\n';\n\n\t\t\t\tif (nextNode.piece.length === 1) {\n\t\t\t\t\trbDelete(this, nextNode);\n\t\t\t\t} else {\n\n\t\t\t\t\tconst piece = nextNode.piece;\n\t\t\t\t\tconst newStart: BufferCursor = { line: piece.start.line + 1, column: 0 };\n\t\t\t\t\tconst newLength = piece.length - 1;\n\t\t\t\t\tconst newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n\t\t\t\t\tnextNode.piece = new Piece(\n\t\t\t\t\t\tpiece.bufferIndex,\n\t\t\t\t\t\tnewStart,\n\t\t\t\t\t\tpiece.end,\n\t\t\t\t\t\tnewLineFeedCnt,\n\t\t\t\t\t\tnewLength\n\t\t\t\t\t);\n\n\t\t\t\t\tupdateTreeMetadata(this, nextNode, -1, -1);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// #endregion\n\n\t// #endregion\n\n\t// #region Tree operations\n\titerate(node: TreeNode, callback: (node: TreeNode) => boolean): boolean {\n\t\tif (node === SENTINEL) {\n\t\t\treturn callback(SENTINEL);\n\t\t}\n\n\t\tlet leftRet = this.iterate(node.left, callback);\n\t\tif (!leftRet) {\n\t\t\treturn leftRet;\n\t\t}\n\n\t\treturn callback(node) && this.iterate(node.right, callback);\n\t}\n\n\tgetNodeContent(node: TreeNode) {\n\t\tif (node === SENTINEL) {\n\t\t\treturn '';\n\t\t}\n\t\tlet buffer = this._buffers[node.piece.bufferIndex];\n\t\tlet currentContent;\n\t\tlet piece = node.piece;\n\t\tlet startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tlet endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tcurrentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\tgetPieceContent(piece: Piece) {\n\t\tlet buffer = this._buffers[piece.bufferIndex];\n\t\tlet startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n\t\tlet endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n\t\tlet currentContent = buffer.buffer.substring(startOffset, endOffset);\n\t\treturn currentContent;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b    <----   a    b\n\t *                         /\n\t *                        z\n\t */\n\trbInsertRight(node: TreeNode | null, p: Piece): TreeNode {\n\t\tlet z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tlet x = this.root;\n\t\tif (x === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.right === SENTINEL) {\n\t\t\tnode!.right = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tlet nextNode = leftest(node!.right);\n\t\t\tnextNode.left = z;\n\t\t\tz.parent = nextNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\t/**\n\t *      node              node\n\t *     /  \\              /  \\\n\t *    a   b     ---->   a    b\n\t *                       \\\n\t *                        z\n\t */\n\trbInsertLeft(node: TreeNode | null, p: Piece): TreeNode {\n\t\tlet z = new TreeNode(p, NodeColor.Red);\n\t\tz.left = SENTINEL;\n\t\tz.right = SENTINEL;\n\t\tz.parent = SENTINEL;\n\t\tz.size_left = 0;\n\t\tz.lf_left = 0;\n\n\t\tif (this.root === SENTINEL) {\n\t\t\tthis.root = z;\n\t\t\tz.color = NodeColor.Black;\n\t\t} else if (node!.left === SENTINEL) {\n\t\t\tnode!.left = z;\n\t\t\tz.parent = node!;\n\t\t} else {\n\t\t\tlet prevNode = righttest(node!.left); // a\n\t\t\tprevNode.right = z;\n\t\t\tz.parent = prevNode;\n\t\t}\n\n\t\tfixInsert(this, z);\n\t\treturn z;\n\t}\n\n\tgetContentOfSubTree(node: TreeNode): string {\n\t\tlet str = '';\n\n\t\tthis.iterate(node, node => {\n\t\t\tstr += this.getNodeContent(node);\n\t\t\treturn true;\n\t\t});\n\n\t\treturn str;\n\t}\n\t// #endregion\n}\n"]}]}