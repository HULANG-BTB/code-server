{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/filters.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/filters.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar map_1 = require(\"vs/base/common/map\");\nvar strings = require(\"vs/base/common/strings\");\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nfunction or() {\n    var filter = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        filter[_i] = arguments[_i];\n    }\n    return function (word, wordToMatchAgainst) {\n        for (var i = 0, len = filter.length; i < len; i++) {\n            var match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\nexports.or = or;\n// Prefix\nexports.matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexports.matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    var matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\nfunction matchesContiguousSubString(word, wordToMatchAgainst) {\n    var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\nexports.matchesContiguousSubString = matchesContiguousSubString;\n// Substring\nfunction matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nexports.matchesSubString = matchesSubString;\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            var result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return charCode_1.CharCode.a <= code && code <= charCode_1.CharCode.z;\n}\nfunction isUpper(code) {\n    return charCode_1.CharCode.A <= code && code <= charCode_1.CharCode.Z;\n}\nexports.isUpper = isUpper;\nfunction isNumber(code) {\n    return charCode_1.CharCode.Digit0 <= code && code <= charCode_1.CharCode.Digit9;\n}\nfunction isWhitespace(code) {\n    return (code === charCode_1.CharCode.Space\n        || code === charCode_1.CharCode.Tab\n        || code === charCode_1.CharCode.LineFeed\n        || code === charCode_1.CharCode.CarriageReturn);\n}\nvar wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\n    .split('')\n    .forEach(function (s) { return wordSeparators.add(s.charCodeAt(0)); });\nfunction isWordSeparator(code) {\n    return wordSeparators.has(code);\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (var i = start; i < camelCaseWord.length; i++) {\n        var c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        var result = null;\n        var nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (var i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    var upperPercent = upper / word.length;\n    var lowerPercent = lower / word.length;\n    var alphaPercent = alpha / word.length;\n    var numericPercent = numeric / word.length;\n    return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    var upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (var i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nfunction matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        return null;\n    }\n    var analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    var result = null;\n    var i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\nexports.matchesCamelCase = matchesCamelCase;\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nfunction matchesWords(word, target, contiguous) {\n    if (contiguous === void 0) { contiguous = false; }\n    if (!target || target.length === 0) {\n        return null;\n    }\n    var result = null;\n    var i = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n        i = nextWord(target, i + 1);\n    }\n    return result;\n}\nexports.matchesWords = matchesWords;\nfunction _matchesWords(word, target, i, j, contiguous) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === target.length) {\n        return null;\n    }\n    else if (word[i] !== target[j]) {\n        return null;\n    }\n    else {\n        var result = null;\n        var nextWordIndex = j + 1;\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n        if (!contiguous) {\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n                nextWordIndex++;\n            }\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction nextWord(word, start) {\n    for (var i = start; i < word.length; i++) {\n        var c = word.charCodeAt(i);\n        if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1))) ||\n            isWordSeparator(c) || (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nvar fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nvar fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);\nvar fuzzyRegExpCache = new map_1.LRUCache(10000); // bounded to 10000 elements\nfunction matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\n    if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    var regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    var match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexports.matchesFuzzy = matchesFuzzy;\n/**\n * Match pattern againt word in a fuzzy way. As in IntelliSense and faster and more\n * powerfull than `matchesFuzzy`\n */\nfunction matchesFuzzy2(pattern, word) {\n    var score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n    return score ? createMatches(score) : null;\n}\nexports.matchesFuzzy2 = matchesFuzzy2;\nfunction anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n    var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n    if (result) {\n        return result;\n    }\n    var matches = 0;\n    var score = 0;\n    var idx = _wordPos;\n    for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n        var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n        if (wordPos >= 0) {\n            score += 1;\n            matches += Math.pow(2, wordPos);\n            idx = wordPos + 1;\n        }\n    }\n    return [score, matches, _wordPos];\n}\nexports.anyScore = anyScore;\n//#region --- fuzzyScore ---\nfunction createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    var matches = score[1].toString(2);\n    var wordStart = score[2];\n    var res = [];\n    for (var pos = wordStart; pos < _maxLen; pos++) {\n        if (matches[matches.length - (pos + 1)] === '1') {\n            var last = res[res.length - 1];\n            if (last && last.end === pos) {\n                last.end = pos + 1;\n            }\n            else {\n                res.push({ start: pos, end: pos + 1 });\n            }\n        }\n    }\n    return res;\n}\nexports.createMatches = createMatches;\nvar _maxLen = 53;\nfunction initTable() {\n    var table = [];\n    var row = [0];\n    for (var i = 1; i <= _maxLen; i++) {\n        row.push(-i);\n    }\n    for (var i = 0; i <= _maxLen; i++) {\n        var thisRow = row.slice(0);\n        thisRow[0] = -i;\n        table.push(thisRow);\n    }\n    return table;\n}\nvar _table = initTable();\nvar _scores = initTable();\nvar _arrows = initTable();\nvar _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n    function pad(s, n, pad) {\n        if (pad === void 0) { pad = ' '; }\n        while (s.length < n) {\n            s = pad + s;\n        }\n        return s;\n    }\n    var ret = \" |   |\" + word.split('').map(function (c) { return pad(c, 3); }).join('|') + \"\\n\";\n    for (var i = 0; i <= patternLen; i++) {\n        if (i === 0) {\n            ret += ' |';\n        }\n        else {\n            ret += pattern[i - 1] + \"|\";\n        }\n        ret += table[i].slice(0, wordLen + 1).map(function (n) { return pad(n.toString(), 3); }).join('|') + '\\n';\n    }\n    return ret;\n}\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    var code = value.charCodeAt(index);\n    switch (code) {\n        case charCode_1.CharCode.Underline:\n        case charCode_1.CharCode.Dash:\n        case charCode_1.CharCode.Period:\n        case charCode_1.CharCode.Space:\n        case charCode_1.CharCode.Slash:\n        case charCode_1.CharCode.Backslash:\n        case charCode_1.CharCode.SingleQuote:\n        case charCode_1.CharCode.DoubleQuote:\n        case charCode_1.CharCode.Colon:\n        case charCode_1.CharCode.DollarSign:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    var code = value.charCodeAt(index);\n    switch (code) {\n        case charCode_1.CharCode.Space:\n        case charCode_1.CharCode.Tab:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nfunction isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\nvar Arrow;\n(function (Arrow) {\n    Arrow[Arrow[\"Top\"] = 1] = \"Top\";\n    Arrow[Arrow[\"Diag\"] = 2] = \"Diag\";\n    Arrow[Arrow[\"Left\"] = 4] = \"Left\";\n})(Arrow || (Arrow = {}));\nvar FuzzyScore;\n(function (FuzzyScore) {\n    /**\n     * No matches and value `-100`\n     */\n    FuzzyScore.Default = [-100, 0, 0];\n    function isDefault(score) {\n        return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore = exports.FuzzyScore || (exports.FuzzyScore = {}));\nfunction fuzzyScore(pattern, patternLow, patternPos, word, wordLow, wordPos, firstMatchCanBeWeak) {\n    var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    var wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternPos >= patternLen || wordPos >= wordLen || patternLen > wordLen) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen)) {\n        return undefined;\n    }\n    var patternStartPos = patternPos;\n    var wordStartPos = wordPos;\n    // There will be a mach, fill in tables\n    for (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {\n        for (wordPos = 1; wordPos <= wordLen; wordPos++) {\n            var score = -1;\n            if (patternLow[patternPos - 1] === wordLow[wordPos - 1]) {\n                if (wordPos === (patternPos - patternStartPos)) {\n                    // common prefix: `foobar <-> foobaz`\n                    //                            ^^^^^\n                    if (pattern[patternPos - 1] === word[wordPos - 1]) {\n                        score = 7;\n                    }\n                    else {\n                        score = 5;\n                    }\n                }\n                else if (isUpperCaseAtPos(wordPos - 1, word, wordLow) && (wordPos === 1 || !isUpperCaseAtPos(wordPos - 2, word, wordLow))) {\n                    // hitting upper-case: `foo <-> forOthers`\n                    //                              ^^ ^\n                    if (pattern[patternPos - 1] === word[wordPos - 1]) {\n                        score = 7;\n                    }\n                    else {\n                        score = 5;\n                    }\n                }\n                else if (isSeparatorAtPos(wordLow, wordPos - 2) || isWhitespaceAtPos(wordLow, wordPos - 2)) {\n                    // post separator: `foo <-> bar_foo`\n                    //                              ^^^\n                    score = 5;\n                }\n                else {\n                    score = 1;\n                }\n            }\n            _scores[patternPos][wordPos] = score;\n            var diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);\n            var top = _table[patternPos - 1][wordPos] + -1;\n            var left = _table[patternPos][wordPos - 1] + -1;\n            if (left >= top) {\n                // left or diag\n                if (left > diag) {\n                    _table[patternPos][wordPos] = left;\n                    _arrows[patternPos][wordPos] = Arrow.Left;\n                }\n                else if (left === diag) {\n                    _table[patternPos][wordPos] = left;\n                    _arrows[patternPos][wordPos] = Arrow.Left | Arrow.Diag;\n                }\n                else {\n                    _table[patternPos][wordPos] = diag;\n                    _arrows[patternPos][wordPos] = Arrow.Diag;\n                }\n            }\n            else {\n                // top or diag\n                if (top > diag) {\n                    _table[patternPos][wordPos] = top;\n                    _arrows[patternPos][wordPos] = Arrow.Top;\n                }\n                else if (top === diag) {\n                    _table[patternPos][wordPos] = top;\n                    _arrows[patternPos][wordPos] = Arrow.Top | Arrow.Diag;\n                }\n                else {\n                    _table[patternPos][wordPos] = diag;\n                    _arrows[patternPos][wordPos] = Arrow.Diag;\n                }\n            }\n        }\n    }\n    if (_debug) {\n        console.log(printTable(_table, pattern, patternLen, word, wordLen));\n        console.log(printTable(_arrows, pattern, patternLen, word, wordLen));\n        console.log(printTable(_scores, pattern, patternLen, word, wordLen));\n    }\n    _matchesCount = 0;\n    _topScore = -100;\n    _patternStartPos = patternStartPos;\n    _firstMatchCanBeWeak = firstMatchCanBeWeak;\n    _findAllMatches2(patternLen, wordLen, patternLen === wordLen ? 1 : 0, 0, false);\n    if (_matchesCount === 0) {\n        return undefined;\n    }\n    return [_topScore, _topMatch2, wordStartPos];\n}\nexports.fuzzyScore = fuzzyScore;\nvar _matchesCount = 0;\nvar _topMatch2 = 0;\nvar _topScore = 0;\nvar _patternStartPos = 0;\nvar _firstMatchCanBeWeak = false;\nfunction _findAllMatches2(patternPos, wordPos, total, matches, lastMatched) {\n    if (_matchesCount >= 10 || total < -25) {\n        // stop when having already 10 results, or\n        // when a potential alignment as already 5 gaps\n        return;\n    }\n    var simpleMatchCount = 0;\n    while (patternPos > _patternStartPos && wordPos > 0) {\n        var score = _scores[patternPos][wordPos];\n        var arrow = _arrows[patternPos][wordPos];\n        if (arrow === Arrow.Left) {\n            // left -> no match, skip a word character\n            wordPos -= 1;\n            if (lastMatched) {\n                total -= 5; // new gap penalty\n            }\n            else if (matches !== 0) {\n                total -= 1; // gap penalty after first match\n            }\n            lastMatched = false;\n            simpleMatchCount = 0;\n        }\n        else if (arrow & Arrow.Diag) {\n            if (arrow & Arrow.Left) {\n                // left\n                _findAllMatches2(patternPos, wordPos - 1, matches !== 0 ? total - 1 : total, // gap penalty after first match\n                matches, lastMatched);\n            }\n            // diag\n            total += score;\n            patternPos -= 1;\n            wordPos -= 1;\n            lastMatched = true;\n            // match -> set a 1 at the word pos\n            matches += Math.pow(2, wordPos);\n            // count simple matches and boost a row of\n            // simple matches when they yield in a\n            // strong match.\n            if (score === 1) {\n                simpleMatchCount += 1;\n                if (patternPos === _patternStartPos && !_firstMatchCanBeWeak) {\n                    // when the first match is a weak\n                    // match we discard it\n                    return undefined;\n                }\n            }\n            else {\n                // boost\n                total += 1 + (simpleMatchCount * (score - 1));\n                simpleMatchCount = 0;\n            }\n        }\n        else {\n            return undefined;\n        }\n    }\n    total -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty\n    // dynamically keep track of the current top score\n    // and insert the current best score at head, the rest at tail\n    _matchesCount += 1;\n    if (total > _topScore) {\n        _topScore = total;\n        _topMatch2 = matches;\n    }\n}\n//#endregion\n//#region --- graceful ---\nfunction fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\nexports.fuzzyScoreGracefulAggressive = fuzzyScoreGracefulAggressive;\nfunction fuzzyScoreGraceful(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, firstMatchCanBeWeak);\n}\nexports.fuzzyScoreGraceful = fuzzyScoreGraceful;\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n    var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        var tries = Math.min(7, pattern.length - 1);\n        for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            var newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    var swap1 = pattern[patternPos];\n    var swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n//#endregion\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/filters.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/filters.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { LRUCache } from 'vs/base/common/map';\nimport * as strings from 'vs/base/common/strings';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] | null {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space\n\t\t|| code === CharCode.Tab\n\t\t|| code === CharCode.LineFeed\n\t\t|| code === CharCode.CarriageReturn\n\t);\n}\n\nconst wordSeparators = new Set<number>();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\n\t.split('')\n\t.forEach(s => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code: number): boolean {\n\treturn wordSeparators.has(code);\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\tif (camelCaseWord.length > 60) {\n\t\treturn null;\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string, contiguous: boolean = false): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n\t\ti = nextWord(target, i + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, i: number, j: number, contiguous: boolean): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === target.length) {\n\t\treturn null;\n\t} else if (word[i] !== target[j]) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextWordIndex = j + 1;\n\t\tresult = _matchesWords(word, target, i + 1, j + 1, contiguous);\n\t\tif (!contiguous) {\n\t\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\t\tresult = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n\t\t\t\tnextWordIndex++;\n\t\t\t}\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tconst c = word.charCodeAt(i);\n\t\tif (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1))) ||\n\t\t\tisWordSeparator(c) || (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern againt word in a fuzzy way. As in IntelliSense and faster and more\n * powerfull than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, true);\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(pattern: string, lowPattern: string, _patternPos: number, word: string, lowWord: string, _wordPos: number): FuzzyScore {\n\tconst result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n\tif (result) {\n\t\treturn result;\n\t}\n\tlet matches = 0;\n\tlet score = 0;\n\tlet idx = _wordPos;\n\tfor (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n\t\tconst wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n\t\tif (wordPos >= 0) {\n\t\t\tscore += 1;\n\t\t\tmatches += 2 ** wordPos;\n\t\t\tidx = wordPos + 1;\n\t\t}\n\t}\n\treturn [score, matches, _wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === 'undefined') {\n\t\treturn [];\n\t}\n\n\tconst matches = score[1].toString(2);\n\tconst wordStart = score[2];\n\tconst res: IMatch[] = [];\n\n\tfor (let pos = wordStart; pos < _maxLen; pos++) {\n\t\tif (matches[matches.length - (pos + 1)] === '1') {\n\t\t\tconst last = res[res.length - 1];\n\t\t\tif (last && last.end === pos) {\n\t\t\t\tlast.end = pos + 1;\n\t\t\t} else {\n\t\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 53;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [0];\n\tfor (let i = 1; i <= _maxLen; i++) {\n\t\trow.push(-i);\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\tconst thisRow = row.slice(0);\n\t\tthisRow[0] = -i;\n\t\ttable.push(thisRow);\n\t}\n\treturn table;\n}\n\nconst _table = initTable();\nconst _scores = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(table: number[][], pattern: string, patternLen: number, word: string, wordLen: number): string {\n\tfunction pad(s: string, n: number, pad = ' ') {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += ' |';\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n\t}\n\treturn ret;\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nfunction isPatternInWord(patternLow: string, patternPos: number, patternLen: number, wordLow: string, wordPos: number, wordLen: number): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nconst enum Arrow { Top = 0b1, Diag = 0b10, Left = 0b100 }\n\n/**\n * A tuple of three values.\n * 0. the score\n * 1. the matches encoded as bitmask (2^53)\n * 2. the offset at which matching started\n */\nexport type FuzzyScore = [number, number, number];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: [-100, 0, 0] = [-100, 0, 0];\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0, 0] {\n\t\treturn !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\n\t}\n}\n\nexport interface FuzzyScorer {\n\t(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(pattern: string, patternLow: string, patternPos: number, word: string, wordLow: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (patternPos >= patternLen || wordPos >= wordLen || patternLen > wordLen) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (!isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen)) {\n\t\treturn undefined;\n\t}\n\n\tconst patternStartPos = patternPos;\n\tconst wordStartPos = wordPos;\n\n\t// There will be a mach, fill in tables\n\tfor (patternPos = patternStartPos + 1; patternPos <= patternLen; patternPos++) {\n\n\t\tfor (wordPos = 1; wordPos <= wordLen; wordPos++) {\n\n\t\t\tlet score = -1;\n\t\t\tif (patternLow[patternPos - 1] === wordLow[wordPos - 1]) {\n\n\t\t\t\tif (wordPos === (patternPos - patternStartPos)) {\n\t\t\t\t\t// common prefix: `foobar <-> foobaz`\n\t\t\t\t\t//                            ^^^^^\n\t\t\t\t\tif (pattern[patternPos - 1] === word[wordPos - 1]) {\n\t\t\t\t\t\tscore = 7;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = 5;\n\t\t\t\t\t}\n\t\t\t\t} else if (isUpperCaseAtPos(wordPos - 1, word, wordLow) && (wordPos === 1 || !isUpperCaseAtPos(wordPos - 2, word, wordLow))) {\n\t\t\t\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t\t\t\t//                              ^^ ^\n\t\t\t\t\tif (pattern[patternPos - 1] === word[wordPos - 1]) {\n\t\t\t\t\t\tscore = 7;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscore = 5;\n\t\t\t\t\t}\n\t\t\t\t} else if (isSeparatorAtPos(wordLow, wordPos - 2) || isWhitespaceAtPos(wordLow, wordPos - 2)) {\n\t\t\t\t\t// post separator: `foo <-> bar_foo`\n\t\t\t\t\t//                              ^^^\n\t\t\t\t\tscore = 5;\n\n\t\t\t\t} else {\n\t\t\t\t\tscore = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_scores[patternPos][wordPos] = score;\n\n\t\t\tconst diag = _table[patternPos - 1][wordPos - 1] + (score > 1 ? 1 : score);\n\t\t\tconst top = _table[patternPos - 1][wordPos] + -1;\n\t\t\tconst left = _table[patternPos][wordPos - 1] + -1;\n\n\t\t\tif (left >= top) {\n\t\t\t\t// left or diag\n\t\t\t\tif (left > diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = left;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Left;\n\t\t\t\t} else if (left === diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = left;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Left | Arrow.Diag;\n\t\t\t\t} else {\n\t\t\t\t\t_table[patternPos][wordPos] = diag;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Diag;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// top or diag\n\t\t\t\tif (top > diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = top;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Top;\n\t\t\t\t} else if (top === diag) {\n\t\t\t\t\t_table[patternPos][wordPos] = top;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Top | Arrow.Diag;\n\t\t\t\t} else {\n\t\t\t\t\t_table[patternPos][wordPos] = diag;\n\t\t\t\t\t_arrows[patternPos][wordPos] = Arrow.Diag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tconsole.log(printTable(_table, pattern, patternLen, word, wordLen));\n\t\tconsole.log(printTable(_arrows, pattern, patternLen, word, wordLen));\n\t\tconsole.log(printTable(_scores, pattern, patternLen, word, wordLen));\n\t}\n\n\t_matchesCount = 0;\n\t_topScore = -100;\n\t_patternStartPos = patternStartPos;\n\t_firstMatchCanBeWeak = firstMatchCanBeWeak;\n\t_findAllMatches2(patternLen, wordLen, patternLen === wordLen ? 1 : 0, 0, false);\n\tif (_matchesCount === 0) {\n\t\treturn undefined;\n\t}\n\n\treturn [_topScore, _topMatch2, wordStartPos];\n}\n\n\nlet _matchesCount: number = 0;\nlet _topMatch2: number = 0;\nlet _topScore: number = 0;\nlet _patternStartPos: number = 0;\nlet _firstMatchCanBeWeak: boolean = false;\n\nfunction _findAllMatches2(patternPos: number, wordPos: number, total: number, matches: number, lastMatched: boolean): void {\n\n\tif (_matchesCount >= 10 || total < -25) {\n\t\t// stop when having already 10 results, or\n\t\t// when a potential alignment as already 5 gaps\n\t\treturn;\n\t}\n\n\tlet simpleMatchCount = 0;\n\n\twhile (patternPos > _patternStartPos && wordPos > 0) {\n\n\t\tconst score = _scores[patternPos][wordPos];\n\t\tconst arrow = _arrows[patternPos][wordPos];\n\n\t\tif (arrow === Arrow.Left) {\n\t\t\t// left -> no match, skip a word character\n\t\t\twordPos -= 1;\n\t\t\tif (lastMatched) {\n\t\t\t\ttotal -= 5; // new gap penalty\n\t\t\t} else if (matches !== 0) {\n\t\t\t\ttotal -= 1; // gap penalty after first match\n\t\t\t}\n\t\t\tlastMatched = false;\n\t\t\tsimpleMatchCount = 0;\n\n\t\t} else if (arrow & Arrow.Diag) {\n\n\t\t\tif (arrow & Arrow.Left) {\n\t\t\t\t// left\n\t\t\t\t_findAllMatches2(\n\t\t\t\t\tpatternPos,\n\t\t\t\t\twordPos - 1,\n\t\t\t\t\tmatches !== 0 ? total - 1 : total, // gap penalty after first match\n\t\t\t\t\tmatches,\n\t\t\t\t\tlastMatched\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// diag\n\t\t\ttotal += score;\n\t\t\tpatternPos -= 1;\n\t\t\twordPos -= 1;\n\t\t\tlastMatched = true;\n\n\t\t\t// match -> set a 1 at the word pos\n\t\t\tmatches += 2 ** wordPos;\n\n\t\t\t// count simple matches and boost a row of\n\t\t\t// simple matches when they yield in a\n\t\t\t// strong match.\n\t\t\tif (score === 1) {\n\t\t\t\tsimpleMatchCount += 1;\n\n\t\t\t\tif (patternPos === _patternStartPos && !_firstMatchCanBeWeak) {\n\t\t\t\t\t// when the first match is a weak\n\t\t\t\t\t// match we discard it\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// boost\n\t\t\t\ttotal += 1 + (simpleMatchCount * (score - 1));\n\t\t\t\tsimpleMatchCount = 0;\n\t\t\t}\n\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\ttotal -= wordPos >= 3 ? 9 : wordPos * 3; // late start penalty\n\n\t// dynamically keep track of the current top score\n\t// and insert the current best score at head, the rest at tail\n\t_matchesCount += 1;\n\tif (total > _topScore) {\n\t\t_topScore = total;\n\t\t_topMatch2 = matches;\n\t}\n}\n\n//#endregion\n\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n\nexport function fuzzyScoreGraceful(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, firstMatchCanBeWeak);\n}\n\nfunction fuzzyScoreWithPermutations(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, aggressive: boolean, firstMatchCanBeWeak: boolean): FuzzyScore | undefined {\n\tlet top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(pattern: string, patternPos: number): string | undefined {\n\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn pattern.slice(0, patternPos)\n\t\t+ swap2\n\t\t+ swap1\n\t\t+ pattern.slice(patternPos + 2);\n}\n\n//#endregion\n"]}]}