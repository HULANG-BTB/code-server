{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/extensions/node/extensionValidator.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/extensions/node/extensionValidator.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/platform/product/node/package\"], function (require, exports, nls, package_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const VERSION_REGEXP = /^(\\^|>=)?((\\d+)|x)\\.((\\d+)|x)\\.((\\d+)|x)(\\-.*)?$/;\n    function isValidVersionStr(version) {\n        version = version.trim();\n        return (version === '*' || VERSION_REGEXP.test(version));\n    }\n    exports.isValidVersionStr = isValidVersionStr;\n    function parseVersion(version) {\n        if (!isValidVersionStr(version)) {\n            return null;\n        }\n        version = version.trim();\n        if (version === '*') {\n            return {\n                hasCaret: false,\n                hasGreaterEquals: false,\n                majorBase: 0,\n                majorMustEqual: false,\n                minorBase: 0,\n                minorMustEqual: false,\n                patchBase: 0,\n                patchMustEqual: false,\n                preRelease: null\n            };\n        }\n        let m = version.match(VERSION_REGEXP);\n        if (!m) {\n            return null;\n        }\n        return {\n            hasCaret: m[1] === '^',\n            hasGreaterEquals: m[1] === '>=',\n            majorBase: m[2] === 'x' ? 0 : parseInt(m[2], 10),\n            majorMustEqual: (m[2] === 'x' ? false : true),\n            minorBase: m[4] === 'x' ? 0 : parseInt(m[4], 10),\n            minorMustEqual: (m[4] === 'x' ? false : true),\n            patchBase: m[6] === 'x' ? 0 : parseInt(m[6], 10),\n            patchMustEqual: (m[6] === 'x' ? false : true),\n            preRelease: m[8] || null\n        };\n    }\n    exports.parseVersion = parseVersion;\n    function normalizeVersion(version) {\n        if (!version) {\n            return null;\n        }\n        let majorBase = version.majorBase, majorMustEqual = version.majorMustEqual, minorBase = version.minorBase, minorMustEqual = version.minorMustEqual, patchBase = version.patchBase, patchMustEqual = version.patchMustEqual;\n        if (version.hasCaret) {\n            if (majorBase === 0) {\n                patchMustEqual = false;\n            }\n            else {\n                minorMustEqual = false;\n                patchMustEqual = false;\n            }\n        }\n        return {\n            majorBase: majorBase,\n            majorMustEqual: majorMustEqual,\n            minorBase: minorBase,\n            minorMustEqual: minorMustEqual,\n            patchBase: patchBase,\n            patchMustEqual: patchMustEqual,\n            isMinimum: version.hasGreaterEquals\n        };\n    }\n    exports.normalizeVersion = normalizeVersion;\n    function isValidVersion(_version, _desiredVersion) {\n        let version;\n        if (typeof _version === 'string') {\n            version = normalizeVersion(parseVersion(_version));\n        }\n        else {\n            version = _version;\n        }\n        let desiredVersion;\n        if (typeof _desiredVersion === 'string') {\n            desiredVersion = normalizeVersion(parseVersion(_desiredVersion));\n        }\n        else {\n            desiredVersion = _desiredVersion;\n        }\n        if (!version || !desiredVersion) {\n            return false;\n        }\n        let majorBase = version.majorBase;\n        let minorBase = version.minorBase;\n        let patchBase = version.patchBase;\n        let desiredMajorBase = desiredVersion.majorBase;\n        let desiredMinorBase = desiredVersion.minorBase;\n        let desiredPatchBase = desiredVersion.patchBase;\n        let majorMustEqual = desiredVersion.majorMustEqual;\n        let minorMustEqual = desiredVersion.minorMustEqual;\n        let patchMustEqual = desiredVersion.patchMustEqual;\n        if (desiredVersion.isMinimum) {\n            if (majorBase > desiredMajorBase) {\n                return true;\n            }\n            if (majorBase < desiredMajorBase) {\n                return false;\n            }\n            if (minorBase > desiredMinorBase) {\n                return true;\n            }\n            if (minorBase < desiredMinorBase) {\n                return false;\n            }\n            return patchBase >= desiredPatchBase;\n        }\n        // Anything < 1.0.0 is compatible with >= 1.0.0, except exact matches\n        if (majorBase === 1 && desiredMajorBase === 0 && (!majorMustEqual || !minorMustEqual || !patchMustEqual)) {\n            desiredMajorBase = 1;\n            desiredMinorBase = 0;\n            desiredPatchBase = 0;\n            majorMustEqual = true;\n            minorMustEqual = false;\n            patchMustEqual = false;\n        }\n        if (majorBase < desiredMajorBase) {\n            // smaller major version\n            return false;\n        }\n        if (majorBase > desiredMajorBase) {\n            // higher major version\n            return (!majorMustEqual);\n        }\n        // at this point, majorBase are equal\n        if (minorBase < desiredMinorBase) {\n            // smaller minor version\n            return false;\n        }\n        if (minorBase > desiredMinorBase) {\n            // higher minor version\n            return (!minorMustEqual);\n        }\n        // at this point, minorBase are equal\n        if (patchBase < desiredPatchBase) {\n            // smaller patch version\n            return false;\n        }\n        if (patchBase > desiredPatchBase) {\n            // higher patch version\n            return (!patchMustEqual);\n        }\n        // at this point, patchBase are equal\n        return true;\n    }\n    exports.isValidVersion = isValidVersion;\n    function isValidExtensionVersion(version, extensionDesc, notices) {\n        if (extensionDesc.isBuiltin || typeof extensionDesc.main === 'undefined') {\n            // No version check for builtin or declarative extensions\n            return true;\n        }\n        return isVersionValid(version, extensionDesc.engines.vscode, notices);\n    }\n    exports.isValidExtensionVersion = isValidExtensionVersion;\n    function isEngineValid(engine) {\n        // TODO@joao: discuss with alex '*' doesn't seem to be a valid engine version\n        return engine === '*' || isVersionValid(package_1.default.version, engine);\n    }\n    exports.isEngineValid = isEngineValid;\n    function isVersionValid(currentVersion, requestedVersion, notices = []) {\n        let desiredVersion = normalizeVersion(parseVersion(requestedVersion));\n        if (!desiredVersion) {\n            notices.push(nls.localize('versionSyntax', \"Could not parse `engines.vscode` value {0}. Please use, for example: ^1.22.0, ^1.22.x, etc.\", requestedVersion));\n            return false;\n        }\n        // enforce that a breaking API version is specified.\n        // for 0.X.Y, that means up to 0.X must be specified\n        // otherwise for Z.X.Y, that means Z must be specified\n        if (desiredVersion.majorBase === 0) {\n            // force that major and minor must be specific\n            if (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {\n                notices.push(nls.localize('versionSpecificity1', \"Version specified in `engines.vscode` ({0}) is not specific enough. For vscode versions before 1.0.0, please define at a minimum the major and minor desired version. E.g. ^0.10.0, 0.10.x, 0.11.0, etc.\", requestedVersion));\n                return false;\n            }\n        }\n        else {\n            // force that major must be specific\n            if (!desiredVersion.majorMustEqual) {\n                notices.push(nls.localize('versionSpecificity2', \"Version specified in `engines.vscode` ({0}) is not specific enough. For vscode versions after 1.0.0, please define at a minimum the major desired version. E.g. ^1.10.0, 1.10.x, 1.x.x, 2.x.x, etc.\", requestedVersion));\n                return false;\n            }\n        }\n        if (!isValidVersion(currentVersion, desiredVersion)) {\n            notices.push(nls.localize('versionMismatch', \"Extension is not compatible with Code {0}. Extension requires: {1}.\", currentVersion, requestedVersion));\n            return false;\n        }\n        return true;\n    }\n    exports.isVersionValid = isVersionValid;\n});\n",null]}