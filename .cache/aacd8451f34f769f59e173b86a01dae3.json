{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/extensions.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/common/extensions.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"vs/base/common/uri\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/extensions/common/extensions\", \"vs/platform/extensionManagement/common/extensionManagementUtil\"], function (require, exports, event_1, uri_1, instantiation_1, extensions_1, extensionManagementUtil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.nullExtensionDescription = Object.freeze({\n        identifier: new extensions_1.ExtensionIdentifier('nullExtensionDescription'),\n        name: 'Null Extension Description',\n        version: '0.0.0',\n        publisher: 'vscode',\n        enableProposedApi: false,\n        engines: { vscode: '' },\n        extensionLocation: uri_1.URI.parse('void:location'),\n        isBuiltin: false,\n    });\n    exports.IExtensionService = instantiation_1.createDecorator('extensionService');\n    class MissingDependencyError {\n        constructor(dependency) {\n            this.dependency = dependency;\n        }\n    }\n    exports.MissingDependencyError = MissingDependencyError;\n    class ActivationTimes {\n        constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {\n            this.startup = startup;\n            this.codeLoadingTime = codeLoadingTime;\n            this.activateCallTime = activateCallTime;\n            this.activateResolvedTime = activateResolvedTime;\n            this.activationEvent = activationEvent;\n        }\n    }\n    exports.ActivationTimes = ActivationTimes;\n    class ExtensionPointContribution {\n        constructor(description, value) {\n            this.description = description;\n            this.value = value;\n        }\n    }\n    exports.ExtensionPointContribution = ExtensionPointContribution;\n    exports.ExtensionHostLogFileName = 'exthost';\n    function checkProposedApiEnabled(extension) {\n        if (!extension.enableProposedApi) {\n            throwProposedApiError(extension);\n        }\n    }\n    exports.checkProposedApiEnabled = checkProposedApiEnabled;\n    function throwProposedApiError(extension) {\n        throw new Error(`[${extension.identifier.value}]: Proposed API is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);\n    }\n    exports.throwProposedApiError = throwProposedApiError;\n    function toExtension(extensionDescription) {\n        return {\n            type: extensionDescription.isBuiltin ? extensions_1.ExtensionType.System : extensions_1.ExtensionType.User,\n            identifier: { id: extensionManagementUtil_1.getGalleryExtensionId(extensionDescription.publisher, extensionDescription.name), uuid: extensionDescription.uuid },\n            manifest: extensionDescription,\n            location: extensionDescription.extensionLocation,\n        };\n    }\n    exports.toExtension = toExtension;\n    class NullExtensionService {\n        constructor() {\n            this.onDidRegisterExtensions = event_1.Event.None;\n            this.onDidChangeExtensionsStatus = event_1.Event.None;\n            this.onDidChangeExtensions = event_1.Event.None;\n            this.onWillActivateByEvent = event_1.Event.None;\n            this.onDidChangeResponsiveChange = event_1.Event.None;\n        }\n        activateByEvent(_activationEvent) { return Promise.resolve(undefined); }\n        whenInstalledExtensionsRegistered() { return Promise.resolve(true); }\n        getExtensions() { return Promise.resolve([]); }\n        getExtension() { return Promise.resolve(undefined); }\n        readExtensionPointContributions(_extPoint) { return Promise.resolve(Object.create(null)); }\n        getExtensionsStatus() { return Object.create(null); }\n        canProfileExtensionHost() { return false; }\n        getInspectPort() { return 0; }\n        startExtensionHostProfile() { return Promise.resolve(Object.create(null)); }\n        restartExtensionHost() { }\n        startExtensionHost() { }\n        stopExtensionHost() { }\n        canAddExtension() { return false; }\n        canRemoveExtension() { return false; }\n        _logOrShowMessage(_severity, _msg) { }\n        _activateById(_extensionId, _activationEvent) { return Promise.resolve(); }\n        _onWillActivateExtension(_extensionId) { }\n        _onDidActivateExtension(_extensionId, _startup, _codeLoadingTime, _activateCallTime, _activateResolvedTime, _activationEvent) { }\n        _onExtensionRuntimeError(_extensionId, _err) { }\n        _onExtensionHostExit(code) { }\n    }\n    exports.NullExtensionService = NullExtensionService;\n});\n",null]}