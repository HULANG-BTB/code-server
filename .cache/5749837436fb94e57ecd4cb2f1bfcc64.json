{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/asyncDataTree.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/asyncDataTree.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar abstractTree_1 = require(\"vs/base/browser/ui/tree/abstractTree\");\nvar objectTree_1 = require(\"vs/base/browser/ui/tree/objectTree\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar event_1 = require(\"vs/base/common/event\");\nvar async_1 = require(\"vs/base/common/async\");\nvar iterator_1 = require(\"vs/base/common/iterator\");\nvar listView_1 = require(\"vs/base/browser/ui/list/listView\");\nvar errors_1 = require(\"vs/base/common/errors\");\nvar dom_1 = require(\"vs/base/browser/dom\");\nvar map_1 = require(\"vs/base/common/map\");\nfunction createAsyncDataTreeNode(props) {\n    return tslib_1.__assign({}, props, { children: [], loading: false, stale: true, slow: false });\n}\nfunction isAncestor(ancestor, descendant) {\n    if (!descendant.parent) {\n        return false;\n    }\n    else if (descendant.parent === ancestor) {\n        return true;\n    }\n    else {\n        return isAncestor(ancestor, descendant.parent);\n    }\n}\nfunction intersects(node, other) {\n    return node === other || isAncestor(node, other) || isAncestor(other, node);\n}\nvar AsyncDataTreeNodeWrapper = /** @class */ (function () {\n    function AsyncDataTreeNodeWrapper(node) {\n        this.node = node;\n    }\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"element\", {\n        get: function () { return this.node.element.element; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"parent\", {\n        get: function () { return this.node.parent && new AsyncDataTreeNodeWrapper(this.node.parent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"children\", {\n        get: function () { return this.node.children.map(function (node) { return new AsyncDataTreeNodeWrapper(node); }); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"depth\", {\n        get: function () { return this.node.depth; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"visibleChildrenCount\", {\n        get: function () { return this.node.visibleChildrenCount; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"visibleChildIndex\", {\n        get: function () { return this.node.visibleChildIndex; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"collapsible\", {\n        get: function () { return this.node.collapsible; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"collapsed\", {\n        get: function () { return this.node.collapsed; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"visible\", {\n        get: function () { return this.node.visible; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTreeNodeWrapper.prototype, \"filterData\", {\n        get: function () { return this.node.filterData; },\n        enumerable: true,\n        configurable: true\n    });\n    return AsyncDataTreeNodeWrapper;\n}());\nvar DataTreeRenderer = /** @class */ (function () {\n    function DataTreeRenderer(renderer, onDidChangeTwistieState) {\n        this.renderer = renderer;\n        this.onDidChangeTwistieState = onDidChangeTwistieState;\n        this.renderedNodes = new Map();\n        this.disposables = [];\n        this.templateId = renderer.templateId;\n    }\n    DataTreeRenderer.prototype.renderTemplate = function (container) {\n        var templateData = this.renderer.renderTemplate(container);\n        return { templateData: templateData };\n    };\n    DataTreeRenderer.prototype.renderElement = function (node, index, templateData, dynamicHeightProbing) {\n        this.renderer.renderElement(new AsyncDataTreeNodeWrapper(node), index, templateData.templateData, dynamicHeightProbing);\n    };\n    DataTreeRenderer.prototype.renderTwistie = function (element, twistieElement) {\n        dom_1.toggleClass(twistieElement, 'loading', element.slow);\n        return false;\n    };\n    DataTreeRenderer.prototype.disposeElement = function (node, index, templateData, dynamicHeightProbing) {\n        if (this.renderer.disposeElement) {\n            this.renderer.disposeElement(new AsyncDataTreeNodeWrapper(node), index, templateData.templateData, dynamicHeightProbing);\n        }\n    };\n    DataTreeRenderer.prototype.disposeTemplate = function (templateData) {\n        this.renderer.disposeTemplate(templateData.templateData);\n    };\n    DataTreeRenderer.prototype.dispose = function () {\n        this.renderedNodes.clear();\n        this.disposables = lifecycle_1.dispose(this.disposables);\n    };\n    return DataTreeRenderer;\n}());\nfunction asTreeEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        elements: e.elements.map(function (e) { return e.element; })\n    };\n}\nfunction asTreeMouseEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element\n    };\n}\nfunction asTreeContextMenuEvent(e) {\n    return {\n        browserEvent: e.browserEvent,\n        element: e.element && e.element.element,\n        anchor: e.anchor\n    };\n}\nvar ChildrenResolutionReason;\n(function (ChildrenResolutionReason) {\n    ChildrenResolutionReason[ChildrenResolutionReason[\"Refresh\"] = 0] = \"Refresh\";\n    ChildrenResolutionReason[ChildrenResolutionReason[\"Expand\"] = 1] = \"Expand\";\n})(ChildrenResolutionReason = exports.ChildrenResolutionReason || (exports.ChildrenResolutionReason = {}));\nfunction asAsyncDataTreeDragAndDropData(data) {\n    if (data instanceof listView_1.ElementsDragAndDropData) {\n        var nodes = data.elements;\n        return new listView_1.ElementsDragAndDropData(nodes.map(function (node) { return node.element; }));\n    }\n    return data;\n}\nvar AsyncDataTreeNodeListDragAndDrop = /** @class */ (function () {\n    function AsyncDataTreeNodeListDragAndDrop(dnd) {\n        this.dnd = dnd;\n    }\n    AsyncDataTreeNodeListDragAndDrop.prototype.getDragURI = function (node) {\n        return this.dnd.getDragURI(node.element);\n    };\n    AsyncDataTreeNodeListDragAndDrop.prototype.getDragLabel = function (nodes) {\n        if (this.dnd.getDragLabel) {\n            return this.dnd.getDragLabel(nodes.map(function (node) { return node.element; }));\n        }\n        return undefined;\n    };\n    AsyncDataTreeNodeListDragAndDrop.prototype.onDragStart = function (data, originalEvent) {\n        if (this.dnd.onDragStart) {\n            this.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n        }\n    };\n    AsyncDataTreeNodeListDragAndDrop.prototype.onDragOver = function (data, targetNode, targetIndex, originalEvent, raw) {\n        if (raw === void 0) { raw = true; }\n        return this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    };\n    AsyncDataTreeNodeListDragAndDrop.prototype.drop = function (data, targetNode, targetIndex, originalEvent) {\n        this.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element, targetIndex, originalEvent);\n    };\n    return AsyncDataTreeNodeListDragAndDrop;\n}());\nfunction asObjectTreeOptions(options) {\n    return options && tslib_1.__assign({}, options, { collapseByDefault: true, identityProvider: options.identityProvider && {\n            getId: function (el) {\n                return options.identityProvider.getId(el.element);\n            }\n        }, dnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd), multipleSelectionController: options.multipleSelectionController && {\n            isSelectionSingleChangeEvent: function (e) {\n                return options.multipleSelectionController.isSelectionSingleChangeEvent(tslib_1.__assign({}, e, { element: e.element }));\n            },\n            isSelectionRangeChangeEvent: function (e) {\n                return options.multipleSelectionController.isSelectionRangeChangeEvent(tslib_1.__assign({}, e, { element: e.element }));\n            }\n        }, accessibilityProvider: options.accessibilityProvider && {\n            getAriaLabel: function (e) {\n                return options.accessibilityProvider.getAriaLabel(e.element);\n            }\n        }, filter: options.filter && {\n            filter: function (e, parentVisibility) {\n                return options.filter.filter(e.element, parentVisibility);\n            }\n        }, keyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n            getKeyboardNavigationLabel: function (e) {\n                return options.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);\n            }\n        }, sorter: undefined, expandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (typeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (function (e) { return options.expandOnlyOnTwistieClick(e.element); })), ariaSetProvider: undefined });\n}\nfunction asTreeElement(node, viewStateContext) {\n    var collapsed;\n    if (viewStateContext && viewStateContext.viewState.expanded && node.id) {\n        collapsed = viewStateContext.viewState.expanded.indexOf(node.id) === -1;\n    }\n    return {\n        element: node,\n        children: node.hasChildren ? iterator_1.Iterator.map(iterator_1.Iterator.fromArray(node.children), function (child) { return asTreeElement(child, viewStateContext); }) : [],\n        collapsible: node.hasChildren,\n        collapsed: collapsed\n    };\n}\nfunction dfs(node, fn) {\n    fn(node);\n    node.children.forEach(function (child) { return dfs(child, fn); });\n}\nvar AsyncDataTree = /** @class */ (function () {\n    function AsyncDataTree(container, delegate, renderers, dataSource, options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        this.dataSource = dataSource;\n        this.nodes = new Map();\n        this.subTreeRefreshPromises = new Map();\n        this.refreshPromises = new Map();\n        this._onDidRender = new event_1.Emitter();\n        this._onDidChangeNodeSlowState = new event_1.Emitter();\n        this.disposables = [];\n        this.identityProvider = options.identityProvider;\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n        this.sorter = options.sorter;\n        var objectTreeDelegate = new abstractTree_1.ComposedTreeDelegate(delegate);\n        var objectTreeRenderers = renderers.map(function (r) { return new DataTreeRenderer(r, _this._onDidChangeNodeSlowState.event); });\n        var objectTreeOptions = asObjectTreeOptions(options) || {};\n        this.tree = new objectTree_1.ObjectTree(container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n        this.root = createAsyncDataTreeNode({\n            element: undefined,\n            parent: null,\n            hasChildren: true\n        });\n        if (this.identityProvider) {\n            this.root = tslib_1.__assign({}, this.root, { id: null });\n        }\n        this.nodes.set(null, this.root);\n        this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n    }\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidScroll\", {\n        get: function () { return this.tree.onDidScroll; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidChangeFocus\", {\n        get: function () { return event_1.Event.map(this.tree.onDidChangeFocus, asTreeEvent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidChangeSelection\", {\n        get: function () { return event_1.Event.map(this.tree.onDidChangeSelection, asTreeEvent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidOpen\", {\n        get: function () { return event_1.Event.map(this.tree.onDidOpen, asTreeEvent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onKeyDown\", {\n        get: function () { return this.tree.onKeyDown; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onMouseClick\", {\n        get: function () { return event_1.Event.map(this.tree.onMouseClick, asTreeMouseEvent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onMouseDblClick\", {\n        get: function () { return event_1.Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onContextMenu\", {\n        get: function () { return event_1.Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidFocus\", {\n        get: function () { return this.tree.onDidFocus; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidBlur\", {\n        get: function () { return this.tree.onDidBlur; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidUpdateOptions\", {\n        get: function () { return this.tree.onDidUpdateOptions; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"filterOnType\", {\n        get: function () { return this.tree.filterOnType; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"openOnSingleClick\", {\n        get: function () { return this.tree.openOnSingleClick; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidDispose\", {\n        get: function () { return this.tree.onDidDispose; },\n        enumerable: true,\n        configurable: true\n    });\n    AsyncDataTree.prototype.updateOptions = function (options) {\n        if (options === void 0) { options = {}; }\n        this.tree.updateOptions(options);\n    };\n    // Widget\n    AsyncDataTree.prototype.getHTMLElement = function () {\n        return this.tree.getHTMLElement();\n    };\n    Object.defineProperty(AsyncDataTree.prototype, \"contentHeight\", {\n        get: function () {\n            return this.tree.contentHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"onDidChangeContentHeight\", {\n        get: function () {\n            return this.tree.onDidChangeContentHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"scrollTop\", {\n        get: function () {\n            return this.tree.scrollTop;\n        },\n        set: function (scrollTop) {\n            this.tree.scrollTop = scrollTop;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"scrollHeight\", {\n        get: function () {\n            return this.tree.scrollHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"renderHeight\", {\n        get: function () {\n            return this.tree.renderHeight;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"firstVisibleElement\", {\n        get: function () {\n            return this.tree.firstVisibleElement.element;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AsyncDataTree.prototype, \"lastVisibleElement\", {\n        get: function () {\n            return this.tree.lastVisibleElement.element;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AsyncDataTree.prototype.domFocus = function () {\n        this.tree.domFocus();\n    };\n    AsyncDataTree.prototype.layout = function (height, width) {\n        this.tree.layout(height, width);\n    };\n    AsyncDataTree.prototype.style = function (styles) {\n        this.tree.style(styles);\n    };\n    // Model\n    AsyncDataTree.prototype.getInput = function () {\n        return this.root.element;\n    };\n    AsyncDataTree.prototype.setInput = function (input, viewState) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var viewStateContext;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.refreshPromises.forEach(function (promise) { return promise.cancel(); });\n                        this.refreshPromises.clear();\n                        this.root.element = input;\n                        viewStateContext = viewState && { viewState: viewState, focus: [], selection: [] };\n                        return [4 /*yield*/, this.updateChildren(input, true, viewStateContext)];\n                    case 1:\n                        _a.sent();\n                        if (viewStateContext) {\n                            this.tree.setFocus(viewStateContext.focus);\n                            this.tree.setSelection(viewStateContext.selection);\n                        }\n                        if (viewState && typeof viewState.scrollTop === 'number') {\n                            this.scrollTop = viewState.scrollTop;\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.updateChildren = function (element, recursive, viewStateContext) {\n        if (element === void 0) { element = this.root.element; }\n        if (recursive === void 0) { recursive = true; }\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typeof this.root.element === 'undefined') {\n                            throw new Error('Tree input not set');\n                        }\n                        if (!this.root.loading) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.subTreeRefreshPromises.get(this.root)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, event_1.Event.toPromise(this._onDidRender.event)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [4 /*yield*/, this.refreshAndRenderNode(this.getDataNode(element), recursive, ChildrenResolutionReason.Refresh, viewStateContext)];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.resort = function (element, recursive) {\n        if (element === void 0) { element = this.root.element; }\n        if (recursive === void 0) { recursive = true; }\n        this.tree.resort(this.getDataNode(element), recursive);\n    };\n    AsyncDataTree.prototype.hasNode = function (element) {\n        return element === this.root.element || this.nodes.has(element);\n    };\n    // View\n    AsyncDataTree.prototype.rerender = function (element) {\n        if (element === undefined) {\n            this.tree.rerender();\n            return;\n        }\n        var node = this.getDataNode(element);\n        this.tree.rerender(node);\n    };\n    AsyncDataTree.prototype.updateWidth = function (element) {\n        var node = this.getDataNode(element);\n        this.tree.updateWidth(node);\n    };\n    // Tree\n    AsyncDataTree.prototype.getNode = function (element) {\n        if (element === void 0) { element = this.root.element; }\n        var dataNode = this.getDataNode(element);\n        var node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n        return new AsyncDataTreeNodeWrapper(node);\n    };\n    AsyncDataTree.prototype.collapse = function (element, recursive) {\n        if (recursive === void 0) { recursive = false; }\n        var node = this.getDataNode(element);\n        return this.tree.collapse(node === this.root ? null : node, recursive);\n    };\n    AsyncDataTree.prototype.expand = function (element, recursive) {\n        if (recursive === void 0) { recursive = false; }\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var node, result;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typeof this.root.element === 'undefined') {\n                            throw new Error('Tree input not set');\n                        }\n                        if (!this.root.loading) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.subTreeRefreshPromises.get(this.root)];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, event_1.Event.toPromise(this._onDidRender.event)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        node = this.getDataNode(element);\n                        if (node !== this.root && !node.loading && !this.tree.isCollapsed(node)) {\n                            return [2 /*return*/, false];\n                        }\n                        result = this.tree.expand(node === this.root ? null : node, recursive);\n                        if (!node.loading) return [3 /*break*/, 6];\n                        return [4 /*yield*/, this.subTreeRefreshPromises.get(node)];\n                    case 4:\n                        _a.sent();\n                        return [4 /*yield*/, event_1.Event.toPromise(this._onDidRender.event)];\n                    case 5:\n                        _a.sent();\n                        _a.label = 6;\n                    case 6: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.toggleCollapsed = function (element, recursive) {\n        if (recursive === void 0) { recursive = false; }\n        return this.tree.toggleCollapsed(this.getDataNode(element), recursive);\n    };\n    AsyncDataTree.prototype.expandAll = function () {\n        this.tree.expandAll();\n    };\n    AsyncDataTree.prototype.collapseAll = function () {\n        this.tree.collapseAll();\n    };\n    AsyncDataTree.prototype.isCollapsible = function (element) {\n        return this.tree.isCollapsible(this.getDataNode(element));\n    };\n    AsyncDataTree.prototype.isCollapsed = function (element) {\n        return this.tree.isCollapsed(this.getDataNode(element));\n    };\n    AsyncDataTree.prototype.toggleKeyboardNavigation = function () {\n        this.tree.toggleKeyboardNavigation();\n    };\n    AsyncDataTree.prototype.refilter = function () {\n        this.tree.refilter();\n    };\n    AsyncDataTree.prototype.setSelection = function (elements, browserEvent) {\n        var _this = this;\n        var nodes = elements.map(function (e) { return _this.getDataNode(e); });\n        this.tree.setSelection(nodes, browserEvent);\n    };\n    AsyncDataTree.prototype.getSelection = function () {\n        var nodes = this.tree.getSelection();\n        return nodes.map(function (n) { return n.element; });\n    };\n    AsyncDataTree.prototype.setFocus = function (elements, browserEvent) {\n        var _this = this;\n        var nodes = elements.map(function (e) { return _this.getDataNode(e); });\n        this.tree.setFocus(nodes, browserEvent);\n    };\n    AsyncDataTree.prototype.focusNext = function (n, loop, browserEvent) {\n        if (n === void 0) { n = 1; }\n        if (loop === void 0) { loop = false; }\n        this.tree.focusNext(n, loop, browserEvent);\n    };\n    AsyncDataTree.prototype.focusPrevious = function (n, loop, browserEvent) {\n        if (n === void 0) { n = 1; }\n        if (loop === void 0) { loop = false; }\n        this.tree.focusPrevious(n, loop, browserEvent);\n    };\n    AsyncDataTree.prototype.focusNextPage = function (browserEvent) {\n        this.tree.focusNextPage(browserEvent);\n    };\n    AsyncDataTree.prototype.focusPreviousPage = function (browserEvent) {\n        this.tree.focusPreviousPage(browserEvent);\n    };\n    AsyncDataTree.prototype.focusLast = function (browserEvent) {\n        this.tree.focusLast(browserEvent);\n    };\n    AsyncDataTree.prototype.focusFirst = function (browserEvent) {\n        this.tree.focusFirst(browserEvent);\n    };\n    AsyncDataTree.prototype.getFocus = function () {\n        var nodes = this.tree.getFocus();\n        return nodes.map(function (n) { return n.element; });\n    };\n    AsyncDataTree.prototype.open = function (elements) {\n        var _this = this;\n        var nodes = elements.map(function (e) { return _this.getDataNode(e); });\n        this.tree.open(nodes);\n    };\n    AsyncDataTree.prototype.reveal = function (element, relativeTop) {\n        this.tree.reveal(this.getDataNode(element), relativeTop);\n    };\n    AsyncDataTree.prototype.getRelativeTop = function (element) {\n        return this.tree.getRelativeTop(this.getDataNode(element));\n    };\n    // Tree navigation\n    AsyncDataTree.prototype.getParentElement = function (element) {\n        var node = this.tree.getParentElement(this.getDataNode(element));\n        return (node && node.element);\n    };\n    AsyncDataTree.prototype.getFirstElementChild = function (element) {\n        if (element === void 0) { element = this.root.element; }\n        var dataNode = this.getDataNode(element);\n        var node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n        return (node && node.element);\n    };\n    // Implementation\n    AsyncDataTree.prototype.getDataNode = function (element) {\n        var node = this.nodes.get((element === this.root.element ? null : element));\n        if (!node) {\n            throw new Error(\"Data tree node not found: \" + element);\n        }\n        return node;\n    };\n    AsyncDataTree.prototype.refreshAndRenderNode = function (node, recursive, reason, viewStateContext) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var treeNode, visibleChildren;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.refreshNode(node, recursive, viewStateContext)];\n                    case 1:\n                        _a.sent();\n                        this.render(node, viewStateContext);\n                        if (!(node !== this.root && this.autoExpandSingleChildren && reason === ChildrenResolutionReason.Expand)) return [3 /*break*/, 3];\n                        treeNode = this.tree.getNode(node);\n                        visibleChildren = treeNode.children.filter(function (node) { return node.visible; });\n                        if (!(visibleChildren.length === 1)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.tree.expand(visibleChildren[0].element, false)];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.refreshNode = function (node, recursive, viewStateContext) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var result;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.subTreeRefreshPromises.forEach(function (refreshPromise, refreshNode) {\n                            if (!result && intersects(refreshNode, node)) {\n                                result = refreshPromise.then(function () { return _this.refreshNode(node, recursive, viewStateContext); });\n                            }\n                        });\n                        if (result) {\n                            return [2 /*return*/, result];\n                        }\n                        result = this.doRefreshSubTree(node, recursive, viewStateContext);\n                        this.subTreeRefreshPromises.set(node, result);\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 3, 4]);\n                        return [4 /*yield*/, result];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        this.subTreeRefreshPromises.delete(node);\n                        return [7 /*endfinally*/];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.doRefreshSubTree = function (node, recursive, viewStateContext) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var childrenToRefresh;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        node.loading = true;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, , 4, 5]);\n                        return [4 /*yield*/, this.doRefreshNode(node, recursive, viewStateContext)];\n                    case 2:\n                        childrenToRefresh = _a.sent();\n                        node.stale = false;\n                        return [4 /*yield*/, Promise.all(childrenToRefresh.map(function (child) { return _this.doRefreshSubTree(child, recursive, viewStateContext); }))];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        node.loading = false;\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.doRefreshNode = function (node, recursive, viewStateContext) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var childrenPromise, slowTimeout_1, children, err_1;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        node.hasChildren = !!this.dataSource.hasChildren(node.element);\n                        if (!node.hasChildren) {\n                            childrenPromise = Promise.resolve([]);\n                        }\n                        else {\n                            slowTimeout_1 = async_1.timeout(800);\n                            slowTimeout_1.then(function () {\n                                node.slow = true;\n                                _this._onDidChangeNodeSlowState.fire(node);\n                            }, function (_) { return null; });\n                            childrenPromise = this.doGetChildren(node)\n                                .finally(function () { return slowTimeout_1.cancel(); });\n                        }\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, 4, 5]);\n                        return [4 /*yield*/, childrenPromise];\n                    case 2:\n                        children = _a.sent();\n                        return [2 /*return*/, this.setChildren(node, children, recursive, viewStateContext)];\n                    case 3:\n                        err_1 = _a.sent();\n                        if (node !== this.root) {\n                            this.tree.collapse(node === this.root ? null : node);\n                        }\n                        if (errors_1.isPromiseCanceledError(err_1)) {\n                            return [2 /*return*/, []];\n                        }\n                        throw err_1;\n                    case 4:\n                        if (node.slow) {\n                            node.slow = false;\n                            this._onDidChangeNodeSlowState.fire(node);\n                        }\n                        return [7 /*endfinally*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AsyncDataTree.prototype.doGetChildren = function (node) {\n        var _this = this;\n        var result = this.refreshPromises.get(node);\n        if (result) {\n            return result;\n        }\n        result = async_1.createCancelablePromise(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            var children;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.dataSource.getChildren(node.element)];\n                    case 1:\n                        children = _a.sent();\n                        if (this.sorter) {\n                            children.sort(this.sorter.compare.bind(this.sorter));\n                        }\n                        return [2 /*return*/, children];\n                }\n            });\n        }); });\n        this.refreshPromises.set(node, result);\n        return result.finally(function () { return _this.refreshPromises.delete(node); });\n    };\n    AsyncDataTree.prototype._onDidChangeCollapseState = function (_a) {\n        var node = _a.node, deep = _a.deep;\n        if (!node.collapsed && node.element.stale) {\n            if (deep) {\n                this.collapse(node.element.element);\n            }\n            else {\n                this.refreshAndRenderNode(node.element, false, ChildrenResolutionReason.Expand)\n                    .catch(errors_1.onUnexpectedError);\n            }\n        }\n    };\n    AsyncDataTree.prototype.setChildren = function (node, childrenElements, recursive, viewStateContext) {\n        var _this = this;\n        var _a;\n        // perf: if the node was and still is a leaf, avoid all this hassle\n        if (node.children.length === 0 && childrenElements.length === 0) {\n            return [];\n        }\n        var nodesToForget = new Map();\n        var childrenTreeNodesById = new Map();\n        for (var _i = 0, _b = node.children; _i < _b.length; _i++) {\n            var child = _b[_i];\n            nodesToForget.set(child.element, child);\n            if (this.identityProvider) {\n                childrenTreeNodesById.set(child.id, this.tree.getNode(child));\n            }\n        }\n        var childrenToRefresh = [];\n        var children = childrenElements.map(function (element) {\n            if (!_this.identityProvider) {\n                return createAsyncDataTreeNode({\n                    element: element,\n                    parent: node,\n                    hasChildren: !!_this.dataSource.hasChildren(element)\n                });\n            }\n            var id = _this.identityProvider.getId(element).toString();\n            var childNode = childrenTreeNodesById.get(id);\n            if (childNode) {\n                var asyncDataTreeNode = childNode.element;\n                nodesToForget.delete(asyncDataTreeNode.element);\n                _this.nodes.delete(asyncDataTreeNode.element);\n                _this.nodes.set(element, asyncDataTreeNode);\n                asyncDataTreeNode.element = element;\n                asyncDataTreeNode.hasChildren = !!_this.dataSource.hasChildren(element);\n                if (recursive) {\n                    if (childNode.collapsed) {\n                        dfs(asyncDataTreeNode, function (node) { return node.stale = true; });\n                    }\n                    else {\n                        childrenToRefresh.push(asyncDataTreeNode);\n                    }\n                }\n                return asyncDataTreeNode;\n            }\n            var childAsyncDataTreeNode = createAsyncDataTreeNode({\n                element: element,\n                parent: node,\n                id: id,\n                hasChildren: !!_this.dataSource.hasChildren(element)\n            });\n            if (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n                viewStateContext.focus.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n                viewStateContext.selection.push(childAsyncDataTreeNode);\n            }\n            if (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n                childrenToRefresh.push(childAsyncDataTreeNode);\n            }\n            return childAsyncDataTreeNode;\n        });\n        for (var _c = 0, _d = map_1.values(nodesToForget); _c < _d.length; _c++) {\n            var node_1 = _d[_c];\n            dfs(node_1, function (node) { return _this.nodes.delete(node.element); });\n        }\n        for (var _e = 0, children_1 = children; _e < children_1.length; _e++) {\n            var child = children_1[_e];\n            this.nodes.set(child.element, child);\n        }\n        (_a = node.children).splice.apply(_a, [0, node.children.length].concat(children));\n        return childrenToRefresh;\n    };\n    AsyncDataTree.prototype.render = function (node, viewStateContext) {\n        var children = node.children.map(function (c) { return asTreeElement(c, viewStateContext); });\n        this.tree.setChildren(node === this.root ? null : node, children);\n        this._onDidRender.fire();\n    };\n    // view state\n    AsyncDataTree.prototype.getViewState = function () {\n        var _this = this;\n        if (!this.identityProvider) {\n            throw new Error('Can\\'t get tree view state without an identity provider');\n        }\n        var getId = function (element) { return _this.identityProvider.getId(element).toString(); };\n        var focus = this.getFocus().map(getId);\n        var selection = this.getSelection().map(getId);\n        var expanded = [];\n        var root = this.tree.getNode();\n        var queue = [root];\n        while (queue.length > 0) {\n            var node = queue.shift();\n            if (node !== root && node.collapsible && !node.collapsed) {\n                expanded.push(getId(node.element.element));\n            }\n            queue.push.apply(queue, node.children);\n        }\n        return { focus: focus, selection: selection, expanded: expanded, scrollTop: this.scrollTop };\n    };\n    AsyncDataTree.prototype.dispose = function () {\n        lifecycle_1.dispose(this.disposables);\n    };\n    return AsyncDataTree;\n}());\nexports.AsyncDataTree = AsyncDataTree;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/asyncDataTree.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/browser/ui/tree/asyncDataTree.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ComposedTreeDelegate, IAbstractTreeOptions, IAbstractTreeOptionsUpdate } from 'vs/base/browser/ui/tree/abstractTree';\nimport { ObjectTree, IObjectTreeOptions } from 'vs/base/browser/ui/tree/objectTree';\nimport { IListVirtualDelegate, IIdentityProvider, IListDragAndDrop, IListDragOverReaction } from 'vs/base/browser/ui/list/list';\nimport { ITreeElement, ITreeNode, ITreeRenderer, ITreeEvent, ITreeMouseEvent, ITreeContextMenuEvent, ITreeSorter, ICollapseStateChangeEvent, IAsyncDataSource, ITreeDragAndDrop } from 'vs/base/browser/ui/tree/tree';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { timeout, CancelablePromise, createCancelablePromise } from 'vs/base/common/async';\nimport { IListStyles } from 'vs/base/browser/ui/list/listWidget';\nimport { Iterator } from 'vs/base/common/iterator';\nimport { IDragAndDropData } from 'vs/base/browser/dnd';\nimport { ElementsDragAndDropData } from 'vs/base/browser/ui/list/listView';\nimport { isPromiseCanceledError, onUnexpectedError } from 'vs/base/common/errors';\nimport { toggleClass } from 'vs/base/browser/dom';\nimport { values } from 'vs/base/common/map';\nimport { ScrollEvent } from 'vs/base/common/scrollable';\n\ninterface IAsyncDataTreeNode<TInput, T> {\n\telement: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly children: IAsyncDataTreeNode<TInput, T>[];\n\treadonly id?: string | null;\n\tloading: boolean;\n\thasChildren: boolean;\n\tstale: boolean;\n\tslow: boolean;\n}\n\ninterface IAsyncDataTreeNodeRequiredProps<TInput, T> extends Partial<IAsyncDataTreeNode<TInput, T>> {\n\treadonly element: TInput | T;\n\treadonly parent: IAsyncDataTreeNode<TInput, T> | null;\n\treadonly hasChildren: boolean;\n}\n\nfunction createAsyncDataTreeNode<TInput, T>(props: IAsyncDataTreeNodeRequiredProps<TInput, T>): IAsyncDataTreeNode<TInput, T> {\n\treturn {\n\t\t...props,\n\t\tchildren: [],\n\t\tloading: false,\n\t\tstale: true,\n\t\tslow: false\n\t};\n}\n\nfunction isAncestor<TInput, T>(ancestor: IAsyncDataTreeNode<TInput, T>, descendant: IAsyncDataTreeNode<TInput, T>): boolean {\n\tif (!descendant.parent) {\n\t\treturn false;\n\t} else if (descendant.parent === ancestor) {\n\t\treturn true;\n\t} else {\n\t\treturn isAncestor(ancestor, descendant.parent);\n\t}\n}\n\nfunction intersects<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, other: IAsyncDataTreeNode<TInput, T>): boolean {\n\treturn node === other || isAncestor(node, other) || isAncestor(other, node);\n}\n\ninterface IDataTreeListTemplateData<T> {\n\ttemplateData: T;\n}\n\nclass AsyncDataTreeNodeWrapper<TInput, T, TFilterData> implements ITreeNode<TInput | T, TFilterData> {\n\n\tget element(): T { return this.node.element!.element as T; }\n\tget parent(): ITreeNode<T, TFilterData> | undefined { return this.node.parent && new AsyncDataTreeNodeWrapper(this.node.parent); }\n\tget children(): ITreeNode<T, TFilterData>[] { return this.node.children.map(node => new AsyncDataTreeNodeWrapper(node)); }\n\tget depth(): number { return this.node.depth; }\n\tget visibleChildrenCount(): number { return this.node.visibleChildrenCount; }\n\tget visibleChildIndex(): number { return this.node.visibleChildIndex; }\n\tget collapsible(): boolean { return this.node.collapsible; }\n\tget collapsed(): boolean { return this.node.collapsed; }\n\tget visible(): boolean { return this.node.visible; }\n\tget filterData(): TFilterData | undefined { return this.node.filterData; }\n\n\tconstructor(private node: ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>) { }\n}\n\nclass DataTreeRenderer<TInput, T, TFilterData, TTemplateData> implements ITreeRenderer<IAsyncDataTreeNode<TInput, T>, TFilterData, IDataTreeListTemplateData<TTemplateData>> {\n\n\treadonly templateId: string;\n\tprivate renderedNodes = new Map<IAsyncDataTreeNode<TInput, T>, IDataTreeListTemplateData<TTemplateData>>();\n\tprivate disposables: IDisposable[] = [];\n\n\tconstructor(\n\t\tprivate renderer: ITreeRenderer<T, TFilterData, TTemplateData>,\n\t\treadonly onDidChangeTwistieState: Event<IAsyncDataTreeNode<TInput, T>>\n\t) {\n\t\tthis.templateId = renderer.templateId;\n\t}\n\n\trenderTemplate(container: HTMLElement): IDataTreeListTemplateData<TTemplateData> {\n\t\tconst templateData = this.renderer.renderTemplate(container);\n\t\treturn { templateData };\n\t}\n\n\trenderElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, dynamicHeightProbing?: boolean): void {\n\t\tthis.renderer.renderElement(new AsyncDataTreeNodeWrapper(node), index, templateData.templateData, dynamicHeightProbing);\n\t}\n\n\trenderTwistie(element: IAsyncDataTreeNode<TInput, T>, twistieElement: HTMLElement): boolean {\n\t\ttoggleClass(twistieElement, 'loading', element.slow);\n\t\treturn false;\n\t}\n\n\tdisposeElement(node: ITreeNode<IAsyncDataTreeNode<TInput, T>, TFilterData>, index: number, templateData: IDataTreeListTemplateData<TTemplateData>, dynamicHeightProbing?: boolean): void {\n\t\tif (this.renderer.disposeElement) {\n\t\t\tthis.renderer.disposeElement(new AsyncDataTreeNodeWrapper(node), index, templateData.templateData, dynamicHeightProbing);\n\t\t}\n\t}\n\n\tdisposeTemplate(templateData: IDataTreeListTemplateData<TTemplateData>): void {\n\t\tthis.renderer.disposeTemplate(templateData.templateData);\n\t}\n\n\tdispose(): void {\n\t\tthis.renderedNodes.clear();\n\t\tthis.disposables = dispose(this.disposables);\n\t}\n}\n\nfunction asTreeEvent<TInput, T>(e: ITreeEvent<IAsyncDataTreeNode<TInput, T>>): ITreeEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telements: e.elements.map(e => e.element as T)\n\t};\n}\n\nfunction asTreeMouseEvent<TInput, T>(e: ITreeMouseEvent<IAsyncDataTreeNode<TInput, T>>): ITreeMouseEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T\n\t};\n}\n\nfunction asTreeContextMenuEvent<TInput, T>(e: ITreeContextMenuEvent<IAsyncDataTreeNode<TInput, T>>): ITreeContextMenuEvent<T> {\n\treturn {\n\t\tbrowserEvent: e.browserEvent,\n\t\telement: e.element && e.element.element as T,\n\t\tanchor: e.anchor\n\t};\n}\n\nexport enum ChildrenResolutionReason {\n\tRefresh,\n\tExpand\n}\n\nexport interface IChildrenResolutionEvent<T> {\n\treadonly element: T | null;\n\treadonly reason: ChildrenResolutionReason;\n}\n\nfunction asAsyncDataTreeDragAndDropData<TInput, T>(data: IDragAndDropData): IDragAndDropData {\n\tif (data instanceof ElementsDragAndDropData) {\n\t\tconst nodes = (data as ElementsDragAndDropData<IAsyncDataTreeNode<TInput, T>>).elements;\n\t\treturn new ElementsDragAndDropData(nodes.map(node => node.element));\n\t}\n\n\treturn data;\n}\n\nclass AsyncDataTreeNodeListDragAndDrop<TInput, T> implements IListDragAndDrop<IAsyncDataTreeNode<TInput, T>> {\n\n\tconstructor(private dnd: ITreeDragAndDrop<T>) { }\n\n\tgetDragURI(node: IAsyncDataTreeNode<TInput, T>): string | null {\n\t\treturn this.dnd.getDragURI(node.element as T);\n\t}\n\n\tgetDragLabel(nodes: IAsyncDataTreeNode<TInput, T>[]): string | undefined {\n\t\tif (this.dnd.getDragLabel) {\n\t\t\treturn this.dnd.getDragLabel(nodes.map(node => node.element as T));\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tonDragStart(data: IDragAndDropData, originalEvent: DragEvent): void {\n\t\tif (this.dnd.onDragStart) {\n\t\t\tthis.dnd.onDragStart(asAsyncDataTreeDragAndDropData(data), originalEvent);\n\t\t}\n\t}\n\n\tonDragOver(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, originalEvent: DragEvent, raw = true): boolean | IListDragOverReaction {\n\t\treturn this.dnd.onDragOver(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, originalEvent);\n\t}\n\n\tdrop(data: IDragAndDropData, targetNode: IAsyncDataTreeNode<TInput, T> | undefined, targetIndex: number | undefined, originalEvent: DragEvent): void {\n\t\tthis.dnd.drop(asAsyncDataTreeDragAndDropData(data), targetNode && targetNode.element as T, targetIndex, originalEvent);\n\t}\n}\n\nfunction asObjectTreeOptions<TInput, T, TFilterData>(options?: IAsyncDataTreeOptions<T, TFilterData>): IObjectTreeOptions<IAsyncDataTreeNode<TInput, T>, TFilterData> | undefined {\n\treturn options && {\n\t\t...options,\n\t\tcollapseByDefault: true,\n\t\tidentityProvider: options.identityProvider && {\n\t\t\tgetId(el) {\n\t\t\t\treturn options.identityProvider!.getId(el.element as T);\n\t\t\t}\n\t\t},\n\t\tdnd: options.dnd && new AsyncDataTreeNodeListDragAndDrop(options.dnd),\n\t\tmultipleSelectionController: options.multipleSelectionController && {\n\t\t\tisSelectionSingleChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionSingleChangeEvent({ ...e, element: e.element } as any);\n\t\t\t},\n\t\t\tisSelectionRangeChangeEvent(e) {\n\t\t\t\treturn options.multipleSelectionController!.isSelectionRangeChangeEvent({ ...e, element: e.element } as any);\n\t\t\t}\n\t\t},\n\t\taccessibilityProvider: options.accessibilityProvider && {\n\t\t\tgetAriaLabel(e) {\n\t\t\t\treturn options.accessibilityProvider!.getAriaLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tfilter: options.filter && {\n\t\t\tfilter(e, parentVisibility) {\n\t\t\t\treturn options.filter!.filter(e.element as T, parentVisibility);\n\t\t\t}\n\t\t},\n\t\tkeyboardNavigationLabelProvider: options.keyboardNavigationLabelProvider && {\n\t\t\tgetKeyboardNavigationLabel(e) {\n\t\t\t\treturn options.keyboardNavigationLabelProvider!.getKeyboardNavigationLabel(e.element as T);\n\t\t\t}\n\t\t},\n\t\tsorter: undefined,\n\t\texpandOnlyOnTwistieClick: typeof options.expandOnlyOnTwistieClick === 'undefined' ? undefined : (\n\t\t\ttypeof options.expandOnlyOnTwistieClick !== 'function' ? options.expandOnlyOnTwistieClick : (\n\t\t\t\te => (options.expandOnlyOnTwistieClick as ((e: T) => boolean))(e.element as T)\n\t\t\t)\n\t\t),\n\t\tariaSetProvider: undefined\n\t};\n}\n\nfunction asTreeElement<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): ITreeElement<IAsyncDataTreeNode<TInput, T>> {\n\tlet collapsed: boolean | undefined;\n\n\tif (viewStateContext && viewStateContext.viewState.expanded && node.id) {\n\t\tcollapsed = viewStateContext.viewState.expanded.indexOf(node.id) === -1;\n\t}\n\n\treturn {\n\t\telement: node,\n\t\tchildren: node.hasChildren ? Iterator.map(Iterator.fromArray(node.children), child => asTreeElement(child, viewStateContext)) : [],\n\t\tcollapsible: node.hasChildren,\n\t\tcollapsed\n\t};\n}\n\nexport interface IAsyncDataTreeOptionsUpdate extends IAbstractTreeOptionsUpdate { }\n\nexport interface IAsyncDataTreeOptions<T, TFilterData = void> extends IAsyncDataTreeOptionsUpdate, IAbstractTreeOptions<T, TFilterData> {\n\tidentityProvider?: IIdentityProvider<T>;\n\tsorter?: ITreeSorter<T>;\n\tautoExpandSingleChildren?: boolean;\n}\n\nexport interface IAsyncDataTreeViewState {\n\treadonly focus?: string[];\n\treadonly selection?: string[];\n\treadonly expanded?: string[];\n\treadonly scrollTop?: number;\n}\n\ninterface IAsyncDataTreeViewStateContext<TInput, T> {\n\treadonly viewState: IAsyncDataTreeViewState;\n\treadonly selection: IAsyncDataTreeNode<TInput, T>[];\n\treadonly focus: IAsyncDataTreeNode<TInput, T>[];\n}\n\nfunction dfs<TInput, T>(node: IAsyncDataTreeNode<TInput, T>, fn: (node: IAsyncDataTreeNode<TInput, T>) => void): void {\n\tfn(node);\n\tnode.children.forEach(child => dfs(child, fn));\n}\n\nexport class AsyncDataTree<TInput, T, TFilterData = void> implements IDisposable {\n\n\tprivate readonly tree: ObjectTree<IAsyncDataTreeNode<TInput, T>, TFilterData>;\n\tprivate readonly root: IAsyncDataTreeNode<TInput, T>;\n\tprivate readonly nodes = new Map<null | T, IAsyncDataTreeNode<TInput, T>>();\n\tprivate readonly sorter?: ITreeSorter<T>;\n\n\tprivate readonly subTreeRefreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, Promise<void>>();\n\tprivate readonly refreshPromises = new Map<IAsyncDataTreeNode<TInput, T>, CancelablePromise<T[]>>();\n\n\tprivate readonly identityProvider?: IIdentityProvider<T>;\n\tprivate readonly autoExpandSingleChildren: boolean;\n\n\tprivate readonly _onDidRender = new Emitter<void>();\n\tprivate readonly _onDidChangeNodeSlowState = new Emitter<IAsyncDataTreeNode<TInput, T>>();\n\n\tprotected readonly disposables: IDisposable[] = [];\n\n\tget onDidScroll(): Event<ScrollEvent> { return this.tree.onDidScroll; }\n\n\tget onDidChangeFocus(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeFocus, asTreeEvent); }\n\tget onDidChangeSelection(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidChangeSelection, asTreeEvent); }\n\tget onDidOpen(): Event<ITreeEvent<T>> { return Event.map(this.tree.onDidOpen, asTreeEvent); }\n\n\tget onKeyDown(): Event<KeyboardEvent> { return this.tree.onKeyDown; }\n\tget onMouseClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseClick, asTreeMouseEvent); }\n\tget onMouseDblClick(): Event<ITreeMouseEvent<T>> { return Event.map(this.tree.onMouseDblClick, asTreeMouseEvent); }\n\tget onContextMenu(): Event<ITreeContextMenuEvent<T>> { return Event.map(this.tree.onContextMenu, asTreeContextMenuEvent); }\n\tget onDidFocus(): Event<void> { return this.tree.onDidFocus; }\n\tget onDidBlur(): Event<void> { return this.tree.onDidBlur; }\n\n\tget onDidUpdateOptions(): Event<IAsyncDataTreeOptionsUpdate> { return this.tree.onDidUpdateOptions; }\n\n\tget filterOnType(): boolean { return this.tree.filterOnType; }\n\tget openOnSingleClick(): boolean { return this.tree.openOnSingleClick; }\n\n\tget onDidDispose(): Event<void> { return this.tree.onDidDispose; }\n\n\tconstructor(\n\t\tcontainer: HTMLElement,\n\t\tdelegate: IListVirtualDelegate<T>,\n\t\trenderers: ITreeRenderer<any /* TODO@joao */, TFilterData, any>[],\n\t\tprivate dataSource: IAsyncDataSource<TInput, T>,\n\t\toptions: IAsyncDataTreeOptions<T, TFilterData> = {}\n\t) {\n\t\tthis.identityProvider = options.identityProvider;\n\t\tthis.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n\t\tthis.sorter = options.sorter;\n\n\t\tconst objectTreeDelegate = new ComposedTreeDelegate<TInput | T, IAsyncDataTreeNode<TInput, T>>(delegate);\n\t\tconst objectTreeRenderers = renderers.map(r => new DataTreeRenderer(r, this._onDidChangeNodeSlowState.event));\n\t\tconst objectTreeOptions = asObjectTreeOptions<TInput, T, TFilterData>(options) || {};\n\n\t\tthis.tree = new ObjectTree(container, objectTreeDelegate, objectTreeRenderers, objectTreeOptions);\n\n\t\tthis.root = createAsyncDataTreeNode({\n\t\t\telement: undefined!,\n\t\t\tparent: null,\n\t\t\thasChildren: true\n\t\t});\n\n\t\tif (this.identityProvider) {\n\t\t\tthis.root = {\n\t\t\t\t...this.root,\n\t\t\t\tid: null\n\t\t\t};\n\t\t}\n\n\t\tthis.nodes.set(null, this.root);\n\n\t\tthis.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);\n\t}\n\n\tupdateOptions(options: IAsyncDataTreeOptionsUpdate = {}): void {\n\t\tthis.tree.updateOptions(options);\n\t}\n\n\t// Widget\n\n\tgetHTMLElement(): HTMLElement {\n\t\treturn this.tree.getHTMLElement();\n\t}\n\n\tget contentHeight(): number {\n\t\treturn this.tree.contentHeight;\n\t}\n\n\tget onDidChangeContentHeight(): Event<number> {\n\t\treturn this.tree.onDidChangeContentHeight;\n\t}\n\n\tget scrollTop(): number {\n\t\treturn this.tree.scrollTop;\n\t}\n\n\tset scrollTop(scrollTop: number) {\n\t\tthis.tree.scrollTop = scrollTop;\n\t}\n\n\tget scrollHeight(): number {\n\t\treturn this.tree.scrollHeight;\n\t}\n\n\tget renderHeight(): number {\n\t\treturn this.tree.renderHeight;\n\t}\n\n\tget firstVisibleElement(): T {\n\t\treturn this.tree.firstVisibleElement!.element as T;\n\t}\n\n\tget lastVisibleElement(): T {\n\t\treturn this.tree.lastVisibleElement!.element as T;\n\t}\n\n\tdomFocus(): void {\n\t\tthis.tree.domFocus();\n\t}\n\n\tlayout(height?: number, width?: number): void {\n\t\tthis.tree.layout(height, width);\n\t}\n\n\tstyle(styles: IListStyles): void {\n\t\tthis.tree.style(styles);\n\t}\n\n\t// Model\n\n\tgetInput(): TInput | undefined {\n\t\treturn this.root.element as TInput;\n\t}\n\n\tasync setInput(input: TInput, viewState?: IAsyncDataTreeViewState): Promise<void> {\n\t\tthis.refreshPromises.forEach(promise => promise.cancel());\n\t\tthis.refreshPromises.clear();\n\n\t\tthis.root.element = input!;\n\n\t\tconst viewStateContext = viewState && { viewState, focus: [], selection: [] } as IAsyncDataTreeViewStateContext<TInput, T>;\n\n\t\tawait this.updateChildren(input, true, viewStateContext);\n\n\t\tif (viewStateContext) {\n\t\t\tthis.tree.setFocus(viewStateContext.focus);\n\t\t\tthis.tree.setSelection(viewStateContext.selection);\n\t\t}\n\n\t\tif (viewState && typeof viewState.scrollTop === 'number') {\n\t\t\tthis.scrollTop = viewState.scrollTop;\n\t\t}\n\t}\n\n\tasync updateChildren(element: TInput | T = this.root.element, recursive = true, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new Error('Tree input not set');\n\t\t}\n\n\t\tif (this.root.loading) {\n\t\t\tawait this.subTreeRefreshPromises.get(this.root)!;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tawait this.refreshAndRenderNode(this.getDataNode(element), recursive, ChildrenResolutionReason.Refresh, viewStateContext);\n\t}\n\n\tresort(element: TInput | T = this.root.element, recursive = true): void {\n\t\tthis.tree.resort(this.getDataNode(element), recursive);\n\t}\n\n\thasNode(element: TInput | T): boolean {\n\t\treturn element === this.root.element || this.nodes.has(element as T);\n\t}\n\n\t// View\n\n\trerender(element?: T): void {\n\t\tif (element === undefined) {\n\t\t\tthis.tree.rerender();\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.rerender(node);\n\t}\n\n\tupdateWidth(element: T): void {\n\t\tconst node = this.getDataNode(element);\n\t\tthis.tree.updateWidth(node);\n\t}\n\n\t// Tree\n\n\tgetNode(element: TInput | T = this.root.element): ITreeNode<TInput | T, TFilterData> {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getNode(dataNode === this.root ? null : dataNode);\n\t\treturn new AsyncDataTreeNodeWrapper<TInput, T, TFilterData>(node);\n\t}\n\n\tcollapse(element: T, recursive: boolean = false): boolean {\n\t\tconst node = this.getDataNode(element);\n\t\treturn this.tree.collapse(node === this.root ? null : node, recursive);\n\t}\n\n\tasync expand(element: T, recursive: boolean = false): Promise<boolean> {\n\t\tif (typeof this.root.element === 'undefined') {\n\t\t\tthrow new Error('Tree input not set');\n\t\t}\n\n\t\tif (this.root.loading) {\n\t\t\tawait this.subTreeRefreshPromises.get(this.root)!;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\tconst node = this.getDataNode(element);\n\n\t\tif (node !== this.root && !node.loading && !this.tree.isCollapsed(node)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst result = this.tree.expand(node === this.root ? null : node, recursive);\n\n\t\tif (node.loading) {\n\t\t\tawait this.subTreeRefreshPromises.get(node)!;\n\t\t\tawait Event.toPromise(this._onDidRender.event);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttoggleCollapsed(element: T, recursive: boolean = false): boolean {\n\t\treturn this.tree.toggleCollapsed(this.getDataNode(element), recursive);\n\t}\n\n\texpandAll(): void {\n\t\tthis.tree.expandAll();\n\t}\n\n\tcollapseAll(): void {\n\t\tthis.tree.collapseAll();\n\t}\n\n\tisCollapsible(element: T): boolean {\n\t\treturn this.tree.isCollapsible(this.getDataNode(element));\n\t}\n\n\tisCollapsed(element: T): boolean {\n\t\treturn this.tree.isCollapsed(this.getDataNode(element));\n\t}\n\n\ttoggleKeyboardNavigation(): void {\n\t\tthis.tree.toggleKeyboardNavigation();\n\t}\n\n\trefilter(): void {\n\t\tthis.tree.refilter();\n\t}\n\n\tsetSelection(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setSelection(nodes, browserEvent);\n\t}\n\n\tgetSelection(): T[] {\n\t\tconst nodes = this.tree.getSelection();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\tsetFocus(elements: T[], browserEvent?: UIEvent): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.setFocus(nodes, browserEvent);\n\t}\n\n\tfocusNext(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusNext(n, loop, browserEvent);\n\t}\n\n\tfocusPrevious(n = 1, loop = false, browserEvent?: UIEvent): void {\n\t\tthis.tree.focusPrevious(n, loop, browserEvent);\n\t}\n\n\tfocusNextPage(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusNextPage(browserEvent);\n\t}\n\n\tfocusPreviousPage(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusPreviousPage(browserEvent);\n\t}\n\n\tfocusLast(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusLast(browserEvent);\n\t}\n\n\tfocusFirst(browserEvent?: UIEvent): void {\n\t\tthis.tree.focusFirst(browserEvent);\n\t}\n\n\tgetFocus(): T[] {\n\t\tconst nodes = this.tree.getFocus();\n\t\treturn nodes.map(n => n!.element as T);\n\t}\n\n\topen(elements: T[]): void {\n\t\tconst nodes = elements.map(e => this.getDataNode(e));\n\t\tthis.tree.open(nodes);\n\t}\n\n\treveal(element: T, relativeTop?: number): void {\n\t\tthis.tree.reveal(this.getDataNode(element), relativeTop);\n\t}\n\n\tgetRelativeTop(element: T): number | null {\n\t\treturn this.tree.getRelativeTop(this.getDataNode(element));\n\t}\n\n\t// Tree navigation\n\n\tgetParentElement(element: T): TInput | T {\n\t\tconst node = this.tree.getParentElement(this.getDataNode(element));\n\t\treturn (node && node.element)!;\n\t}\n\n\tgetFirstElementChild(element: TInput | T = this.root.element): TInput | T | undefined {\n\t\tconst dataNode = this.getDataNode(element);\n\t\tconst node = this.tree.getFirstElementChild(dataNode === this.root ? null : dataNode);\n\t\treturn (node && node.element)!;\n\t}\n\n\t// Implementation\n\n\tprivate getDataNode(element: TInput | T): IAsyncDataTreeNode<TInput, T> {\n\t\tconst node: IAsyncDataTreeNode<TInput, T> | undefined = this.nodes.get((element === this.root.element ? null : element) as T);\n\n\t\tif (!node) {\n\t\t\tthrow new Error(`Data tree node not found: ${element}`);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate async refreshAndRenderNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, reason: ChildrenResolutionReason, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tawait this.refreshNode(node, recursive, viewStateContext);\n\t\tthis.render(node, viewStateContext);\n\n\t\tif (node !== this.root && this.autoExpandSingleChildren && reason === ChildrenResolutionReason.Expand) {\n\t\t\tconst treeNode = this.tree.getNode(node);\n\t\t\tconst visibleChildren = treeNode.children.filter(node => node.visible);\n\n\t\t\tif (visibleChildren.length === 1) {\n\t\t\t\tawait this.tree.expand(visibleChildren[0].element, false);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate async refreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tlet result: Promise<void> | undefined;\n\n\t\tthis.subTreeRefreshPromises.forEach((refreshPromise, refreshNode) => {\n\t\t\tif (!result && intersects(refreshNode, node)) {\n\t\t\t\tresult = refreshPromise.then(() => this.refreshNode(node, recursive, viewStateContext));\n\t\t\t}\n\t\t});\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this.doRefreshSubTree(node, recursive, viewStateContext);\n\t\tthis.subTreeRefreshPromises.set(node, result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} finally {\n\t\t\tthis.subTreeRefreshPromises.delete(node);\n\t\t}\n\t}\n\n\tprivate async doRefreshSubTree(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<void> {\n\t\tnode.loading = true;\n\n\t\ttry {\n\t\t\tconst childrenToRefresh = await this.doRefreshNode(node, recursive, viewStateContext);\n\t\t\tnode.stale = false;\n\n\t\t\tawait Promise.all(childrenToRefresh.map(child => this.doRefreshSubTree(child, recursive, viewStateContext)));\n\t\t} finally {\n\t\t\tnode.loading = false;\n\t\t}\n\t}\n\n\tprivate async doRefreshNode(node: IAsyncDataTreeNode<TInput, T>, recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): Promise<IAsyncDataTreeNode<TInput, T>[]> {\n\t\tnode.hasChildren = !!this.dataSource.hasChildren(node.element!);\n\n\t\tlet childrenPromise: Promise<T[]>;\n\n\t\tif (!node.hasChildren) {\n\t\t\tchildrenPromise = Promise.resolve([]);\n\t\t} else {\n\t\t\tconst slowTimeout = timeout(800);\n\n\t\t\tslowTimeout.then(() => {\n\t\t\t\tnode.slow = true;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}, _ => null);\n\n\t\t\tchildrenPromise = this.doGetChildren(node)\n\t\t\t\t.finally(() => slowTimeout.cancel());\n\t\t}\n\n\t\ttry {\n\t\t\tconst children = await childrenPromise;\n\t\t\treturn this.setChildren(node, children, recursive, viewStateContext);\n\t\t} catch (err) {\n\t\t\tif (node !== this.root) {\n\t\t\t\tthis.tree.collapse(node === this.root ? null : node);\n\t\t\t}\n\n\t\t\tif (isPromiseCanceledError(err)) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tif (node.slow) {\n\t\t\t\tnode.slow = false;\n\t\t\t\tthis._onDidChangeNodeSlowState.fire(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate doGetChildren(node: IAsyncDataTreeNode<TInput, T>): Promise<T[]> {\n\t\tlet result = this.refreshPromises.get(node);\n\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = createCancelablePromise(async () => {\n\t\t\tconst children = await this.dataSource.getChildren(node.element!);\n\n\t\t\tif (this.sorter) {\n\t\t\t\tchildren.sort(this.sorter.compare.bind(this.sorter));\n\t\t\t}\n\n\t\t\treturn children;\n\t\t});\n\n\t\tthis.refreshPromises.set(node, result);\n\n\t\treturn result.finally(() => this.refreshPromises.delete(node));\n\t}\n\n\tprivate _onDidChangeCollapseState({ node, deep }: ICollapseStateChangeEvent<IAsyncDataTreeNode<TInput, T>, any>): void {\n\t\tif (!node.collapsed && node.element.stale) {\n\t\t\tif (deep) {\n\t\t\t\tthis.collapse(node.element.element as T);\n\t\t\t} else {\n\t\t\t\tthis.refreshAndRenderNode(node.element, false, ChildrenResolutionReason.Expand)\n\t\t\t\t\t.catch(onUnexpectedError);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setChildren(node: IAsyncDataTreeNode<TInput, T>, childrenElements: T[], recursive: boolean, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): IAsyncDataTreeNode<TInput, T>[] {\n\t\t// perf: if the node was and still is a leaf, avoid all this hassle\n\t\tif (node.children.length === 0 && childrenElements.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst nodesToForget = new Map<T, IAsyncDataTreeNode<TInput, T>>();\n\t\tconst childrenTreeNodesById = new Map<string, ITreeNode<IAsyncDataTreeNode<TInput, T> | null, TFilterData>>();\n\n\t\tfor (const child of node.children) {\n\t\t\tnodesToForget.set(child.element as T, child);\n\n\t\t\tif (this.identityProvider) {\n\t\t\t\tchildrenTreeNodesById.set(child.id!, this.tree.getNode(child));\n\t\t\t}\n\t\t}\n\n\t\tconst childrenToRefresh: IAsyncDataTreeNode<TInput, T>[] = [];\n\n\t\tconst children = childrenElements.map<IAsyncDataTreeNode<TInput, T>>(element => {\n\t\t\tif (!this.identityProvider) {\n\t\t\t\treturn createAsyncDataTreeNode({\n\t\t\t\t\telement,\n\t\t\t\t\tparent: node,\n\t\t\t\t\thasChildren: !!this.dataSource.hasChildren(element)\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst id = this.identityProvider.getId(element).toString();\n\t\t\tconst childNode = childrenTreeNodesById.get(id);\n\n\t\t\tif (childNode) {\n\t\t\t\tconst asyncDataTreeNode = childNode.element!;\n\n\t\t\t\tnodesToForget.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.delete(asyncDataTreeNode.element as T);\n\t\t\t\tthis.nodes.set(element, asyncDataTreeNode);\n\n\t\t\t\tasyncDataTreeNode.element = element;\n\t\t\t\tasyncDataTreeNode.hasChildren = !!this.dataSource.hasChildren(element);\n\n\t\t\t\tif (recursive) {\n\t\t\t\t\tif (childNode.collapsed) {\n\t\t\t\t\t\tdfs(asyncDataTreeNode, node => node.stale = true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildrenToRefresh.push(asyncDataTreeNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn asyncDataTreeNode;\n\t\t\t}\n\n\t\t\tconst childAsyncDataTreeNode = createAsyncDataTreeNode({\n\t\t\t\telement,\n\t\t\t\tparent: node,\n\t\t\t\tid,\n\t\t\t\thasChildren: !!this.dataSource.hasChildren(element)\n\t\t\t});\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.focus && viewStateContext.viewState.focus.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.focus.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.selection && viewStateContext.viewState.selection.indexOf(id) > -1) {\n\t\t\t\tviewStateContext.selection.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\tif (viewStateContext && viewStateContext.viewState.expanded && viewStateContext.viewState.expanded.indexOf(id) > -1) {\n\t\t\t\tchildrenToRefresh.push(childAsyncDataTreeNode);\n\t\t\t}\n\n\t\t\treturn childAsyncDataTreeNode;\n\t\t});\n\n\t\tfor (const node of values(nodesToForget)) {\n\t\t\tdfs(node, node => this.nodes.delete(node.element as T));\n\t\t}\n\n\t\tfor (const child of children) {\n\t\t\tthis.nodes.set(child.element as T, child);\n\t\t}\n\n\t\tnode.children.splice(0, node.children.length, ...children);\n\n\t\treturn childrenToRefresh;\n\t}\n\n\tprivate render(node: IAsyncDataTreeNode<TInput, T>, viewStateContext?: IAsyncDataTreeViewStateContext<TInput, T>): void {\n\t\tconst children = node.children.map(c => asTreeElement(c, viewStateContext));\n\t\tthis.tree.setChildren(node === this.root ? null : node, children);\n\t\tthis._onDidRender.fire();\n\t}\n\n\t// view state\n\n\tgetViewState(): IAsyncDataTreeViewState {\n\t\tif (!this.identityProvider) {\n\t\t\tthrow new Error('Can\\'t get tree view state without an identity provider');\n\t\t}\n\n\t\tconst getId = (element: T) => this.identityProvider!.getId(element).toString();\n\t\tconst focus = this.getFocus().map(getId);\n\t\tconst selection = this.getSelection().map(getId);\n\n\t\tconst expanded: string[] = [];\n\t\tconst root = this.tree.getNode();\n\t\tconst queue = [root];\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst node = queue.shift()!;\n\n\t\t\tif (node !== root && node.collapsible && !node.collapsed) {\n\t\t\t\texpanded.push(getId(node.element!.element as T));\n\t\t\t}\n\n\t\t\tqueue.push(...node.children);\n\t\t}\n\n\t\treturn { focus, selection, expanded, scrollTop: this.scrollTop };\n\t}\n\n\tdispose(): void {\n\t\tdispose(this.disposables);\n\t}\n}\n"]}]}