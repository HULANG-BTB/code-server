{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDocumentSaveParticipant.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostDocumentSaveParticipant.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/uri\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/workbench/api/node/extHostTypes\", \"vs/workbench/api/node/extHostTypeConverters\", \"vs/base/common/linkedList\"], function (require, exports, uri_1, async_1, errors_1, extHostTypes_1, extHostTypeConverters_1, linkedList_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class ExtHostDocumentSaveParticipant {\n        constructor(_logService, _documents, _mainThreadEditors, _thresholds = { timeout: 1500, errors: 3 }) {\n            this._logService = _logService;\n            this._documents = _documents;\n            this._mainThreadEditors = _mainThreadEditors;\n            this._thresholds = _thresholds;\n            this._callbacks = new linkedList_1.LinkedList();\n            this._badListeners = new WeakMap();\n            //\n        }\n        dispose() {\n            this._callbacks.clear();\n        }\n        getOnWillSaveTextDocumentEvent(extension) {\n            return (listener, thisArg, disposables) => {\n                const remove = this._callbacks.push([listener, thisArg, extension]);\n                const result = { dispose: remove };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        $participateInSave(data, reason) {\n            const resource = uri_1.URI.revive(data);\n            const entries = this._callbacks.toArray();\n            let didTimeout = false;\n            const didTimeoutHandle = setTimeout(() => didTimeout = true, this._thresholds.timeout);\n            const promise = async_1.sequence(entries.map(listener => {\n                return () => {\n                    if (didTimeout) {\n                        // timeout - no more listeners\n                        return Promise.resolve();\n                    }\n                    const document = this._documents.getDocument(resource);\n                    return this._deliverEventAsyncAndBlameBadListeners(listener, { document, reason: extHostTypeConverters_1.TextDocumentSaveReason.to(reason) });\n                };\n            }));\n            return promise.finally(() => clearTimeout(didTimeoutHandle));\n        }\n        _deliverEventAsyncAndBlameBadListeners([listener, thisArg, extension], stubEvent) {\n            const errors = this._badListeners.get(listener);\n            if (typeof errors === 'number' && errors > this._thresholds.errors) {\n                // bad listener - ignore\n                return Promise.resolve(false);\n            }\n            return this._deliverEventAsync(extension, listener, thisArg, stubEvent).then(() => {\n                // don't send result across the wire\n                return true;\n            }, err => {\n                this._logService.error(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' threw ERROR`);\n                this._logService.error(err);\n                if (!(err instanceof Error) || err.message !== 'concurrent_edits') {\n                    const errors = this._badListeners.get(listener);\n                    this._badListeners.set(listener, !errors ? 1 : errors + 1);\n                    if (typeof errors === 'number' && errors > this._thresholds.errors) {\n                        this._logService.info(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' will now be IGNORED because of timeouts and/or errors`);\n                    }\n                }\n                return false;\n            });\n        }\n        _deliverEventAsync(extension, listener, thisArg, stubEvent) {\n            const promises = [];\n            const t1 = Date.now();\n            const { document, reason } = stubEvent;\n            const { version } = document;\n            const event = Object.freeze({\n                document,\n                reason,\n                waitUntil(p) {\n                    if (Object.isFrozen(promises)) {\n                        throw errors_1.illegalState('waitUntil can not be called async');\n                    }\n                    promises.push(Promise.resolve(p));\n                }\n            });\n            try {\n                // fire event\n                listener.apply(thisArg, [event]);\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n            // freeze promises after event call\n            Object.freeze(promises);\n            return new Promise((resolve, reject) => {\n                // join on all listener promises, reject after timeout\n                const handle = setTimeout(() => reject(new Error('timeout')), this._thresholds.timeout);\n                return Promise.all(promises).then(edits => {\n                    this._logService.debug(`onWillSaveTextDocument-listener from extension '${extension.identifier.value}' finished after ${(Date.now() - t1)}ms`);\n                    clearTimeout(handle);\n                    resolve(edits);\n                }).catch(err => {\n                    clearTimeout(handle);\n                    reject(err);\n                });\n            }).then(values => {\n                const resourceEdit = {\n                    resource: document.uri,\n                    edits: []\n                };\n                for (const value of values) {\n                    if (Array.isArray(value) && value.every(e => e instanceof extHostTypes_1.TextEdit)) {\n                        for (const { newText, newEol, range } of value) {\n                            resourceEdit.edits.push({\n                                range: range && extHostTypeConverters_1.Range.from(range),\n                                text: newText,\n                                eol: extHostTypeConverters_1.EndOfLine.from(newEol)\n                            });\n                        }\n                    }\n                }\n                // apply edits if any and if document\n                // didn't change somehow in the meantime\n                if (resourceEdit.edits.length === 0) {\n                    return undefined;\n                }\n                if (version === document.version) {\n                    return this._mainThreadEditors.$tryApplyWorkspaceEdit({ edits: [resourceEdit] });\n                }\n                return Promise.reject(new Error('concurrent_edits'));\n            });\n        }\n    }\n    exports.ExtHostDocumentSaveParticipant = ExtHostDocumentSaveParticipant;\n});\n",null]}