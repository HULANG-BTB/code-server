{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/electron-browser/mainThreadWebview.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/electron-browser/mainThreadWebview.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/base/common/map\", \"vs/base/common/uri\", \"vs/editor/browser/services/codeEditorService\", \"vs/nls\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/opener/common/opener\", \"vs/platform/telemetry/common/telemetry\", \"vs/workbench/api/common/extHost.protocol\", \"vs/workbench/api/common/shared/editor\", \"vs/workbench/contrib/codeinset/electron-browser/codeInset.contribution\", \"vs/workbench/contrib/webview/electron-browser/webviewEditor\", \"vs/workbench/contrib/webview/electron-browser/webviewEditorInput\", \"vs/workbench/contrib/webview/electron-browser/webviewEditorService\", \"vs/workbench/contrib/webview/electron-browser/webviewElement\", \"vs/workbench/services/editor/common/editorGroupsService\", \"vs/workbench/services/editor/common/editorService\", \"vs/workbench/services/extensions/common/extensions\", \"vs/workbench/services/layout/browser/layoutService\", \"../common/extHostCustomers\"], function (require, exports, errors_1, lifecycle_1, map, uri_1, codeEditorService_1, nls_1, instantiation_1, lifecycle_2, opener_1, telemetry_1, extHost_protocol_1, editor_1, codeInset_contribution_1, webviewEditor_1, webviewEditorInput_1, webviewEditorService_1, webviewElement_1, editorGroupsService_1, editorService_1, extensions_1, layoutService_1, extHostCustomers_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var MainThreadWebviews_1;\n    \"use strict\";\n    let MainThreadWebviews = MainThreadWebviews_1 = class MainThreadWebviews extends lifecycle_1.Disposable {\n        constructor(context, lifecycleService, extensionService, _editorGroupService, _editorService, _webviewService, _openerService, _telemetryService, _instantiationService, _codeEditorService, _layoutService) {\n            super();\n            this._editorGroupService = _editorGroupService;\n            this._editorService = _editorService;\n            this._webviewService = _webviewService;\n            this._openerService = _openerService;\n            this._telemetryService = _telemetryService;\n            this._instantiationService = _instantiationService;\n            this._codeEditorService = _codeEditorService;\n            this._layoutService = _layoutService;\n            this._webviews = new Map();\n            this._webviewsElements = new Map();\n            this._revivers = new Map();\n            this._activeWebview = undefined;\n            this._proxy = context.getProxy(extHost_protocol_1.ExtHostContext.ExtHostWebviews);\n            _editorService.onDidActiveEditorChange(this.onActiveEditorChanged, this, this._toDispose);\n            _editorService.onDidVisibleEditorsChange(this.onVisibleEditorsChanged, this, this._toDispose);\n            // This reviver's only job is to activate webview extensions\n            // This should trigger the real reviver to be registered from the extension host side.\n            this._toDispose.push(_webviewService.registerReviver({\n                canRevive: (webview) => {\n                    const viewType = webview.state.viewType;\n                    if (viewType) {\n                        extensionService.activateByEvent(`onWebviewPanel:${viewType}`);\n                    }\n                    return false;\n                },\n                reviveWebview: () => { throw new Error('not implemented'); }\n            }));\n            lifecycleService.onBeforeShutdown(e => {\n                e.veto(this._onBeforeShutdown());\n            }, this, this._toDispose);\n        }\n        $createWebviewPanel(handle, viewType, title, showOptions, options, extensionId, extensionLocation) {\n            const mainThreadShowOptions = Object.create(null);\n            if (showOptions) {\n                mainThreadShowOptions.preserveFocus = !!showOptions.preserveFocus;\n                mainThreadShowOptions.group = editor_1.viewColumnToEditorGroup(this._editorGroupService, showOptions.viewColumn);\n            }\n            const webview = this._webviewService.createWebview(this.getInternalWebviewId(viewType), title, mainThreadShowOptions, reviveWebviewOptions(options), {\n                location: uri_1.URI.revive(extensionLocation),\n                id: extensionId\n            }, this.createWebviewEventDelegate(handle));\n            webview.state = {\n                viewType: viewType,\n                state: undefined\n            };\n            this._webviews.set(handle, webview);\n            this._activeWebview = handle;\n            /* __GDPR__\n                \"webviews:createWebviewPanel\" : {\n                    \"extensionId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this._telemetryService.publicLog('webviews:createWebviewPanel', { extensionId: extensionId.value });\n        }\n        $createWebviewCodeInset(handle, symbolId, options, extensionId, extensionLocation) {\n            // todo@joh main is for the lack of a code-inset service\n            // which we maybe wanna have... this is how it now works\n            // 1) create webview element\n            // 2) find the code inset controller that request it\n            // 3) let the controller adopt the widget\n            // 4) continue to forward messages to the webview\n            const webview = this._instantiationService.createInstance(webviewElement_1.WebviewElement, this._layoutService.getContainer(layoutService_1.Parts.EDITOR_PART), {\n                extension: {\n                    location: uri_1.URI.revive(extensionLocation),\n                    id: extensionId\n                },\n                enableFindWidget: false,\n            }, {\n                allowScripts: options.enableScripts,\n            });\n            let found = false;\n            for (const editor of this._codeEditorService.listCodeEditors()) {\n                const ctrl = codeInset_contribution_1.CodeInsetController.get(editor);\n                if (ctrl && ctrl.acceptWebview(symbolId, webview)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                webview.dispose();\n                return;\n            }\n            // this will leak... the adopted webview will be disposed by the\n            // code inset controller. we might need a dispose-event here so that\n            // we can clean up things.\n            this._webviewsElements.set(handle, webview);\n        }\n        $disposeWebview(handle) {\n            const webview = this.getWebview(handle);\n            webview.dispose();\n        }\n        $setTitle(handle, value) {\n            const webview = this.getWebview(handle);\n            webview.setName(value);\n        }\n        $setIconPath(handle, value) {\n            const webview = this.getWebview(handle);\n            webview.iconPath = reviveWebviewIcon(value);\n        }\n        $setHtml(handle, value) {\n            if (typeof handle === 'number') {\n                this.getWebviewElement(handle).contents = value;\n            }\n            else {\n                const webview = this.getWebview(handle);\n                webview.html = value;\n            }\n        }\n        $setOptions(handle, options) {\n            if (typeof handle === 'number') {\n                this.getWebviewElement(handle).options = reviveWebviewOptions(options /*todo@mat */);\n            }\n            else {\n                const webview = this.getWebview(handle);\n                webview.setOptions(reviveWebviewOptions(options /*todo@mat */));\n            }\n        }\n        $reveal(handle, showOptions) {\n            const webview = this.getWebview(handle);\n            if (webview.isDisposed()) {\n                return;\n            }\n            const targetGroup = this._editorGroupService.getGroup(editor_1.viewColumnToEditorGroup(this._editorGroupService, showOptions.viewColumn)) || this._editorGroupService.getGroup(webview.group || 0);\n            if (targetGroup) {\n                this._webviewService.revealWebview(webview, targetGroup, !!showOptions.preserveFocus);\n            }\n        }\n        $postMessage(handle, message) {\n            if (typeof handle === 'number') {\n                this.getWebviewElement(handle).sendMessage(message);\n                return Promise.resolve(true);\n            }\n            else {\n                const webview = this.getWebview(handle);\n                const editors = this._editorService.visibleControls\n                    .filter(e => e instanceof webviewEditor_1.WebviewEditor)\n                    .map(e => e)\n                    .filter(e => e.input.matches(webview));\n                for (const editor of editors) {\n                    editor.sendMessage(message);\n                }\n                return Promise.resolve(editors.length > 0);\n            }\n        }\n        $registerSerializer(viewType) {\n            if (this._revivers.has(viewType)) {\n                throw new Error(`Reviver for ${viewType} already registered`);\n            }\n            this._revivers.set(viewType, this._webviewService.registerReviver({\n                canRevive: (webview) => {\n                    return webview.state && webview.state.viewType === viewType;\n                },\n                reviveWebview: (webview) => __awaiter(this, void 0, void 0, function* () {\n                    const viewType = webview.state.viewType;\n                    const handle = 'revival-' + MainThreadWebviews_1.revivalPool++;\n                    this._webviews.set(handle, webview);\n                    webview._events = this.createWebviewEventDelegate(handle);\n                    let state = undefined;\n                    if (webview.state.state) {\n                        try {\n                            state = JSON.parse(webview.state.state);\n                        }\n                        catch (_a) {\n                            // noop\n                        }\n                    }\n                    try {\n                        yield this._proxy.$deserializeWebviewPanel(handle, viewType, webview.getTitle(), state, editor_1.editorGroupToViewColumn(this._editorGroupService, webview.group || 0), webview.options);\n                    }\n                    catch (error) {\n                        errors_1.onUnexpectedError(error);\n                        webview.html = MainThreadWebviews_1.getDeserializationFailedContents(viewType);\n                    }\n                })\n            }));\n        }\n        $unregisterSerializer(viewType) {\n            const reviver = this._revivers.get(viewType);\n            if (!reviver) {\n                throw new Error(`No reviver for ${viewType} registered`);\n            }\n            reviver.dispose();\n            this._revivers.delete(viewType);\n        }\n        getInternalWebviewId(viewType) {\n            return `mainThreadWebview-${viewType}`;\n        }\n        _onBeforeShutdown() {\n            this._webviews.forEach((webview) => {\n                if (!webview.isDisposed() && webview.state && this._revivers.has(webview.state.viewType)) {\n                    webview.state.state = webview.webviewState;\n                }\n            });\n            return false; // Don't veto shutdown\n        }\n        createWebviewEventDelegate(handle) {\n            return {\n                onDidClickLink: (uri) => this.onDidClickLink(handle, uri),\n                onMessage: (message) => this._proxy.$onMessage(handle, message),\n                onDispose: () => {\n                    this._proxy.$onDidDisposeWebviewPanel(handle).finally(() => {\n                        this._webviews.delete(handle);\n                    });\n                }\n            };\n        }\n        onActiveEditorChanged() {\n            const activeEditor = this._editorService.activeControl;\n            let newActiveWebview = undefined;\n            if (activeEditor && activeEditor.input instanceof webviewEditorInput_1.WebviewEditorInput) {\n                for (const handle of map.keys(this._webviews)) {\n                    const input = this._webviews.get(handle);\n                    if (input.matches(activeEditor.input)) {\n                        newActiveWebview = { input, handle };\n                        break;\n                    }\n                }\n            }\n            if (newActiveWebview && newActiveWebview.handle === this._activeWebview) {\n                // Webview itself unchanged but position may have changed\n                this._proxy.$onDidChangeWebviewPanelViewState(newActiveWebview.handle, {\n                    active: true,\n                    visible: true,\n                    position: editor_1.editorGroupToViewColumn(this._editorGroupService, newActiveWebview.input.group || 0)\n                });\n                return;\n            }\n            // Broadcast view state update for currently active\n            if (typeof this._activeWebview !== 'undefined') {\n                const oldActiveWebview = this._webviews.get(this._activeWebview);\n                if (oldActiveWebview) {\n                    this._proxy.$onDidChangeWebviewPanelViewState(this._activeWebview, {\n                        active: false,\n                        visible: this._editorService.visibleControls.some(editor => !!editor.input && editor.input.matches(oldActiveWebview)),\n                        position: editor_1.editorGroupToViewColumn(this._editorGroupService, oldActiveWebview.group || 0),\n                    });\n                }\n            }\n            // Then for newly active\n            if (newActiveWebview) {\n                this._proxy.$onDidChangeWebviewPanelViewState(newActiveWebview.handle, {\n                    active: true,\n                    visible: true,\n                    position: editor_1.editorGroupToViewColumn(this._editorGroupService, activeEditor ? activeEditor.group : editorService_1.ACTIVE_GROUP),\n                });\n                this._activeWebview = newActiveWebview.handle;\n            }\n            else {\n                this._activeWebview = undefined;\n            }\n        }\n        onVisibleEditorsChanged() {\n            this._webviews.forEach((input, handle) => {\n                for (const workbenchEditor of this._editorService.visibleControls) {\n                    if (workbenchEditor.input && workbenchEditor.input.matches(input)) {\n                        const editorPosition = editor_1.editorGroupToViewColumn(this._editorGroupService, workbenchEditor.group);\n                        input.updateGroup(workbenchEditor.group.id);\n                        this._proxy.$onDidChangeWebviewPanelViewState(handle, {\n                            active: handle === this._activeWebview,\n                            visible: true,\n                            position: editorPosition\n                        });\n                        break;\n                    }\n                }\n            });\n        }\n        onDidClickLink(handle, link) {\n            if (!link) {\n                return;\n            }\n            const webview = this.getWebview(handle);\n            const enableCommandUris = webview.options.enableCommandUris;\n            if (MainThreadWebviews_1.standardSupportedLinkSchemes.indexOf(link.scheme) >= 0 || enableCommandUris && link.scheme === 'command') {\n                this._openerService.open(link);\n            }\n        }\n        getWebview(handle) {\n            const webview = this._webviews.get(handle);\n            if (!webview) {\n                throw new Error('Unknown webview handle:' + handle);\n            }\n            return webview;\n        }\n        getWebviewElement(handle) {\n            const webview = this._webviewsElements.get(handle);\n            if (!webview) {\n                throw new Error('Unknown webview handle:' + handle);\n            }\n            return webview;\n        }\n        static getDeserializationFailedContents(viewType) {\n            return `<!DOCTYPE html>\n\t\t<html>\n\t\t\t<head>\n\t\t\t\t<base href=\"https://code.visualstudio.com/raw/\">\n\t\t\t\t<meta http-equiv=\"Content-type\" content=\"text/html;charset=UTF-8\">\n\t\t\t\t<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; img-src https: data:; media-src https:; script-src 'none'; style-src vscode-core-resource: https: 'unsafe-inline'; child-src 'none'; frame-src 'none';\">\n\t\t\t</head>\n\t\t\t<body>${nls_1.localize('errorMessage', \"An error occurred while restoring view:{0}\", viewType)}</body>\n\t\t</html>`;\n        }\n    };\n    MainThreadWebviews.standardSupportedLinkSchemes = ['http', 'https', 'mailto'];\n    MainThreadWebviews.revivalPool = 0;\n    MainThreadWebviews = MainThreadWebviews_1 = __decorate([\n        extHostCustomers_1.extHostNamedCustomer(extHost_protocol_1.MainContext.MainThreadWebviews),\n        __param(1, lifecycle_2.ILifecycleService),\n        __param(2, extensions_1.IExtensionService),\n        __param(3, editorGroupsService_1.IEditorGroupsService),\n        __param(4, editorService_1.IEditorService),\n        __param(5, webviewEditorService_1.IWebviewEditorService),\n        __param(6, opener_1.IOpenerService),\n        __param(7, telemetry_1.ITelemetryService),\n        __param(8, instantiation_1.IInstantiationService),\n        __param(9, codeEditorService_1.ICodeEditorService),\n        __param(10, layoutService_1.IWorkbenchLayoutService)\n    ], MainThreadWebviews);\n    exports.MainThreadWebviews = MainThreadWebviews;\n    function reviveWebviewOptions(options) {\n        return Object.assign({}, options, { localResourceRoots: Array.isArray(options.localResourceRoots) ? options.localResourceRoots.map(uri_1.URI.revive) : undefined });\n    }\n    function reviveWebviewIcon(value) {\n        if (!value) {\n            return undefined;\n        }\n        return {\n            light: uri_1.URI.revive(value.light),\n            dark: uri_1.URI.revive(value.dark)\n        };\n    }\n});\n",null]}