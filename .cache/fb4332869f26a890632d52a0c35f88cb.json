{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugContentProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugContentProvider.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar nls_1 = require(\"vs/nls\");\nvar mime_1 = require(\"vs/base/common/mime\");\nvar modelService_1 = require(\"vs/editor/common/services/modelService\");\nvar modeService_1 = require(\"vs/editor/common/services/modeService\");\nvar resolverService_1 = require(\"vs/editor/common/services/resolverService\");\nvar debug_1 = require(\"vs/workbench/contrib/debug/common/debug\");\nvar debugSource_1 = require(\"vs/workbench/contrib/debug/common/debugSource\");\nvar editorWorkerService_1 = require(\"vs/editor/common/services/editorWorkerService\");\nvar editOperation_1 = require(\"vs/editor/common/core/editOperation\");\nvar range_1 = require(\"vs/editor/common/core/range\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\n/**\n * Debug URI format\n *\n * a debug URI represents a Source object and the debug session where the Source comes from.\n *\n *       debug:arbitrary_path?session=123e4567-e89b-12d3-a456-426655440000&ref=1016\n *       \\___/ \\____________/ \\__________________________________________/ \\______/\n *         |          |                             |                          |\n *      scheme   source.path                    session id            source.reference\n *\n * the arbitrary_path and the session id are encoded with 'encodeURIComponent'\n *\n */\nvar DebugContentProvider = /** @class */ (function () {\n    function DebugContentProvider(textModelResolverService, debugService, modelService, modeService, editorWorkerService) {\n        this.debugService = debugService;\n        this.modelService = modelService;\n        this.modeService = modeService;\n        this.editorWorkerService = editorWorkerService;\n        this.pendingUpdates = new Map();\n        textModelResolverService.registerTextModelContentProvider(debug_1.DEBUG_SCHEME, this);\n        DebugContentProvider.INSTANCE = this;\n    }\n    DebugContentProvider.prototype.dispose = function () {\n        this.pendingUpdates.forEach(function (cancellationSource) { return cancellationSource.dispose(); });\n    };\n    DebugContentProvider.prototype.provideTextContent = function (resource) {\n        return this.createOrUpdateContentModel(resource, true);\n    };\n    /**\n     * Reload the model content of the given resource.\n     * If there is no model for the given resource, this method does nothing.\n     */\n    DebugContentProvider.refreshDebugContent = function (resource) {\n        if (DebugContentProvider.INSTANCE) {\n            DebugContentProvider.INSTANCE.createOrUpdateContentModel(resource, false);\n        }\n    };\n    /**\n     * Create or reload the model content of the given resource.\n     */\n    DebugContentProvider.prototype.createOrUpdateContentModel = function (resource, createIfNotExists) {\n        var _this = this;\n        var model = this.modelService.getModel(resource);\n        if (!model && !createIfNotExists) {\n            // nothing to do\n            return null;\n        }\n        var session;\n        if (resource.query) {\n            var data = debugSource_1.Source.getEncodedDebugData(resource);\n            session = this.debugService.getModel().getSession(data.sessionId);\n        }\n        if (!session) {\n            // fallback: use focused session\n            session = this.debugService.getViewModel().focusedSession;\n        }\n        if (!session) {\n            return Promise.reject(new Error(nls_1.localize('unable', \"Unable to resolve the resource without a debug session\")));\n        }\n        var createErrModel = function (errMsg) {\n            _this.debugService.sourceIsNotAvailable(resource);\n            var languageSelection = _this.modeService.create(mime_1.MIME_TEXT);\n            var message = errMsg\n                ? nls_1.localize('canNotResolveSourceWithError', \"Could not load source '{0}': {1}.\", resource.path, errMsg)\n                : nls_1.localize('canNotResolveSource', \"Could not load source '{0}'.\", resource.path);\n            return _this.modelService.createModel(message, languageSelection, resource);\n        };\n        return session.loadSource(resource).then(function (response) {\n            if (response && response.body) {\n                if (model) {\n                    var newContent = response.body.content;\n                    // cancel and dispose an existing update\n                    var cancellationSource = _this.pendingUpdates.get(model.id);\n                    if (cancellationSource) {\n                        cancellationSource.cancel();\n                    }\n                    // create and keep update token\n                    var myToken_1 = new cancellation_1.CancellationTokenSource();\n                    _this.pendingUpdates.set(model.id, myToken_1);\n                    // update text model\n                    return _this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: newContent, range: model.getFullModelRange() }]).then(function (edits) {\n                        // remove token\n                        _this.pendingUpdates.delete(model.id);\n                        if (!myToken_1.token.isCancellationRequested && edits && edits.length > 0) {\n                            // use the evil-edit as these models show in readonly-editor only\n                            model.applyEdits(edits.map(function (edit) { return editOperation_1.EditOperation.replace(range_1.Range.lift(edit.range), edit.text); }));\n                        }\n                        return model;\n                    });\n                }\n                else {\n                    // create text model\n                    var mime = response.body.mimeType || mime_1.guessMimeTypes(resource.path)[0];\n                    var languageSelection = _this.modeService.create(mime);\n                    return _this.modelService.createModel(response.body.content, languageSelection, resource);\n                }\n            }\n            return createErrModel();\n        }, function (err) { return createErrModel(err.message); });\n    };\n    DebugContentProvider = tslib_1.__decorate([\n        tslib_1.__param(0, resolverService_1.ITextModelService),\n        tslib_1.__param(1, debug_1.IDebugService),\n        tslib_1.__param(2, modelService_1.IModelService),\n        tslib_1.__param(3, modeService_1.IModeService),\n        tslib_1.__param(4, editorWorkerService_1.IEditorWorkerService)\n    ], DebugContentProvider);\n    return DebugContentProvider;\n}());\nexports.DebugContentProvider = DebugContentProvider;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugContentProvider.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/debug/common/debugContentProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI as uri } from 'vs/base/common/uri';\nimport { localize } from 'vs/nls';\nimport { guessMimeTypes, MIME_TEXT } from 'vs/base/common/mime';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { IModeService } from 'vs/editor/common/services/modeService';\nimport { ITextModelService, ITextModelContentProvider } from 'vs/editor/common/services/resolverService';\nimport { IWorkbenchContribution } from 'vs/workbench/common/contributions';\nimport { DEBUG_SCHEME, IDebugService, IDebugSession } from 'vs/workbench/contrib/debug/common/debug';\nimport { Source } from 'vs/workbench/contrib/debug/common/debugSource';\nimport { IEditorWorkerService } from 'vs/editor/common/services/editorWorkerService';\nimport { EditOperation } from 'vs/editor/common/core/editOperation';\nimport { Range } from 'vs/editor/common/core/range';\nimport { CancellationTokenSource } from 'vs/base/common/cancellation';\n\n/**\n * Debug URI format\n *\n * a debug URI represents a Source object and the debug session where the Source comes from.\n *\n *       debug:arbitrary_path?session=123e4567-e89b-12d3-a456-426655440000&ref=1016\n *       \\___/ \\____________/ \\__________________________________________/ \\______/\n *         |          |                             |                          |\n *      scheme   source.path                    session id            source.reference\n *\n * the arbitrary_path and the session id are encoded with 'encodeURIComponent'\n *\n */\nexport class DebugContentProvider implements IWorkbenchContribution, ITextModelContentProvider {\n\n\tprivate static INSTANCE: DebugContentProvider;\n\n\tprivate readonly pendingUpdates = new Map<string, CancellationTokenSource>();\n\n\tconstructor(\n\t\t@ITextModelService textModelResolverService: ITextModelService,\n\t\t@IDebugService private readonly debugService: IDebugService,\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@IModeService private readonly modeService: IModeService,\n\t\t@IEditorWorkerService private readonly editorWorkerService: IEditorWorkerService\n\t) {\n\t\ttextModelResolverService.registerTextModelContentProvider(DEBUG_SCHEME, this);\n\t\tDebugContentProvider.INSTANCE = this;\n\t}\n\n\tdispose(): void {\n\t\tthis.pendingUpdates.forEach(cancellationSource => cancellationSource.dispose());\n\t}\n\n\tprovideTextContent(resource: uri): Promise<ITextModel> | null {\n\t\treturn this.createOrUpdateContentModel(resource, true);\n\t}\n\n\t/**\n\t * Reload the model content of the given resource.\n\t * If there is no model for the given resource, this method does nothing.\n\t */\n\tstatic refreshDebugContent(resource: uri): void {\n\t\tif (DebugContentProvider.INSTANCE) {\n\t\t\tDebugContentProvider.INSTANCE.createOrUpdateContentModel(resource, false);\n\t\t}\n\t}\n\n\t/**\n\t * Create or reload the model content of the given resource.\n\t */\n\tprivate createOrUpdateContentModel(resource: uri, createIfNotExists: boolean): Promise<ITextModel> | null {\n\n\t\tconst model = this.modelService.getModel(resource);\n\t\tif (!model && !createIfNotExists) {\n\t\t\t// nothing to do\n\t\t\treturn null;\n\t\t}\n\n\t\tlet session: IDebugSession | undefined;\n\n\t\tif (resource.query) {\n\t\t\tconst data = Source.getEncodedDebugData(resource);\n\t\t\tsession = this.debugService.getModel().getSession(data.sessionId);\n\t\t}\n\n\t\tif (!session) {\n\t\t\t// fallback: use focused session\n\t\t\tsession = this.debugService.getViewModel().focusedSession;\n\t\t}\n\n\t\tif (!session) {\n\t\t\treturn Promise.reject(new Error(localize('unable', \"Unable to resolve the resource without a debug session\")));\n\t\t}\n\t\tconst createErrModel = (errMsg?: string) => {\n\t\t\tthis.debugService.sourceIsNotAvailable(resource);\n\t\t\tconst languageSelection = this.modeService.create(MIME_TEXT);\n\t\t\tconst message = errMsg\n\t\t\t\t? localize('canNotResolveSourceWithError', \"Could not load source '{0}': {1}.\", resource.path, errMsg)\n\t\t\t\t: localize('canNotResolveSource', \"Could not load source '{0}'.\", resource.path);\n\t\t\treturn this.modelService.createModel(message, languageSelection, resource);\n\t\t};\n\n\t\treturn session.loadSource(resource).then(response => {\n\n\t\t\tif (response && response.body) {\n\n\t\t\t\tif (model) {\n\n\t\t\t\t\tconst newContent = response.body.content;\n\n\t\t\t\t\t// cancel and dispose an existing update\n\t\t\t\t\tconst cancellationSource = this.pendingUpdates.get(model.id);\n\t\t\t\t\tif (cancellationSource) {\n\t\t\t\t\t\tcancellationSource.cancel();\n\t\t\t\t\t}\n\n\t\t\t\t\t// create and keep update token\n\t\t\t\t\tconst myToken = new CancellationTokenSource();\n\t\t\t\t\tthis.pendingUpdates.set(model.id, myToken);\n\n\t\t\t\t\t// update text model\n\t\t\t\t\treturn this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: newContent, range: model.getFullModelRange() }]).then(edits => {\n\n\t\t\t\t\t\t// remove token\n\t\t\t\t\t\tthis.pendingUpdates.delete(model.id);\n\n\t\t\t\t\t\tif (!myToken.token.isCancellationRequested && edits && edits.length > 0) {\n\t\t\t\t\t\t\t// use the evil-edit as these models show in readonly-editor only\n\t\t\t\t\t\t\tmodel.applyEdits(edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn model;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// create text model\n\t\t\t\t\tconst mime = response.body.mimeType || guessMimeTypes(resource.path)[0];\n\t\t\t\t\tconst languageSelection = this.modeService.create(mime);\n\t\t\t\t\treturn this.modelService.createModel(response.body.content, languageSelection, resource);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn createErrModel();\n\n\t\t}, (err: DebugProtocol.ErrorResponse) => createErrModel(err.message));\n\t}\n}\n"]}]}