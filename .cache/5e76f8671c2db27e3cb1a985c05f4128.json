{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostConfiguration.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostConfiguration.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/objects\", \"vs/base/common/uri\", \"vs/base/common/event\", \"./extHostTypes\", \"vs/platform/configuration/common/configuration\", \"vs/platform/configuration/common/configurationModels\", \"vs/workbench/services/configuration/common/configurationModels\", \"vs/base/common/map\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/base/common/types\", \"vs/base/common/async\"], function (require, exports, objects_1, uri_1, event_1, extHostTypes_1, configuration_1, configurationModels_1, configurationModels_2, map_1, configurationRegistry_1, types_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function lookUp(tree, key) {\n        if (key) {\n            const parts = key.split('.');\n            let node = tree;\n            for (let i = 0; node && i < parts.length; i++) {\n                node = node[parts[i]];\n            }\n            return node;\n        }\n    }\n    class ExtHostConfiguration {\n        constructor(proxy, extHostWorkspace) {\n            this._proxy = proxy;\n            this._extHostWorkspace = extHostWorkspace;\n            this._barrier = new async_1.Barrier();\n            this._actual = null;\n        }\n        getConfigProvider() {\n            return this._barrier.wait().then(_ => this._actual);\n        }\n        $initializeConfiguration(data) {\n            this._actual = new ExtHostConfigProvider(this._proxy, this._extHostWorkspace, data);\n            this._barrier.open();\n        }\n        $acceptConfigurationChanged(data, eventData) {\n            this.getConfigProvider().then(provider => provider.$acceptConfigurationChanged(data, eventData));\n        }\n    }\n    exports.ExtHostConfiguration = ExtHostConfiguration;\n    class ExtHostConfigProvider {\n        constructor(proxy, extHostWorkspace, data) {\n            this._onDidChangeConfiguration = new event_1.Emitter();\n            this._proxy = proxy;\n            this._extHostWorkspace = extHostWorkspace;\n            this._configuration = ExtHostConfigProvider.parse(data);\n            this._configurationScopes = data.configurationScopes;\n        }\n        get onDidChangeConfiguration() {\n            return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;\n        }\n        $acceptConfigurationChanged(data, eventData) {\n            this._configuration = ExtHostConfigProvider.parse(data);\n            this._configurationScopes = data.configurationScopes;\n            this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(eventData));\n        }\n        getConfiguration(section, resource, extensionId) {\n            const config = this._toReadonlyValue(section\n                ? lookUp(this._configuration.getValue(undefined, { resource }, this._extHostWorkspace.workspace), section)\n                : this._configuration.getValue(undefined, { resource }, this._extHostWorkspace.workspace));\n            if (section) {\n                this._validateConfigurationAccess(section, resource, extensionId);\n            }\n            function parseConfigurationTarget(arg) {\n                if (arg === undefined || arg === null) {\n                    return null;\n                }\n                if (typeof arg === 'boolean') {\n                    return arg ? configuration_1.ConfigurationTarget.USER : configuration_1.ConfigurationTarget.WORKSPACE;\n                }\n                switch (arg) {\n                    case extHostTypes_1.ConfigurationTarget.Global: return configuration_1.ConfigurationTarget.USER;\n                    case extHostTypes_1.ConfigurationTarget.Workspace: return configuration_1.ConfigurationTarget.WORKSPACE;\n                    case extHostTypes_1.ConfigurationTarget.WorkspaceFolder: return configuration_1.ConfigurationTarget.WORKSPACE_FOLDER;\n                }\n            }\n            const result = {\n                has(key) {\n                    return typeof lookUp(config, key) !== 'undefined';\n                },\n                get: (key, defaultValue) => {\n                    this._validateConfigurationAccess(section ? `${section}.${key}` : key, resource, extensionId);\n                    let result = lookUp(config, key);\n                    if (typeof result === 'undefined') {\n                        result = defaultValue;\n                    }\n                    else {\n                        let clonedConfig = undefined;\n                        const cloneOnWriteProxy = (target, accessor) => {\n                            let clonedTarget = undefined;\n                            const cloneTarget = () => {\n                                clonedConfig = clonedConfig ? clonedConfig : objects_1.deepClone(config);\n                                clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);\n                            };\n                            return types_1.isObject(target) ?\n                                new Proxy(target, {\n                                    get: (target, property) => {\n                                        if (typeof property === 'string' && property.toLowerCase() === 'tojson') {\n                                            cloneTarget();\n                                            return () => clonedTarget;\n                                        }\n                                        if (clonedConfig) {\n                                            clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);\n                                            return clonedTarget[property];\n                                        }\n                                        const result = target[property];\n                                        if (typeof property === 'string') {\n                                            return cloneOnWriteProxy(result, `${accessor}.${property}`);\n                                        }\n                                        return result;\n                                    },\n                                    set: (_target, property, value) => {\n                                        cloneTarget();\n                                        if (clonedTarget) {\n                                            clonedTarget[property] = value;\n                                        }\n                                        return true;\n                                    },\n                                    deleteProperty: (_target, property) => {\n                                        cloneTarget();\n                                        if (clonedTarget) {\n                                            delete clonedTarget[property];\n                                        }\n                                        return true;\n                                    },\n                                    defineProperty: (_target, property, descriptor) => {\n                                        cloneTarget();\n                                        if (clonedTarget) {\n                                            Object.defineProperty(clonedTarget, property, descriptor);\n                                        }\n                                        return true;\n                                    }\n                                }) : target;\n                        };\n                        result = cloneOnWriteProxy(result, key);\n                    }\n                    return result;\n                },\n                update: (key, value, arg) => {\n                    key = section ? `${section}.${key}` : key;\n                    const target = parseConfigurationTarget(arg);\n                    if (value !== undefined) {\n                        return this._proxy.$updateConfigurationOption(target, key, value, resource);\n                    }\n                    else {\n                        return this._proxy.$removeConfigurationOption(target, key, resource);\n                    }\n                },\n                inspect: (key) => {\n                    key = section ? `${section}.${key}` : key;\n                    const config = objects_1.deepClone(this._configuration.inspect(key, { resource }, this._extHostWorkspace.workspace));\n                    if (config) {\n                        return {\n                            key,\n                            defaultValue: config.default,\n                            globalValue: config.user,\n                            workspaceValue: config.workspace,\n                            workspaceFolderValue: config.workspaceFolder\n                        };\n                    }\n                    return undefined;\n                }\n            };\n            if (typeof config === 'object') {\n                objects_1.mixin(result, config, false);\n            }\n            return Object.freeze(result);\n        }\n        _toReadonlyValue(result) {\n            const readonlyProxy = (target) => {\n                return types_1.isObject(target) ?\n                    new Proxy(target, {\n                        get: (target, property) => readonlyProxy(target[property]),\n                        set: (_target, property, _value) => { throw new Error(`TypeError: Cannot assign to read only property '${property}' of object`); },\n                        deleteProperty: (_target, property) => { throw new Error(`TypeError: Cannot delete read only property '${property}' of object`); },\n                        defineProperty: (_target, property) => { throw new Error(`TypeError: Cannot define property '${property}' for a readonly object`); },\n                        setPrototypeOf: (_target) => { throw new Error(`TypeError: Cannot set prototype for a readonly object`); },\n                        isExtensible: () => false,\n                        preventExtensions: () => true\n                    }) : target;\n            };\n            return readonlyProxy(result);\n        }\n        _validateConfigurationAccess(key, resource, extensionId) {\n            const scope = configurationRegistry_1.OVERRIDE_PROPERTY_PATTERN.test(key) ? configurationRegistry_1.ConfigurationScope.RESOURCE : this._configurationScopes[key];\n            const extensionIdText = extensionId ? `[${extensionId.value}] ` : '';\n            if (configurationRegistry_1.ConfigurationScope.RESOURCE === scope) {\n                if (resource === undefined) {\n                    console.warn(`${extensionIdText}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${key}', provide the URI of a resource or 'null' for any resource.`);\n                }\n                return;\n            }\n            if (configurationRegistry_1.ConfigurationScope.WINDOW === scope) {\n                if (resource) {\n                    console.warn(`${extensionIdText}Accessing a window scoped configuration for a resource is not expected. To associate '${key}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);\n                }\n                return;\n            }\n        }\n        _toConfigurationChangeEvent(data) {\n            const changedConfiguration = new configurationModels_1.ConfigurationModel(data.changedConfiguration.contents, data.changedConfiguration.keys, data.changedConfiguration.overrides);\n            const changedConfigurationByResource = new map_1.ResourceMap();\n            for (const key of Object.keys(data.changedConfigurationByResource)) {\n                const resource = uri_1.URI.parse(key);\n                const model = data.changedConfigurationByResource[key];\n                changedConfigurationByResource.set(resource, new configurationModels_1.ConfigurationModel(model.contents, model.keys, model.overrides));\n            }\n            const event = new configurationModels_2.WorkspaceConfigurationChangeEvent(new configurationModels_1.ConfigurationChangeEvent(changedConfiguration, changedConfigurationByResource), this._extHostWorkspace.workspace);\n            return Object.freeze({\n                affectsConfiguration: (section, resource) => event.affectsConfiguration(section, resource)\n            });\n        }\n        static parse(data) {\n            const defaultConfiguration = ExtHostConfigProvider.parseConfigurationModel(data.defaults);\n            const userConfiguration = ExtHostConfigProvider.parseConfigurationModel(data.user);\n            const workspaceConfiguration = ExtHostConfigProvider.parseConfigurationModel(data.workspace);\n            const folders = Object.keys(data.folders).reduce((result, key) => {\n                result.set(uri_1.URI.parse(key), ExtHostConfigProvider.parseConfigurationModel(data.folders[key]));\n                return result;\n            }, new map_1.ResourceMap());\n            return new configurationModels_1.Configuration(defaultConfiguration, userConfiguration, new configurationModels_1.ConfigurationModel(), workspaceConfiguration, folders, new configurationModels_1.ConfigurationModel(), new map_1.ResourceMap(), false);\n        }\n        static parseConfigurationModel(model) {\n            return new configurationModels_1.ConfigurationModel(model.contents, model.keys, model.overrides).freeze();\n        }\n    }\n    exports.ExtHostConfigProvider = ExtHostConfigProvider;\n});\n",null]}