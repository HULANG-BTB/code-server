{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/preferences/common/keybindingsEditorModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/preferences/common/keybindingsEditorModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/arrays\", \"vs/base/common/strings\", \"vs/base/common/platform\", \"vs/base/common/filters\", \"vs/platform/registry/common/platform\", \"vs/base/common/keybindingLabels\", \"vs/platform/actions/common/actions\", \"vs/workbench/common/actions\", \"vs/workbench/common/editor\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/keybinding/common/resolvedKeybindingItem\", \"vs/platform/keybinding/common/keybindingResolver\"], function (require, exports, nls_1, arrays_1, strings, platform_1, filters_1, platform_2, keybindingLabels_1, actions_1, actions_2, editor_1, keybinding_1, resolvedKeybindingItem_1, keybindingResolver_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.KEYBINDING_ENTRY_TEMPLATE_ID = 'keybinding.entry.template';\n    const SOURCE_DEFAULT = nls_1.localize('default', \"Default\");\n    const SOURCE_USER = nls_1.localize('user', \"User\");\n    const wordFilter = filters_1.or(filters_1.matchesPrefix, filters_1.matchesWords, filters_1.matchesContiguousSubString);\n    let KeybindingsEditorModel = class KeybindingsEditorModel extends editor_1.EditorModel {\n        constructor(os, keybindingsService) {\n            super();\n            this.keybindingsService = keybindingsService;\n            this.modifierLabels = {\n                ui: keybindingLabels_1.UILabelProvider.modifierLabels[os],\n                aria: keybindingLabels_1.AriaLabelProvider.modifierLabels[os],\n                user: keybindingLabels_1.UserSettingsLabelProvider.modifierLabels[os]\n            };\n        }\n        fetch(searchValue, sortByPrecedence = false) {\n            let keybindingItems = sortByPrecedence ? this._keybindingItemsSortedByPrecedence : this._keybindingItems;\n            if (/@source:\\s*(user|default)/i.test(searchValue)) {\n                keybindingItems = this.filterBySource(keybindingItems, searchValue);\n                searchValue = searchValue.replace(/@source:\\s*(user|default)/i, '');\n            }\n            searchValue = searchValue.trim();\n            if (!searchValue) {\n                return keybindingItems.map(keybindingItem => ({ id: KeybindingsEditorModel.getId(keybindingItem), keybindingItem, templateId: exports.KEYBINDING_ENTRY_TEMPLATE_ID }));\n            }\n            return this.filterByText(keybindingItems, searchValue);\n        }\n        filterBySource(keybindingItems, searchValue) {\n            if (/@source:\\s*default/i.test(searchValue)) {\n                return keybindingItems.filter(k => k.source === SOURCE_DEFAULT);\n            }\n            if (/@source:\\s*user/i.test(searchValue)) {\n                return keybindingItems.filter(k => k.source === SOURCE_USER);\n            }\n            return keybindingItems;\n        }\n        filterByText(keybindingItems, searchValue) {\n            const quoteAtFirstChar = searchValue.charAt(0) === '\"';\n            const quoteAtLastChar = searchValue.charAt(searchValue.length - 1) === '\"';\n            const completeMatch = quoteAtFirstChar && quoteAtLastChar;\n            if (quoteAtFirstChar) {\n                searchValue = searchValue.substring(1);\n            }\n            if (quoteAtLastChar) {\n                searchValue = searchValue.substring(0, searchValue.length - 1);\n            }\n            searchValue = searchValue.trim();\n            const result = [];\n            const words = searchValue.split(' ');\n            const keybindingWords = this.splitKeybindingWords(words);\n            for (const keybindingItem of keybindingItems) {\n                const keybindingMatches = new KeybindingItemMatches(this.modifierLabels, keybindingItem, searchValue, words, keybindingWords, completeMatch);\n                if (keybindingMatches.commandIdMatches\n                    || keybindingMatches.commandLabelMatches\n                    || keybindingMatches.commandDefaultLabelMatches\n                    || keybindingMatches.sourceMatches\n                    || keybindingMatches.whenMatches\n                    || keybindingMatches.keybindingMatches) {\n                    result.push({\n                        id: KeybindingsEditorModel.getId(keybindingItem),\n                        templateId: exports.KEYBINDING_ENTRY_TEMPLATE_ID,\n                        commandLabelMatches: keybindingMatches.commandLabelMatches || undefined,\n                        commandDefaultLabelMatches: keybindingMatches.commandDefaultLabelMatches || undefined,\n                        keybindingItem,\n                        keybindingMatches: keybindingMatches.keybindingMatches || undefined,\n                        commandIdMatches: keybindingMatches.commandIdMatches || undefined,\n                        sourceMatches: keybindingMatches.sourceMatches || undefined,\n                        whenMatches: keybindingMatches.whenMatches || undefined\n                    });\n                }\n            }\n            return result;\n        }\n        splitKeybindingWords(wordsSeparatedBySpaces) {\n            const result = [];\n            for (const word of wordsSeparatedBySpaces) {\n                result.push(...arrays_1.coalesce(word.split('+')));\n            }\n            return result;\n        }\n        resolve(editorActionsLabels) {\n            const workbenchActionsRegistry = platform_2.Registry.as(actions_2.Extensions.WorkbenchActions);\n            this._keybindingItemsSortedByPrecedence = [];\n            const boundCommands = new Map();\n            for (const keybinding of this.keybindingsService.getKeybindings()) {\n                if (keybinding.command) { // Skip keybindings without commands\n                    this._keybindingItemsSortedByPrecedence.push(KeybindingsEditorModel.toKeybindingEntry(keybinding.command, keybinding, workbenchActionsRegistry, editorActionsLabels));\n                    boundCommands.set(keybinding.command, true);\n                }\n            }\n            const commandsWithDefaultKeybindings = this.keybindingsService.getDefaultKeybindings().map(keybinding => keybinding.command);\n            for (const command of keybindingResolver_1.KeybindingResolver.getAllUnboundCommands(boundCommands)) {\n                const keybindingItem = new resolvedKeybindingItem_1.ResolvedKeybindingItem(null, command, null, undefined, commandsWithDefaultKeybindings.indexOf(command) === -1);\n                this._keybindingItemsSortedByPrecedence.push(KeybindingsEditorModel.toKeybindingEntry(command, keybindingItem, workbenchActionsRegistry, editorActionsLabels));\n            }\n            this._keybindingItems = this._keybindingItemsSortedByPrecedence.slice(0).sort((a, b) => KeybindingsEditorModel.compareKeybindingData(a, b));\n            return Promise.resolve(this);\n        }\n        static getId(keybindingItem) {\n            return keybindingItem.command + (keybindingItem.keybinding ? keybindingItem.keybinding.getAriaLabel() : '') + keybindingItem.source + keybindingItem.when;\n        }\n        static compareKeybindingData(a, b) {\n            if (a.keybinding && !b.keybinding) {\n                return -1;\n            }\n            if (b.keybinding && !a.keybinding) {\n                return 1;\n            }\n            if (a.commandLabel && !b.commandLabel) {\n                return -1;\n            }\n            if (b.commandLabel && !a.commandLabel) {\n                return 1;\n            }\n            if (a.commandLabel && b.commandLabel) {\n                if (a.commandLabel !== b.commandLabel) {\n                    return a.commandLabel.localeCompare(b.commandLabel);\n                }\n            }\n            if (a.command === b.command) {\n                return a.keybindingItem.isDefault ? 1 : -1;\n            }\n            return a.command.localeCompare(b.command);\n        }\n        static toKeybindingEntry(command, keybindingItem, workbenchActionsRegistry, editorActions) {\n            const menuCommand = actions_1.MenuRegistry.getCommand(command);\n            const editorActionLabel = editorActions[command];\n            return {\n                keybinding: keybindingItem.resolvedKeybinding,\n                keybindingItem,\n                command,\n                commandLabel: KeybindingsEditorModel.getCommandLabel(menuCommand, editorActionLabel),\n                commandDefaultLabel: KeybindingsEditorModel.getCommandDefaultLabel(menuCommand, workbenchActionsRegistry),\n                when: keybindingItem.when ? keybindingItem.when.serialize() : '',\n                source: keybindingItem.isDefault ? SOURCE_DEFAULT : SOURCE_USER\n            };\n        }\n        static getCommandDefaultLabel(menuCommand, workbenchActionsRegistry) {\n            if (!platform_1.Language.isDefaultVariant()) {\n                if (menuCommand && menuCommand.title && menuCommand.title.original) {\n                    const category = menuCommand.category ? menuCommand.category.original : undefined;\n                    const title = menuCommand.title.original;\n                    return category ? nls_1.localize('cat.title', \"{0}: {1}\", category, title) : title;\n                }\n            }\n            return null;\n        }\n        static getCommandLabel(menuCommand, editorActionLabel) {\n            if (menuCommand) {\n                const category = menuCommand.category ? typeof menuCommand.category === 'string' ? menuCommand.category : menuCommand.category.value : undefined;\n                const title = typeof menuCommand.title === 'string' ? menuCommand.title : menuCommand.title.value;\n                return category ? nls_1.localize('cat.title', \"{0}: {1}\", category, title) : title;\n            }\n            if (editorActionLabel) {\n                return editorActionLabel;\n            }\n            return '';\n        }\n    };\n    KeybindingsEditorModel = __decorate([\n        __param(1, keybinding_1.IKeybindingService)\n    ], KeybindingsEditorModel);\n    exports.KeybindingsEditorModel = KeybindingsEditorModel;\n    class KeybindingItemMatches {\n        constructor(modifierLabels, keybindingItem, searchValue, words, keybindingWords, completeMatch) {\n            this.modifierLabels = modifierLabels;\n            this.commandIdMatches = null;\n            this.commandLabelMatches = null;\n            this.commandDefaultLabelMatches = null;\n            this.sourceMatches = null;\n            this.whenMatches = null;\n            this.keybindingMatches = null;\n            if (!completeMatch) {\n                this.commandIdMatches = this.matches(searchValue, keybindingItem.command, filters_1.or(filters_1.matchesWords, filters_1.matchesCamelCase), words);\n                this.commandLabelMatches = keybindingItem.commandLabel ? this.matches(searchValue, keybindingItem.commandLabel, (word, wordToMatchAgainst) => filters_1.matchesWords(word, keybindingItem.commandLabel, true), words) : null;\n                this.commandDefaultLabelMatches = keybindingItem.commandDefaultLabel ? this.matches(searchValue, keybindingItem.commandDefaultLabel, (word, wordToMatchAgainst) => filters_1.matchesWords(word, keybindingItem.commandDefaultLabel, true), words) : null;\n                this.sourceMatches = this.matches(searchValue, keybindingItem.source, (word, wordToMatchAgainst) => filters_1.matchesWords(word, keybindingItem.source, true), words);\n                this.whenMatches = keybindingItem.when ? this.matches(searchValue, keybindingItem.when, filters_1.or(filters_1.matchesWords, filters_1.matchesCamelCase), words) : null;\n            }\n            this.keybindingMatches = keybindingItem.keybinding ? this.matchesKeybinding(keybindingItem.keybinding, searchValue, keybindingWords, completeMatch) : null;\n        }\n        matches(searchValue, wordToMatchAgainst, wordMatchesFilter, words) {\n            let matches = wordFilter(searchValue, wordToMatchAgainst);\n            if (!matches) {\n                matches = this.matchesWords(words, wordToMatchAgainst, wordMatchesFilter);\n            }\n            if (matches) {\n                matches = this.filterAndSort(matches);\n            }\n            return matches;\n        }\n        matchesWords(words, wordToMatchAgainst, wordMatchesFilter) {\n            let matches = [];\n            for (const word of words) {\n                const wordMatches = wordMatchesFilter(word, wordToMatchAgainst);\n                if (wordMatches) {\n                    matches = [...(matches || []), ...wordMatches];\n                }\n                else {\n                    matches = null;\n                    break;\n                }\n            }\n            return matches;\n        }\n        filterAndSort(matches) {\n            return arrays_1.distinct(matches, (a => a.start + '.' + a.end)).filter(match => !matches.some(m => !(m.start === match.start && m.end === match.end) && (m.start <= match.start && m.end >= match.end))).sort((a, b) => a.start - b.start);\n        }\n        matchesKeybinding(keybinding, searchValue, words, completeMatch) {\n            const [firstPart, chordPart] = keybinding.getParts();\n            const userSettingsLabel = keybinding.getUserSettingsLabel();\n            const ariaLabel = keybinding.getAriaLabel();\n            const label = keybinding.getLabel();\n            if ((userSettingsLabel && strings.compareIgnoreCase(searchValue, userSettingsLabel) === 0)\n                || (ariaLabel && strings.compareIgnoreCase(searchValue, ariaLabel) === 0)\n                || (label && strings.compareIgnoreCase(searchValue, label) === 0)) {\n                return {\n                    firstPart: this.createCompleteMatch(firstPart),\n                    chordPart: this.createCompleteMatch(chordPart)\n                };\n            }\n            const firstPartMatch = {};\n            let chordPartMatch = {};\n            const matchedWords = [];\n            const firstPartMatchedWords = [];\n            let chordPartMatchedWords = [];\n            let matchFirstPart = true;\n            for (let index = 0; index < words.length; index++) {\n                const word = words[index];\n                let firstPartMatched = false;\n                let chordPartMatched = false;\n                matchFirstPart = matchFirstPart && !firstPartMatch.keyCode;\n                let matchChordPart = !chordPartMatch.keyCode;\n                if (matchFirstPart) {\n                    firstPartMatched = this.matchPart(firstPart, firstPartMatch, word, completeMatch);\n                    if (firstPartMatch.keyCode) {\n                        for (const cordPartMatchedWordIndex of chordPartMatchedWords) {\n                            if (firstPartMatchedWords.indexOf(cordPartMatchedWordIndex) === -1) {\n                                matchedWords.splice(matchedWords.indexOf(cordPartMatchedWordIndex), 1);\n                            }\n                        }\n                        chordPartMatch = {};\n                        chordPartMatchedWords = [];\n                        matchChordPart = false;\n                    }\n                }\n                if (matchChordPart) {\n                    chordPartMatched = this.matchPart(chordPart, chordPartMatch, word, completeMatch);\n                }\n                if (firstPartMatched) {\n                    firstPartMatchedWords.push(index);\n                }\n                if (chordPartMatched) {\n                    chordPartMatchedWords.push(index);\n                }\n                if (firstPartMatched || chordPartMatched) {\n                    matchedWords.push(index);\n                }\n                matchFirstPart = matchFirstPart && this.isModifier(word);\n            }\n            if (matchedWords.length !== words.length) {\n                return null;\n            }\n            if (completeMatch && (!this.isCompleteMatch(firstPart, firstPartMatch) || !this.isCompleteMatch(chordPart, chordPartMatch))) {\n                return null;\n            }\n            return this.hasAnyMatch(firstPartMatch) || this.hasAnyMatch(chordPartMatch) ? { firstPart: firstPartMatch, chordPart: chordPartMatch } : null;\n        }\n        matchPart(part, match, word, completeMatch) {\n            let matched = false;\n            if (this.matchesMetaModifier(part, word)) {\n                matched = true;\n                match.metaKey = true;\n            }\n            if (this.matchesCtrlModifier(part, word)) {\n                matched = true;\n                match.ctrlKey = true;\n            }\n            if (this.matchesShiftModifier(part, word)) {\n                matched = true;\n                match.shiftKey = true;\n            }\n            if (this.matchesAltModifier(part, word)) {\n                matched = true;\n                match.altKey = true;\n            }\n            if (this.matchesKeyCode(part, word, completeMatch)) {\n                match.keyCode = true;\n                matched = true;\n            }\n            return matched;\n        }\n        matchesKeyCode(keybinding, word, completeMatch) {\n            if (!keybinding) {\n                return false;\n            }\n            const ariaLabel = keybinding.keyAriaLabel || '';\n            if (completeMatch || ariaLabel.length === 1 || word.length === 1) {\n                if (strings.compareIgnoreCase(ariaLabel, word) === 0) {\n                    return true;\n                }\n            }\n            else {\n                if (filters_1.matchesContiguousSubString(word, ariaLabel)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        matchesMetaModifier(keybinding, word) {\n            if (!keybinding) {\n                return false;\n            }\n            if (!keybinding.metaKey) {\n                return false;\n            }\n            return this.wordMatchesMetaModifier(word);\n        }\n        wordMatchesMetaModifier(word) {\n            if (filters_1.matchesPrefix(this.modifierLabels.ui.metaKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.aria.metaKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.user.metaKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(nls_1.localize('meta', \"meta\"), word)) {\n                return true;\n            }\n            return false;\n        }\n        matchesCtrlModifier(keybinding, word) {\n            if (!keybinding) {\n                return false;\n            }\n            if (!keybinding.ctrlKey) {\n                return false;\n            }\n            return this.wordMatchesCtrlModifier(word);\n        }\n        wordMatchesCtrlModifier(word) {\n            if (filters_1.matchesPrefix(this.modifierLabels.ui.ctrlKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.aria.ctrlKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.user.ctrlKey, word)) {\n                return true;\n            }\n            return false;\n        }\n        matchesShiftModifier(keybinding, word) {\n            if (!keybinding) {\n                return false;\n            }\n            if (!keybinding.shiftKey) {\n                return false;\n            }\n            return this.wordMatchesShiftModifier(word);\n        }\n        wordMatchesShiftModifier(word) {\n            if (filters_1.matchesPrefix(this.modifierLabels.ui.shiftKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.aria.shiftKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.user.shiftKey, word)) {\n                return true;\n            }\n            return false;\n        }\n        matchesAltModifier(keybinding, word) {\n            if (!keybinding) {\n                return false;\n            }\n            if (!keybinding.altKey) {\n                return false;\n            }\n            return this.wordMatchesAltModifier(word);\n        }\n        wordMatchesAltModifier(word) {\n            if (filters_1.matchesPrefix(this.modifierLabels.ui.altKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.aria.altKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(this.modifierLabels.user.altKey, word)) {\n                return true;\n            }\n            if (filters_1.matchesPrefix(nls_1.localize('option', \"option\"), word)) {\n                return true;\n            }\n            return false;\n        }\n        hasAnyMatch(keybindingMatch) {\n            return !!keybindingMatch.altKey ||\n                !!keybindingMatch.ctrlKey ||\n                !!keybindingMatch.metaKey ||\n                !!keybindingMatch.shiftKey ||\n                !!keybindingMatch.keyCode;\n        }\n        isCompleteMatch(part, match) {\n            if (!part) {\n                return true;\n            }\n            if (!match.keyCode) {\n                return false;\n            }\n            if (part.metaKey && !match.metaKey) {\n                return false;\n            }\n            if (part.altKey && !match.altKey) {\n                return false;\n            }\n            if (part.ctrlKey && !match.ctrlKey) {\n                return false;\n            }\n            if (part.shiftKey && !match.shiftKey) {\n                return false;\n            }\n            return true;\n        }\n        createCompleteMatch(part) {\n            const match = {};\n            if (part) {\n                match.keyCode = true;\n                if (part.metaKey) {\n                    match.metaKey = true;\n                }\n                if (part.altKey) {\n                    match.altKey = true;\n                }\n                if (part.ctrlKey) {\n                    match.ctrlKey = true;\n                }\n                if (part.shiftKey) {\n                    match.shiftKey = true;\n                }\n            }\n            return match;\n        }\n        isModifier(word) {\n            if (this.wordMatchesAltModifier(word)) {\n                return true;\n            }\n            if (this.wordMatchesCtrlModifier(word)) {\n                return true;\n            }\n            if (this.wordMatchesMetaModifier(word)) {\n                return true;\n            }\n            if (this.wordMatchesShiftModifier(word)) {\n                return true;\n            }\n            return false;\n        }\n    }\n});\n",null]}