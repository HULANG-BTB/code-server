{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/common/jsonFormatter.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/jsonFormatter.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"./json\"], function (require, exports, json_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function format(documentText, range, options) {\n        let initialIndentLevel;\n        let formatText;\n        let formatTextStart;\n        let rangeStart;\n        let rangeEnd;\n        if (range) {\n            rangeStart = range.offset;\n            rangeEnd = rangeStart + range.length;\n            formatTextStart = rangeStart;\n            while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n                formatTextStart--;\n            }\n            let endOffset = rangeEnd;\n            while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n                endOffset++;\n            }\n            formatText = documentText.substring(formatTextStart, endOffset);\n            initialIndentLevel = computeIndentLevel(formatText, options);\n        }\n        else {\n            formatText = documentText;\n            initialIndentLevel = 0;\n            formatTextStart = 0;\n            rangeStart = 0;\n            rangeEnd = documentText.length;\n        }\n        const eol = getEOL(options, documentText);\n        let lineBreak = false;\n        let indentLevel = 0;\n        let indentValue;\n        if (options.insertSpaces) {\n            indentValue = repeat(' ', options.tabSize || 4);\n        }\n        else {\n            indentValue = '\\t';\n        }\n        const scanner = json_1.createScanner(formatText, false);\n        let hasError = false;\n        function newLineAndIndent() {\n            return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n        }\n        function scanNext() {\n            let token = scanner.scan();\n            lineBreak = false;\n            while (token === json_1.SyntaxKind.Trivia || token === json_1.SyntaxKind.LineBreakTrivia) {\n                lineBreak = lineBreak || (token === json_1.SyntaxKind.LineBreakTrivia);\n                token = scanner.scan();\n            }\n            hasError = token === json_1.SyntaxKind.Unknown || scanner.getTokenError() !== json_1.ScanError.None;\n            return token;\n        }\n        const editOperations = [];\n        function addEdit(text, startOffset, endOffset) {\n            if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n                editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });\n            }\n        }\n        let firstToken = scanNext();\n        if (firstToken !== json_1.SyntaxKind.EOF) {\n            const firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n            const initialIndent = repeat(indentValue, initialIndentLevel);\n            addEdit(initialIndent, formatTextStart, firstTokenStart);\n        }\n        while (firstToken !== json_1.SyntaxKind.EOF) {\n            let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n            let secondToken = scanNext();\n            let replaceContent = '';\n            while (!lineBreak && (secondToken === json_1.SyntaxKind.LineCommentTrivia || secondToken === json_1.SyntaxKind.BlockCommentTrivia)) {\n                // comments on the same line: keep them on the same line, but ignore them otherwise\n                const commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n                addEdit(' ', firstTokenEnd, commentTokenStart);\n                firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n                replaceContent = secondToken === json_1.SyntaxKind.LineCommentTrivia ? newLineAndIndent() : '';\n                secondToken = scanNext();\n            }\n            if (secondToken === json_1.SyntaxKind.CloseBraceToken) {\n                if (firstToken !== json_1.SyntaxKind.OpenBraceToken) {\n                    indentLevel--;\n                    replaceContent = newLineAndIndent();\n                }\n            }\n            else if (secondToken === json_1.SyntaxKind.CloseBracketToken) {\n                if (firstToken !== json_1.SyntaxKind.OpenBracketToken) {\n                    indentLevel--;\n                    replaceContent = newLineAndIndent();\n                }\n            }\n            else {\n                switch (firstToken) {\n                    case json_1.SyntaxKind.OpenBracketToken:\n                    case json_1.SyntaxKind.OpenBraceToken:\n                        indentLevel++;\n                        replaceContent = newLineAndIndent();\n                        break;\n                    case json_1.SyntaxKind.CommaToken:\n                    case json_1.SyntaxKind.LineCommentTrivia:\n                        replaceContent = newLineAndIndent();\n                        break;\n                    case json_1.SyntaxKind.BlockCommentTrivia:\n                        if (lineBreak) {\n                            replaceContent = newLineAndIndent();\n                        }\n                        else {\n                            // symbol following comment on the same line: keep on same line, separate with ' '\n                            replaceContent = ' ';\n                        }\n                        break;\n                    case json_1.SyntaxKind.ColonToken:\n                        replaceContent = ' ';\n                        break;\n                    case json_1.SyntaxKind.StringLiteral:\n                        if (secondToken === json_1.SyntaxKind.ColonToken) {\n                            replaceContent = '';\n                            break;\n                        }\n                    // fall through\n                    case json_1.SyntaxKind.NullKeyword:\n                    case json_1.SyntaxKind.TrueKeyword:\n                    case json_1.SyntaxKind.FalseKeyword:\n                    case json_1.SyntaxKind.NumericLiteral:\n                    case json_1.SyntaxKind.CloseBraceToken:\n                    case json_1.SyntaxKind.CloseBracketToken:\n                        if (secondToken === json_1.SyntaxKind.LineCommentTrivia || secondToken === json_1.SyntaxKind.BlockCommentTrivia) {\n                            replaceContent = ' ';\n                        }\n                        else if (secondToken !== json_1.SyntaxKind.CommaToken && secondToken !== json_1.SyntaxKind.EOF) {\n                            hasError = true;\n                        }\n                        break;\n                    case json_1.SyntaxKind.Unknown:\n                        hasError = true;\n                        break;\n                }\n                if (lineBreak && (secondToken === json_1.SyntaxKind.LineCommentTrivia || secondToken === json_1.SyntaxKind.BlockCommentTrivia)) {\n                    replaceContent = newLineAndIndent();\n                }\n            }\n            const secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n            addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n            firstToken = secondToken;\n        }\n        return editOperations;\n    }\n    exports.format = format;\n    function repeat(s, count) {\n        let result = '';\n        for (let i = 0; i < count; i++) {\n            result += s;\n        }\n        return result;\n    }\n    function computeIndentLevel(content, options) {\n        let i = 0;\n        let nChars = 0;\n        const tabSize = options.tabSize || 4;\n        while (i < content.length) {\n            const ch = content.charAt(i);\n            if (ch === ' ') {\n                nChars++;\n            }\n            else if (ch === '\\t') {\n                nChars += tabSize;\n            }\n            else {\n                break;\n            }\n            i++;\n        }\n        return Math.floor(nChars / tabSize);\n    }\n    function getEOL(options, text) {\n        for (let i = 0; i < text.length; i++) {\n            const ch = text.charAt(i);\n            if (ch === '\\r') {\n                if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n                    return '\\r\\n';\n                }\n                return '\\r';\n            }\n            else if (ch === '\\n') {\n                return '\\n';\n            }\n        }\n        return (options && options.eol) || '\\n';\n    }\n    function isEOL(text, offset) {\n        return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n    }\n    exports.isEOL = isEOL;\n});\n",null]}