{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTextEditor.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostTextEditor.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\ndefine([\"require\", \"exports\", \"vs/base/common/assert\", \"vs/base/common/errors\", \"vs/base/common/idGenerator\", \"vs/workbench/api/node/extHostTypeConverters\", \"vs/workbench/api/node/extHostTypes\"], function (require, exports, assert_1, errors_1, idGenerator_1, TypeConverters, extHostTypes_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class TextEditorDecorationType {\n        constructor(proxy, options) {\n            this.key = TextEditorDecorationType._Keys.nextId();\n            this._proxy = proxy;\n            this._proxy.$registerTextEditorDecorationType(this.key, TypeConverters.DecorationRenderOptions.from(options));\n        }\n        dispose() {\n            this._proxy.$removeTextEditorDecorationType(this.key);\n        }\n    }\n    TextEditorDecorationType._Keys = new idGenerator_1.IdGenerator('TextEditorDecorationType');\n    exports.TextEditorDecorationType = TextEditorDecorationType;\n    class TextEditorEdit {\n        constructor(document, options) {\n            this._document = document;\n            this._documentVersionId = document.version;\n            this._collectedEdits = [];\n            this._setEndOfLine = undefined;\n            this._undoStopBefore = options.undoStopBefore;\n            this._undoStopAfter = options.undoStopAfter;\n        }\n        finalize() {\n            return {\n                documentVersionId: this._documentVersionId,\n                edits: this._collectedEdits,\n                setEndOfLine: this._setEndOfLine,\n                undoStopBefore: this._undoStopBefore,\n                undoStopAfter: this._undoStopAfter\n            };\n        }\n        replace(location, value) {\n            let range = null;\n            if (location instanceof extHostTypes_1.Position) {\n                range = new extHostTypes_1.Range(location, location);\n            }\n            else if (location instanceof extHostTypes_1.Range) {\n                range = location;\n            }\n            else {\n                throw new Error('Unrecognized location');\n            }\n            this._pushEdit(range, value, false);\n        }\n        insert(location, value) {\n            this._pushEdit(new extHostTypes_1.Range(location, location), value, true);\n        }\n        delete(location) {\n            let range = null;\n            if (location instanceof extHostTypes_1.Range) {\n                range = location;\n            }\n            else {\n                throw new Error('Unrecognized location');\n            }\n            this._pushEdit(range, null, true);\n        }\n        _pushEdit(range, text, forceMoveMarkers) {\n            const validRange = this._document.validateRange(range);\n            this._collectedEdits.push({\n                range: validRange,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers\n            });\n        }\n        setEndOfLine(endOfLine) {\n            if (endOfLine !== extHostTypes_1.EndOfLine.LF && endOfLine !== extHostTypes_1.EndOfLine.CRLF) {\n                throw errors_1.illegalArgument('endOfLine');\n            }\n            this._setEndOfLine = endOfLine;\n        }\n    }\n    exports.TextEditorEdit = TextEditorEdit;\n    function deprecated(name, message = 'Refer to the documentation for further details.') {\n        return (target, key, descriptor) => {\n            const originalMethod = descriptor.value;\n            descriptor.value = function (...args) {\n                console.warn(`[Deprecation Warning] method '${name}' is deprecated and should no longer be used. ${message}`);\n                return originalMethod.apply(this, args);\n            };\n            return descriptor;\n        };\n    }\n    class ExtHostTextEditorOptions {\n        constructor(proxy, id, source) {\n            this._proxy = proxy;\n            this._id = id;\n            this._accept(source);\n        }\n        _accept(source) {\n            this._tabSize = source.tabSize;\n            this._indentSize = source.indentSize;\n            this._insertSpaces = source.insertSpaces;\n            this._cursorStyle = source.cursorStyle;\n            this._lineNumbers = TypeConverters.TextEditorLineNumbersStyle.to(source.lineNumbers);\n        }\n        get tabSize() {\n            return this._tabSize;\n        }\n        _validateTabSize(value) {\n            if (value === 'auto') {\n                return 'auto';\n            }\n            if (typeof value === 'number') {\n                const r = Math.floor(value);\n                return (r > 0 ? r : null);\n            }\n            if (typeof value === 'string') {\n                const r = parseInt(value, 10);\n                if (isNaN(r)) {\n                    return null;\n                }\n                return (r > 0 ? r : null);\n            }\n            return null;\n        }\n        set tabSize(value) {\n            const tabSize = this._validateTabSize(value);\n            if (tabSize === null) {\n                // ignore invalid call\n                return;\n            }\n            if (typeof tabSize === 'number') {\n                if (this._tabSize === tabSize) {\n                    // nothing to do\n                    return;\n                }\n                // reflect the new tabSize value immediately\n                this._tabSize = tabSize;\n            }\n            warnOnError(this._proxy.$trySetOptions(this._id, {\n                tabSize: tabSize\n            }));\n        }\n        get indentSize() {\n            return this._indentSize;\n        }\n        _validateIndentSize(value) {\n            if (value === 'tabSize') {\n                return 'tabSize';\n            }\n            if (typeof value === 'number') {\n                const r = Math.floor(value);\n                return (r > 0 ? r : null);\n            }\n            if (typeof value === 'string') {\n                const r = parseInt(value, 10);\n                if (isNaN(r)) {\n                    return null;\n                }\n                return (r > 0 ? r : null);\n            }\n            return null;\n        }\n        set indentSize(value) {\n            const indentSize = this._validateIndentSize(value);\n            if (indentSize === null) {\n                // ignore invalid call\n                return;\n            }\n            if (typeof indentSize === 'number') {\n                if (this._indentSize === indentSize) {\n                    // nothing to do\n                    return;\n                }\n                // reflect the new indentSize value immediately\n                this._indentSize = indentSize;\n            }\n            warnOnError(this._proxy.$trySetOptions(this._id, {\n                indentSize: indentSize\n            }));\n        }\n        get insertSpaces() {\n            return this._insertSpaces;\n        }\n        _validateInsertSpaces(value) {\n            if (value === 'auto') {\n                return 'auto';\n            }\n            return (value === 'false' ? false : Boolean(value));\n        }\n        set insertSpaces(value) {\n            const insertSpaces = this._validateInsertSpaces(value);\n            if (typeof insertSpaces === 'boolean') {\n                if (this._insertSpaces === insertSpaces) {\n                    // nothing to do\n                    return;\n                }\n                // reflect the new insertSpaces value immediately\n                this._insertSpaces = insertSpaces;\n            }\n            warnOnError(this._proxy.$trySetOptions(this._id, {\n                insertSpaces: insertSpaces\n            }));\n        }\n        get cursorStyle() {\n            return this._cursorStyle;\n        }\n        set cursorStyle(value) {\n            if (this._cursorStyle === value) {\n                // nothing to do\n                return;\n            }\n            this._cursorStyle = value;\n            warnOnError(this._proxy.$trySetOptions(this._id, {\n                cursorStyle: value\n            }));\n        }\n        get lineNumbers() {\n            return this._lineNumbers;\n        }\n        set lineNumbers(value) {\n            if (this._lineNumbers === value) {\n                // nothing to do\n                return;\n            }\n            this._lineNumbers = value;\n            warnOnError(this._proxy.$trySetOptions(this._id, {\n                lineNumbers: TypeConverters.TextEditorLineNumbersStyle.from(value)\n            }));\n        }\n        assign(newOptions) {\n            const bulkConfigurationUpdate = {};\n            let hasUpdate = false;\n            if (typeof newOptions.tabSize !== 'undefined') {\n                const tabSize = this._validateTabSize(newOptions.tabSize);\n                if (tabSize === 'auto') {\n                    hasUpdate = true;\n                    bulkConfigurationUpdate.tabSize = tabSize;\n                }\n                else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {\n                    // reflect the new tabSize value immediately\n                    this._tabSize = tabSize;\n                    hasUpdate = true;\n                    bulkConfigurationUpdate.tabSize = tabSize;\n                }\n            }\n            // if (typeof newOptions.indentSize !== 'undefined') {\n            // \tconst indentSize = this._validateIndentSize(newOptions.indentSize);\n            // \tif (indentSize === 'tabSize') {\n            // \t\thasUpdate = true;\n            // \t\tbulkConfigurationUpdate.indentSize = indentSize;\n            // \t} else if (typeof indentSize === 'number' && this._indentSize !== indentSize) {\n            // \t\t// reflect the new indentSize value immediately\n            // \t\tthis._indentSize = indentSize;\n            // \t\thasUpdate = true;\n            // \t\tbulkConfigurationUpdate.indentSize = indentSize;\n            // \t}\n            // }\n            if (typeof newOptions.insertSpaces !== 'undefined') {\n                const insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);\n                if (insertSpaces === 'auto') {\n                    hasUpdate = true;\n                    bulkConfigurationUpdate.insertSpaces = insertSpaces;\n                }\n                else if (this._insertSpaces !== insertSpaces) {\n                    // reflect the new insertSpaces value immediately\n                    this._insertSpaces = insertSpaces;\n                    hasUpdate = true;\n                    bulkConfigurationUpdate.insertSpaces = insertSpaces;\n                }\n            }\n            if (typeof newOptions.cursorStyle !== 'undefined') {\n                if (this._cursorStyle !== newOptions.cursorStyle) {\n                    this._cursorStyle = newOptions.cursorStyle;\n                    hasUpdate = true;\n                    bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;\n                }\n            }\n            if (typeof newOptions.lineNumbers !== 'undefined') {\n                if (this._lineNumbers !== newOptions.lineNumbers) {\n                    this._lineNumbers = newOptions.lineNumbers;\n                    hasUpdate = true;\n                    bulkConfigurationUpdate.lineNumbers = TypeConverters.TextEditorLineNumbersStyle.from(newOptions.lineNumbers);\n                }\n            }\n            if (hasUpdate) {\n                warnOnError(this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));\n            }\n        }\n    }\n    exports.ExtHostTextEditorOptions = ExtHostTextEditorOptions;\n    class ExtHostTextEditor {\n        constructor(proxy, id, document, selections, options, visibleRanges, viewColumn) {\n            this._disposed = false;\n            this._proxy = proxy;\n            this._id = id;\n            this._documentData = document;\n            this._selections = selections;\n            this._options = new ExtHostTextEditorOptions(this._proxy, this._id, options);\n            this._visibleRanges = visibleRanges;\n            this._viewColumn = viewColumn;\n            this._hasDecorationsForKey = Object.create(null);\n        }\n        get id() { return this._id; }\n        dispose() {\n            assert_1.ok(!this._disposed);\n            this._disposed = true;\n        }\n        show(column) {\n            this._proxy.$tryShowEditor(this._id, TypeConverters.ViewColumn.from(column));\n        }\n        hide() {\n            this._proxy.$tryHideEditor(this._id);\n        }\n        // ---- the document\n        get document() {\n            return this._documentData.document;\n        }\n        set document(value) {\n            throw errors_1.readonly('document');\n        }\n        // ---- options\n        get options() {\n            return this._options;\n        }\n        set options(value) {\n            if (!this._disposed) {\n                this._options.assign(value);\n            }\n        }\n        _acceptOptions(options) {\n            assert_1.ok(!this._disposed);\n            this._options._accept(options);\n        }\n        // ---- visible ranges\n        get visibleRanges() {\n            return this._visibleRanges;\n        }\n        set visibleRanges(value) {\n            throw errors_1.readonly('visibleRanges');\n        }\n        _acceptVisibleRanges(value) {\n            assert_1.ok(!this._disposed);\n            this._visibleRanges = value;\n        }\n        // ---- view column\n        get viewColumn() {\n            return this._viewColumn;\n        }\n        set viewColumn(value) {\n            throw errors_1.readonly('viewColumn');\n        }\n        _acceptViewColumn(value) {\n            assert_1.ok(!this._disposed);\n            this._viewColumn = value;\n        }\n        // ---- selections\n        get selection() {\n            return this._selections && this._selections[0];\n        }\n        set selection(value) {\n            if (!(value instanceof extHostTypes_1.Selection)) {\n                throw errors_1.illegalArgument('selection');\n            }\n            this._selections = [value];\n            this._trySetSelection();\n        }\n        get selections() {\n            return this._selections;\n        }\n        set selections(value) {\n            if (!Array.isArray(value) || value.some(a => !(a instanceof extHostTypes_1.Selection))) {\n                throw errors_1.illegalArgument('selections');\n            }\n            this._selections = value;\n            this._trySetSelection();\n        }\n        setDecorations(decorationType, ranges) {\n            const willBeEmpty = (ranges.length === 0);\n            if (willBeEmpty && !this._hasDecorationsForKey[decorationType.key]) {\n                // avoid no-op call to the renderer\n                return;\n            }\n            if (willBeEmpty) {\n                delete this._hasDecorationsForKey[decorationType.key];\n            }\n            else {\n                this._hasDecorationsForKey[decorationType.key] = true;\n            }\n            this._runOnProxy(() => {\n                if (TypeConverters.isDecorationOptionsArr(ranges)) {\n                    return this._proxy.$trySetDecorations(this._id, decorationType.key, TypeConverters.fromRangeOrRangeWithMessage(ranges));\n                }\n                else {\n                    const _ranges = new Array(4 * ranges.length);\n                    for (let i = 0, len = ranges.length; i < len; i++) {\n                        const range = ranges[i];\n                        _ranges[4 * i] = range.start.line + 1;\n                        _ranges[4 * i + 1] = range.start.character + 1;\n                        _ranges[4 * i + 2] = range.end.line + 1;\n                        _ranges[4 * i + 3] = range.end.character + 1;\n                    }\n                    return this._proxy.$trySetDecorationsFast(this._id, decorationType.key, _ranges);\n                }\n            });\n        }\n        revealRange(range, revealType) {\n            this._runOnProxy(() => this._proxy.$tryRevealRange(this._id, TypeConverters.Range.from(range), (revealType || extHostTypes_1.TextEditorRevealType.Default)));\n        }\n        _trySetSelection() {\n            const selection = this._selections.map(TypeConverters.Selection.from);\n            return this._runOnProxy(() => this._proxy.$trySetSelections(this._id, selection));\n        }\n        _acceptSelections(selections) {\n            assert_1.ok(!this._disposed);\n            this._selections = selections;\n        }\n        // ---- editing\n        edit(callback, options = { undoStopBefore: true, undoStopAfter: true }) {\n            if (this._disposed) {\n                return Promise.reject(new Error('TextEditor#edit not possible on closed editors'));\n            }\n            const edit = new TextEditorEdit(this._documentData.document, options);\n            callback(edit);\n            return this._applyEdit(edit);\n        }\n        _applyEdit(editBuilder) {\n            const editData = editBuilder.finalize();\n            // return when there is nothing to do\n            if (editData.edits.length === 0 && !editData.setEndOfLine) {\n                return Promise.resolve(true);\n            }\n            // check that the edits are not overlapping (i.e. illegal)\n            const editRanges = editData.edits.map(edit => edit.range);\n            // sort ascending (by end and then by start)\n            editRanges.sort((a, b) => {\n                if (a.end.line === b.end.line) {\n                    if (a.end.character === b.end.character) {\n                        if (a.start.line === b.start.line) {\n                            return a.start.character - b.start.character;\n                        }\n                        return a.start.line - b.start.line;\n                    }\n                    return a.end.character - b.end.character;\n                }\n                return a.end.line - b.end.line;\n            });\n            // check that no edits are overlapping\n            for (let i = 0, count = editRanges.length - 1; i < count; i++) {\n                const rangeEnd = editRanges[i].end;\n                const nextRangeStart = editRanges[i + 1].start;\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    return Promise.reject(new Error('Overlapping ranges are not allowed!'));\n                }\n            }\n            // prepare data for serialization\n            const edits = editData.edits.map((edit) => {\n                return {\n                    range: TypeConverters.Range.from(edit.range),\n                    text: edit.text,\n                    forceMoveMarkers: edit.forceMoveMarkers\n                };\n            });\n            return this._proxy.$tryApplyEdits(this._id, editData.documentVersionId, edits, {\n                setEndOfLine: typeof editData.setEndOfLine === 'number' ? TypeConverters.EndOfLine.from(editData.setEndOfLine) : undefined,\n                undoStopBefore: editData.undoStopBefore,\n                undoStopAfter: editData.undoStopAfter\n            });\n        }\n        insertSnippet(snippet, where, options = { undoStopBefore: true, undoStopAfter: true }) {\n            if (this._disposed) {\n                return Promise.reject(new Error('TextEditor#insertSnippet not possible on closed editors'));\n            }\n            let ranges;\n            if (!where || (Array.isArray(where) && where.length === 0)) {\n                ranges = this._selections.map(range => TypeConverters.Range.from(range));\n            }\n            else if (where instanceof extHostTypes_1.Position) {\n                const { lineNumber, column } = TypeConverters.Position.from(where);\n                ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];\n            }\n            else if (where instanceof extHostTypes_1.Range) {\n                ranges = [TypeConverters.Range.from(where)];\n            }\n            else {\n                ranges = [];\n                for (const posOrRange of where) {\n                    if (posOrRange instanceof extHostTypes_1.Range) {\n                        ranges.push(TypeConverters.Range.from(posOrRange));\n                    }\n                    else {\n                        const { lineNumber, column } = TypeConverters.Position.from(posOrRange);\n                        ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });\n                    }\n                }\n            }\n            return this._proxy.$tryInsertSnippet(this._id, snippet.value, ranges, options);\n        }\n        // ---- util\n        _runOnProxy(callback) {\n            if (this._disposed) {\n                console.warn('TextEditor is closed/disposed');\n                return Promise.resolve(undefined);\n            }\n            return callback().then(() => this, err => {\n                if (!(err instanceof Error && err.name === 'DISPOSED')) {\n                    console.warn(err);\n                }\n                return null;\n            });\n        }\n    }\n    __decorate([\n        deprecated('TextEditor.show')\n    ], ExtHostTextEditor.prototype, \"show\", null);\n    __decorate([\n        deprecated('TextEditor.hide')\n    ], ExtHostTextEditor.prototype, \"hide\", null);\n    exports.ExtHostTextEditor = ExtHostTextEditor;\n    function warnOnError(promise) {\n        promise.then(undefined, (err) => {\n            console.warn(err);\n        });\n    }\n});\n",null]}