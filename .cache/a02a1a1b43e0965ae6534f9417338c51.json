{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/goToDefinition/goToDefinitionCommands.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/goToDefinition/goToDefinitionCommands.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/ui/aria/aria\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/keyCodes\", \"vs/base/common/platform\", \"vs/editor/browser/editorExtensions\", \"vs/editor/browser/services/codeEditorService\", \"vs/editor/common/core/range\", \"vs/editor/common/editorContextKeys\", \"vs/editor/common/modes\", \"vs/editor/contrib/message/messageController\", \"vs/editor/contrib/referenceSearch/peekViewWidget\", \"vs/editor/contrib/referenceSearch/referencesController\", \"vs/editor/contrib/referenceSearch/referencesModel\", \"vs/nls\", \"vs/platform/actions/common/actions\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/platform/notification/common/notification\", \"vs/platform/progress/common/progress\", \"./goToDefinition\", \"vs/platform/commands/common/commands\"], function (require, exports, aria_1, async_1, cancellation_1, keyCodes_1, platform, editorExtensions_1, codeEditorService_1, range_1, editorContextKeys_1, modes_1, messageController_1, peekViewWidget_1, referencesController_1, referencesModel_1, nls, actions_1, contextkey_1, keybindingsRegistry_1, notification_1, progress_1, goToDefinition_1, commands_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class DefinitionActionConfig {\n        constructor(openToSide = false, openInPeek = false, filterCurrent = true, showMessage = true) {\n            this.openToSide = openToSide;\n            this.openInPeek = openInPeek;\n            this.filterCurrent = filterCurrent;\n            this.showMessage = showMessage;\n            //\n        }\n    }\n    exports.DefinitionActionConfig = DefinitionActionConfig;\n    class DefinitionAction extends editorExtensions_1.EditorAction {\n        constructor(configuration, opts) {\n            super(opts);\n            this._configuration = configuration;\n        }\n        run(accessor, editor) {\n            if (!editor.hasModel()) {\n                return Promise.resolve(undefined);\n            }\n            const notificationService = accessor.get(notification_1.INotificationService);\n            const editorService = accessor.get(codeEditorService_1.ICodeEditorService);\n            const progressService = accessor.get(progress_1.IProgressService);\n            const model = editor.getModel();\n            const pos = editor.getPosition();\n            const definitionPromise = this._getTargetLocationForPosition(model, pos, cancellation_1.CancellationToken.None).then((references) => __awaiter(this, void 0, void 0, function* () {\n                if (model.isDisposed() || editor.getModel() !== model) {\n                    // new model, no more model\n                    return;\n                }\n                // * remove falsy references\n                // * find reference at the current pos\n                let idxOfCurrent = -1;\n                const result = [];\n                for (const reference of references) {\n                    if (!reference || !reference.range) {\n                        continue;\n                    }\n                    const newLen = result.push(reference);\n                    if (this._configuration.filterCurrent\n                        && reference.uri.toString() === model.uri.toString()\n                        && range_1.Range.containsPosition(reference.range, pos)\n                        && idxOfCurrent === -1) {\n                        idxOfCurrent = newLen - 1;\n                    }\n                }\n                if (result.length === 0) {\n                    // no result -> show message\n                    if (this._configuration.showMessage) {\n                        const info = model.getWordAtPosition(pos);\n                        messageController_1.MessageController.get(editor).showMessage(this._getNoResultFoundMessage(info), pos);\n                    }\n                }\n                else if (result.length === 1 && idxOfCurrent !== -1) {\n                    // only the position at which we are -> adjust selection\n                    let [current] = result;\n                    return this._openReference(editor, editorService, current, false).then(() => undefined);\n                }\n                else {\n                    // handle multile results\n                    return this._onResult(editorService, editor, new referencesModel_1.ReferencesModel(result));\n                }\n            }), (err) => {\n                // report an error\n                notificationService.error(err);\n            });\n            progressService.showWhile(definitionPromise, 250);\n            return definitionPromise;\n        }\n        _getTargetLocationForPosition(model, position, token) {\n            return goToDefinition_1.getDefinitionsAtPosition(model, position, token);\n        }\n        _getNoResultFoundMessage(info) {\n            return info && info.word\n                ? nls.localize('noResultWord', \"No definition found for '{0}'\", info.word)\n                : nls.localize('generic.noResults', \"No definition found\");\n        }\n        _getMetaTitle(model) {\n            return model.references.length > 1 ? nls.localize('meta.title', \" â€“ {0} definitions\", model.references.length) : '';\n        }\n        _onResult(editorService, editor, model) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const msg = model.getAriaMessage();\n                aria_1.alert(msg);\n                const { gotoLocation } = editor.getConfiguration().contribInfo;\n                if (this._configuration.openInPeek || (gotoLocation.multiple === 'peek' && model.references.length > 1)) {\n                    this._openInPeek(editorService, editor, model);\n                }\n                else if (editor.hasModel()) {\n                    const next = model.firstReference();\n                    if (!next) {\n                        return;\n                    }\n                    const targetEditor = yield this._openReference(editor, editorService, next, this._configuration.openToSide);\n                    if (targetEditor && model.references.length > 1 && gotoLocation.multiple === 'gotoAndPeek') {\n                        this._openInPeek(editorService, targetEditor, model);\n                    }\n                    else {\n                        model.dispose();\n                    }\n                }\n            });\n        }\n        _openReference(editor, editorService, reference, sideBySide) {\n            // range is the target-selection-range when we have one\n            // and the the fallback is the 'full' range\n            let range = undefined;\n            if (modes_1.isLocationLink(reference)) {\n                range = reference.targetSelectionRange;\n            }\n            if (!range) {\n                range = reference.range;\n            }\n            return editorService.openCodeEditor({\n                resource: reference.uri,\n                options: {\n                    selection: range_1.Range.collapseToStart(range),\n                    revealIfOpened: true,\n                    revealInCenterIfOutsideViewport: true\n                }\n            }, editor, sideBySide);\n        }\n        _openInPeek(editorService, target, model) {\n            let controller = referencesController_1.ReferencesController.get(target);\n            if (controller && target.hasModel()) {\n                controller.toggleWidget(target.getSelection(), async_1.createCancelablePromise(_ => Promise.resolve(model)), {\n                    getMetaTitle: (model) => {\n                        return this._getMetaTitle(model);\n                    },\n                    onGoto: (reference) => {\n                        controller.closeWidget();\n                        return this._openReference(target, editorService, reference, false);\n                    }\n                });\n            }\n            else {\n                model.dispose();\n            }\n        }\n    }\n    exports.DefinitionAction = DefinitionAction;\n    const goToDefinitionKb = platform.isWeb\n        ? keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.F12\n        : keyCodes_1.KeyCode.F12;\n    class GoToDefinitionAction extends DefinitionAction {\n        constructor() {\n            super(new DefinitionActionConfig(), {\n                id: GoToDefinitionAction.id,\n                label: nls.localize('actions.goToDecl.label', \"Go to Definition\"),\n                alias: 'Go to Definition',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasDefinitionProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: goToDefinitionKb,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: 'navigation',\n                    order: 1.1\n                }\n            });\n            commands_1.CommandsRegistry.registerCommandAlias('editor.action.goToDeclaration', GoToDefinitionAction.id);\n        }\n    }\n    GoToDefinitionAction.id = 'editor.action.revealDefinition';\n    exports.GoToDefinitionAction = GoToDefinitionAction;\n    class OpenDefinitionToSideAction extends DefinitionAction {\n        constructor() {\n            super(new DefinitionActionConfig(true), {\n                id: OpenDefinitionToSideAction.id,\n                label: nls.localize('actions.goToDeclToSide.label', \"Open Definition to the Side\"),\n                alias: 'Open Definition to the Side',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasDefinitionProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyChord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, goToDefinitionKb),\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n            commands_1.CommandsRegistry.registerCommandAlias('editor.action.openDeclarationToTheSide', OpenDefinitionToSideAction.id);\n        }\n    }\n    OpenDefinitionToSideAction.id = 'editor.action.revealDefinitionAside';\n    exports.OpenDefinitionToSideAction = OpenDefinitionToSideAction;\n    class PeekDefinitionAction extends DefinitionAction {\n        constructor() {\n            super(new DefinitionActionConfig(undefined, true, false), {\n                id: PeekDefinitionAction.id,\n                label: nls.localize('actions.previewDecl.label', \"Peek Definition\"),\n                alias: 'Peek Definition',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasDefinitionProvider, peekViewWidget_1.PeekContext.notInPeekEditor, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.F12,\n                    linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F10 },\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: 'navigation',\n                    order: 1.2\n                }\n            });\n            commands_1.CommandsRegistry.registerCommandAlias('editor.action.previewDeclaration', PeekDefinitionAction.id);\n        }\n    }\n    PeekDefinitionAction.id = 'editor.action.peekDefinition';\n    exports.PeekDefinitionAction = PeekDefinitionAction;\n    class DeclarationAction extends DefinitionAction {\n        _getTargetLocationForPosition(model, position, token) {\n            return goToDefinition_1.getDeclarationsAtPosition(model, position, token);\n        }\n        _getNoResultFoundMessage(info) {\n            return info && info.word\n                ? nls.localize('decl.noResultWord', \"No declaration found for '{0}'\", info.word)\n                : nls.localize('decl.generic.noResults', \"No declaration found\");\n        }\n        _getMetaTitle(model) {\n            return model.references.length > 1 ? nls.localize('decl.meta.title', \" â€“ {0} declarations\", model.references.length) : '';\n        }\n    }\n    exports.DeclarationAction = DeclarationAction;\n    class GoToDeclarationAction extends DeclarationAction {\n        constructor() {\n            super(new DefinitionActionConfig(), {\n                id: GoToDeclarationAction.id,\n                label: nls.localize('actions.goToDeclaration.label', \"Go to Declaration\"),\n                alias: 'Go to Declaration',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasDeclarationProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                menuOpts: {\n                    group: 'navigation',\n                    order: 1.3\n                }\n            });\n        }\n        _getNoResultFoundMessage(info) {\n            return info && info.word\n                ? nls.localize('decl.noResultWord', \"No declaration found for '{0}'\", info.word)\n                : nls.localize('decl.generic.noResults', \"No declaration found\");\n        }\n        _getMetaTitle(model) {\n            return model.references.length > 1 ? nls.localize('decl.meta.title', \" â€“ {0} declarations\", model.references.length) : '';\n        }\n    }\n    GoToDeclarationAction.id = 'editor.action.revealDeclaration';\n    exports.GoToDeclarationAction = GoToDeclarationAction;\n    class PeekDeclarationAction extends DeclarationAction {\n        constructor() {\n            super(new DefinitionActionConfig(undefined, true, false), {\n                id: 'editor.action.peekDeclaration',\n                label: nls.localize('actions.peekDecl.label', \"Peek Declaration\"),\n                alias: 'Peek Declaration',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasDeclarationProvider, peekViewWidget_1.PeekContext.notInPeekEditor, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                menuOpts: {\n                    group: 'navigation',\n                    order: 1.31\n                }\n            });\n        }\n    }\n    exports.PeekDeclarationAction = PeekDeclarationAction;\n    class ImplementationAction extends DefinitionAction {\n        _getTargetLocationForPosition(model, position, token) {\n            return goToDefinition_1.getImplementationsAtPosition(model, position, token);\n        }\n        _getNoResultFoundMessage(info) {\n            return info && info.word\n                ? nls.localize('goToImplementation.noResultWord', \"No implementation found for '{0}'\", info.word)\n                : nls.localize('goToImplementation.generic.noResults', \"No implementation found\");\n        }\n        _getMetaTitle(model) {\n            return model.references.length > 1 ? nls.localize('meta.implementations.title', \" â€“ {0} implementations\", model.references.length) : '';\n        }\n    }\n    exports.ImplementationAction = ImplementationAction;\n    class GoToImplementationAction extends ImplementationAction {\n        constructor() {\n            super(new DefinitionActionConfig(), {\n                id: GoToImplementationAction.ID,\n                label: nls.localize('actions.goToImplementation.label', \"Go to Implementation\"),\n                alias: 'Go to Implementation',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasImplementationProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.F12,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    GoToImplementationAction.ID = 'editor.action.goToImplementation';\n    exports.GoToImplementationAction = GoToImplementationAction;\n    class PeekImplementationAction extends ImplementationAction {\n        constructor() {\n            super(new DefinitionActionConfig(false, true, false), {\n                id: PeekImplementationAction.ID,\n                label: nls.localize('actions.peekImplementation.label', \"Peek Implementation\"),\n                alias: 'Peek Implementation',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasImplementationProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F12,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    PeekImplementationAction.ID = 'editor.action.peekImplementation';\n    exports.PeekImplementationAction = PeekImplementationAction;\n    class TypeDefinitionAction extends DefinitionAction {\n        _getTargetLocationForPosition(model, position, token) {\n            return goToDefinition_1.getTypeDefinitionsAtPosition(model, position, token);\n        }\n        _getNoResultFoundMessage(info) {\n            return info && info.word\n                ? nls.localize('goToTypeDefinition.noResultWord', \"No type definition found for '{0}'\", info.word)\n                : nls.localize('goToTypeDefinition.generic.noResults', \"No type definition found\");\n        }\n        _getMetaTitle(model) {\n            return model.references.length > 1 ? nls.localize('meta.typeDefinitions.title', \" â€“ {0} type definitions\", model.references.length) : '';\n        }\n    }\n    exports.TypeDefinitionAction = TypeDefinitionAction;\n    class GoToTypeDefinitionAction extends TypeDefinitionAction {\n        constructor() {\n            super(new DefinitionActionConfig(), {\n                id: GoToTypeDefinitionAction.ID,\n                label: nls.localize('actions.goToTypeDefinition.label', \"Go to Type Definition\"),\n                alias: 'Go to Type Definition',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasTypeDefinitionProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: 0,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                },\n                menuOpts: {\n                    group: 'navigation',\n                    order: 1.4\n                }\n            });\n        }\n    }\n    GoToTypeDefinitionAction.ID = 'editor.action.goToTypeDefinition';\n    exports.GoToTypeDefinitionAction = GoToTypeDefinitionAction;\n    class PeekTypeDefinitionAction extends TypeDefinitionAction {\n        constructor() {\n            super(new DefinitionActionConfig(false, true, false), {\n                id: PeekTypeDefinitionAction.ID,\n                label: nls.localize('actions.peekTypeDefinition.label', \"Peek Type Definition\"),\n                alias: 'Peek Type Definition',\n                precondition: contextkey_1.ContextKeyExpr.and(editorContextKeys_1.EditorContextKeys.hasTypeDefinitionProvider, editorContextKeys_1.EditorContextKeys.isInEmbeddedEditor.toNegated()),\n                kbOpts: {\n                    kbExpr: editorContextKeys_1.EditorContextKeys.editorTextFocus,\n                    primary: 0,\n                    weight: keybindingsRegistry_1.KeybindingWeight.EditorContrib\n                }\n            });\n        }\n    }\n    PeekTypeDefinitionAction.ID = 'editor.action.peekTypeDefinition';\n    exports.PeekTypeDefinitionAction = PeekTypeDefinitionAction;\n    editorExtensions_1.registerEditorAction(GoToDefinitionAction);\n    editorExtensions_1.registerEditorAction(OpenDefinitionToSideAction);\n    editorExtensions_1.registerEditorAction(PeekDefinitionAction);\n    editorExtensions_1.registerEditorAction(GoToDeclarationAction);\n    editorExtensions_1.registerEditorAction(PeekDeclarationAction);\n    editorExtensions_1.registerEditorAction(GoToImplementationAction);\n    editorExtensions_1.registerEditorAction(PeekImplementationAction);\n    editorExtensions_1.registerEditorAction(GoToTypeDefinitionAction);\n    editorExtensions_1.registerEditorAction(PeekTypeDefinitionAction);\n    // Go to menu\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {\n        group: '4_symbol_nav',\n        command: {\n            id: 'editor.action.goToDeclaration',\n            title: nls.localize({ key: 'miGotoDefinition', comment: ['&& denotes a mnemonic'] }, \"Go to &&Definition\")\n        },\n        order: 2\n    });\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {\n        group: '4_symbol_nav',\n        command: {\n            id: 'editor.action.goToTypeDefinition',\n            title: nls.localize({ key: 'miGotoTypeDefinition', comment: ['&& denotes a mnemonic'] }, \"Go to &&Type Definition\")\n        },\n        order: 3\n    });\n    actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.MenubarGoMenu, {\n        group: '4_symbol_nav',\n        command: {\n            id: 'editor.action.goToImplementation',\n            title: nls.localize({ key: 'miGotoImplementation', comment: ['&& denotes a mnemonic'] }, \"Go to &&Implementation\")\n        },\n        order: 4\n    });\n});\n",null]}