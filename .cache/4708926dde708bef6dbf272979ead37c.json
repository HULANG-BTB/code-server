{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/electron-browser/settingsEditor2.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/preferences/electron-browser/settingsEditor2.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/common/arrays\", \"vs/base/common/async\", \"vs/base/common/cancellation\", \"vs/base/common/collections\", \"vs/base/common/errors\", \"vs/base/common/iterator\", \"vs/base/common/types\", \"vs/base/common/uri\", \"vs/nls\", \"vs/platform/configuration/common/configuration\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/instantiation/common/instantiation\", \"vs/platform/keybinding/common/keybinding\", \"vs/platform/log/common/log\", \"vs/platform/notification/common/notification\", \"vs/platform/storage/common/storage\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/theme/common/colorRegistry\", \"vs/platform/theme/common/styler\", \"vs/platform/theme/common/themeService\", \"vs/workbench/browser/parts/editor/baseEditor\", \"vs/workbench/contrib/codeEditor/browser/suggestEnabledInput/suggestEnabledInput\", \"vs/workbench/contrib/preferences/browser/preferencesWidgets\", \"vs/workbench/contrib/preferences/browser/settingsLayout\", \"vs/workbench/contrib/preferences/browser/settingsTree\", \"vs/workbench/contrib/preferences/browser/settingsTreeModels\", \"vs/workbench/contrib/preferences/browser/settingsWidgets\", \"vs/workbench/contrib/preferences/browser/tocTree\", \"vs/workbench/contrib/preferences/common/preferences\", \"vs/workbench/services/editor/common/editorGroupsService\", \"vs/workbench/services/preferences/common/preferences\", \"vs/css!./media/settingsEditor2\"], function (require, exports, DOM, arrays, async_1, cancellation_1, collections, errors_1, iterator_1, types_1, uri_1, nls_1, configuration_1, contextkey_1, instantiation_1, keybinding_1, log_1, notification_1, storage_1, telemetry_1, colorRegistry_1, styler_1, themeService_1, baseEditor_1, suggestEnabledInput_1, preferencesWidgets_1, settingsLayout_1, settingsTree_1, settingsTreeModels_1, settingsWidgets_1, tocTree_1, preferences_1, editorGroupsService_1, preferences_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function createGroupIterator(group) {\n        const groupsIt = iterator_1.Iterator.fromArray(group.children);\n        return iterator_1.Iterator.map(groupsIt, g => {\n            return {\n                element: g,\n                children: g instanceof settingsTreeModels_1.SettingsTreeGroupElement ?\n                    createGroupIterator(g) :\n                    undefined\n            };\n        });\n    }\n    const $ = DOM.$;\n    const SETTINGS_EDITOR_STATE_KEY = 'settingsEditorState';\n    let SettingsEditor2 = class SettingsEditor2 extends baseEditor_1.BaseEditor {\n        constructor(telemetryService, configurationService, themeService, preferencesService, instantiationService, preferencesSearchService, logService, contextKeyService, storageService, notificationService, editorGroupService, keybindingService) {\n            super(SettingsEditor2.ID, telemetryService, themeService, storageService);\n            this.configurationService = configurationService;\n            this.preferencesService = preferencesService;\n            this.instantiationService = instantiationService;\n            this.preferencesSearchService = preferencesSearchService;\n            this.logService = logService;\n            this.storageService = storageService;\n            this.notificationService = notificationService;\n            this.editorGroupService = editorGroupService;\n            this.keybindingService = keybindingService;\n            this.settingsTreeScrollTop = 0;\n            this.delayedFilterLogging = new async_1.Delayer(1000);\n            this.localSearchDelayer = new async_1.Delayer(300);\n            this.remoteSearchThrottle = new async_1.ThrottledDelayer(200);\n            this.viewState = { settingsTarget: configuration_1.ConfigurationTarget.USER };\n            this.settingFastUpdateDelayer = new async_1.Delayer(SettingsEditor2.SETTING_UPDATE_FAST_DEBOUNCE);\n            this.settingSlowUpdateDelayer = new async_1.Delayer(SettingsEditor2.SETTING_UPDATE_SLOW_DEBOUNCE);\n            this.inSettingsEditorContextKey = preferences_1.CONTEXT_SETTINGS_EDITOR.bindTo(contextKeyService);\n            this.searchFocusContextKey = preferences_1.CONTEXT_SETTINGS_SEARCH_FOCUS.bindTo(contextKeyService);\n            this.tocRowFocused = preferences_1.CONTEXT_TOC_ROW_FOCUS.bindTo(contextKeyService);\n            this.scheduledRefreshes = new Map();\n            this.editorMemento = this.getEditorMemento(editorGroupService, SETTINGS_EDITOR_STATE_KEY);\n            this._register(configurationService.onDidChangeConfiguration(e => {\n                if (e.source !== configuration_1.ConfigurationTarget.DEFAULT) {\n                    this.onConfigUpdate(e.affectedKeys);\n                }\n            }));\n        }\n        static shouldSettingUpdateFast(type) {\n            if (types_1.isArray(type)) {\n                // nullable integer/number or complex\n                return false;\n            }\n            return type === preferences_2.SettingValueType.Enum ||\n                type === preferences_2.SettingValueType.Complex ||\n                type === preferences_2.SettingValueType.Boolean ||\n                type === preferences_2.SettingValueType.Exclude;\n        }\n        get minimumWidth() { return 375; }\n        get maximumWidth() { return Number.POSITIVE_INFINITY; }\n        // these setters need to exist because this extends from BaseEditor\n        set minimumWidth(value) { }\n        set maximumWidth(value) { }\n        get currentSettingsModel() {\n            return this.searchResultModel || this.settingsTreeModel;\n        }\n        get searchResultModel() {\n            return this._searchResultModel;\n        }\n        set searchResultModel(value) {\n            this._searchResultModel = value;\n            DOM.toggleClass(this.rootElement, 'search-mode', !!this._searchResultModel);\n        }\n        get currentSettingsContextMenuKeyBindingLabel() {\n            const keybinding = this.keybindingService.lookupKeybinding(preferences_1.SETTINGS_EDITOR_COMMAND_SHOW_CONTEXT_MENU);\n            return (keybinding && keybinding.getAriaLabel()) || '';\n        }\n        createEditor(parent) {\n            parent.setAttribute('tabindex', '-1');\n            this.rootElement = DOM.append(parent, $('.settings-editor'));\n            this.createHeader(this.rootElement);\n            this.createBody(this.rootElement);\n            this.updateStyles();\n        }\n        setInput(input, options, token) {\n            this.inSettingsEditorContextKey.set(true);\n            return super.setInput(input, options, token)\n                .then(() => new Promise(process.nextTick)) // Force setInput to be async\n                .then(() => {\n                if (!options) {\n                    if (!this.viewState.settingsTarget) {\n                        // Persist?\n                        options = preferences_2.SettingsEditorOptions.create({ target: configuration_1.ConfigurationTarget.USER });\n                    }\n                }\n                else if (!options.target) {\n                    options.target = configuration_1.ConfigurationTarget.USER;\n                }\n                this._setOptions(options);\n                this._register(input.onDispose(() => {\n                    this.searchWidget.setValue('');\n                }));\n                return this.render(token);\n            })\n                .then(() => {\n                // Init TOC selection\n                this.updateTreeScrollSync();\n                this.restoreCachedState();\n            });\n        }\n        restoreCachedState() {\n            const cachedState = this.group && this.input && this.editorMemento.loadEditorState(this.group, this.input);\n            if (cachedState && typeof cachedState.target === 'object') {\n                cachedState.target = uri_1.URI.revive(cachedState.target);\n            }\n            if (cachedState) {\n                const settingsTarget = cachedState.target;\n                this.settingsTargetsWidget.settingsTarget = settingsTarget;\n                this.onDidSettingsTargetChange(settingsTarget);\n                this.searchWidget.setValue(cachedState.searchQuery);\n            }\n        }\n        setOptions(options) {\n            super.setOptions(options);\n            this._setOptions(options);\n        }\n        _setOptions(options) {\n            if (!options) {\n                return;\n            }\n            if (options.query) {\n                this.searchWidget.setValue(options.query);\n            }\n            const target = options.folderUri || options.target;\n            this.settingsTargetsWidget.settingsTarget = target;\n            this.viewState.settingsTarget = target;\n        }\n        clearInput() {\n            this.inSettingsEditorContextKey.set(false);\n            if (this.input) {\n                this.editorMemento.clearEditorState(this.input, this.group);\n            }\n            super.clearInput();\n        }\n        layout(dimension) {\n            this.layoutTrees(dimension);\n            const innerWidth = dimension.width - 24 * 2; // 24px padding on left and right\n            const monacoWidth = (innerWidth > 1000 ? 1000 : innerWidth) - 10;\n            this.searchWidget.layout({ height: 20, width: monacoWidth });\n            DOM.toggleClass(this.rootElement, 'mid-width', dimension.width < 1000 && dimension.width >= 600);\n            DOM.toggleClass(this.rootElement, 'narrow-width', dimension.width < 600);\n        }\n        focus() {\n            if (this.lastFocusedSettingElement) {\n                const elements = this.settingRenderers.getDOMElementsForSettingKey(this.settingsTree.getHTMLElement(), this.lastFocusedSettingElement);\n                if (elements.length) {\n                    const control = elements[0].querySelector(settingsTree_1.AbstractSettingRenderer.CONTROL_SELECTOR);\n                    if (control) {\n                        control.focus();\n                        return;\n                    }\n                }\n            }\n            this.focusSearch();\n        }\n        focusSettings() {\n            // Update ARIA global labels\n            const labelElement = this.settingsAriaExtraLabelsContainer.querySelector('#settings_aria_more_actions_shortcut_label');\n            if (labelElement) {\n                const settingsContextMenuShortcut = this.currentSettingsContextMenuKeyBindingLabel;\n                if (settingsContextMenuShortcut) {\n                    labelElement.setAttribute('aria-label', nls_1.localize('settingsContextMenuAriaShortcut', \"For more actions, Press {0}.\", settingsContextMenuShortcut));\n                }\n            }\n            const firstFocusable = this.settingsTree.getHTMLElement().querySelector(settingsTree_1.AbstractSettingRenderer.CONTROL_SELECTOR);\n            if (firstFocusable) {\n                firstFocusable.focus();\n            }\n        }\n        showContextMenu() {\n            const activeElement = this.getActiveElementInSettingsTree();\n            if (!activeElement) {\n                return;\n            }\n            const settingDOMElement = this.settingRenderers.getSettingDOMElementForDOMElement(activeElement);\n            if (!settingDOMElement) {\n                return;\n            }\n            const focusedKey = this.settingRenderers.getKeyForDOMElementInSetting(settingDOMElement);\n            if (!focusedKey) {\n                return;\n            }\n            const elements = this.currentSettingsModel.getElementsByName(focusedKey);\n            if (elements && elements[0]) {\n                this.settingRenderers.showContextMenu(elements[0], settingDOMElement);\n            }\n        }\n        focusSearch(filter, selectAll = true) {\n            if (filter && this.searchWidget) {\n                this.searchWidget.setValue(filter);\n            }\n            this.searchWidget.focus(selectAll);\n        }\n        clearSearchResults() {\n            this.searchWidget.setValue('');\n        }\n        clearSearchFilters() {\n            let query = this.searchWidget.getValue();\n            SettingsEditor2.SUGGESTIONS.forEach(suggestion => {\n                query = query.replace(suggestion, '');\n            });\n            this.searchWidget.setValue(query.trim());\n        }\n        createHeader(parent) {\n            this.headerContainer = DOM.append(parent, $('.settings-header'));\n            const searchContainer = DOM.append(this.headerContainer, $('.search-container'));\n            const searchBoxLabel = nls_1.localize('SearchSettings.AriaLabel', \"Search settings\");\n            this.searchWidget = this._register(this.instantiationService.createInstance(suggestEnabledInput_1.SuggestEnabledInput, `${SettingsEditor2.ID}.searchbox`, searchContainer, {\n                triggerCharacters: ['@'],\n                provideResults: (query) => {\n                    return SettingsEditor2.SUGGESTIONS.filter(tag => query.indexOf(tag) === -1).map(tag => tag + ' ');\n                }\n            }, searchBoxLabel, 'settingseditor:searchinput' + SettingsEditor2.NUM_INSTANCES++, {\n                placeholderText: searchBoxLabel,\n                focusContextKey: this.searchFocusContextKey,\n            }));\n            this._register(this.searchWidget.onFocus(() => {\n                this.lastFocusedSettingElement = '';\n            }));\n            this._register(suggestEnabledInput_1.attachSuggestEnabledInputBoxStyler(this.searchWidget, this.themeService, {\n                inputBorder: settingsWidgets_1.settingsTextInputBorder\n            }));\n            this.countElement = DOM.append(searchContainer, DOM.$('.settings-count-widget'));\n            this._register(styler_1.attachStylerCallback(this.themeService, { badgeBackground: colorRegistry_1.badgeBackground, contrastBorder: colorRegistry_1.contrastBorder, badgeForeground: colorRegistry_1.badgeForeground }, colors => {\n                const background = colors.badgeBackground ? colors.badgeBackground.toString() : null;\n                const border = colors.contrastBorder ? colors.contrastBorder.toString() : null;\n                const foreground = colors.badgeForeground ? colors.badgeForeground.toString() : null;\n                this.countElement.style.backgroundColor = background;\n                this.countElement.style.color = foreground;\n                this.countElement.style.borderWidth = border ? '1px' : null;\n                this.countElement.style.borderStyle = border ? 'solid' : null;\n                this.countElement.style.borderColor = border;\n            }));\n            this._register(this.searchWidget.onInputDidChange(() => this.onSearchInputChanged()));\n            const headerControlsContainer = DOM.append(this.headerContainer, $('.settings-header-controls'));\n            const targetWidgetContainer = DOM.append(headerControlsContainer, $('.settings-target-container'));\n            this.settingsTargetsWidget = this._register(this.instantiationService.createInstance(preferencesWidgets_1.SettingsTargetsWidget, targetWidgetContainer));\n            this.settingsTargetsWidget.settingsTarget = configuration_1.ConfigurationTarget.USER;\n            this.settingsTargetsWidget.onDidTargetChange(target => this.onDidSettingsTargetChange(target));\n        }\n        onDidSettingsTargetChange(target) {\n            this.viewState.settingsTarget = target;\n            // TODO Instead of rebuilding the whole model, refresh and uncache the inspected setting value\n            this.onConfigUpdate(undefined, true);\n        }\n        onDidClickSetting(evt, recursed) {\n            const elements = this.currentSettingsModel.getElementsByName(evt.targetKey);\n            if (elements && elements[0]) {\n                let sourceTop = this.settingsTree.getRelativeTop(evt.source);\n                if (typeof sourceTop !== 'number') {\n                    return;\n                }\n                if (sourceTop < 0) {\n                    // e.g. clicked a searched element, now the search has been cleared\n                    sourceTop = 0.5;\n                }\n                this.settingsTree.reveal(elements[0], sourceTop);\n                const domElements = this.settingRenderers.getDOMElementsForSettingKey(this.settingsTree.getHTMLElement(), evt.targetKey);\n                if (domElements && domElements[0]) {\n                    const control = domElements[0].querySelector(settingsTree_1.AbstractSettingRenderer.CONTROL_SELECTOR);\n                    if (control) {\n                        control.focus();\n                    }\n                }\n            }\n            else if (!recursed) {\n                const p = this.triggerSearch('');\n                p.then(() => {\n                    this.searchWidget.setValue('');\n                    this.onDidClickSetting(evt, true);\n                });\n            }\n        }\n        switchToSettingsFile() {\n            const query = settingsTreeModels_1.parseQuery(this.searchWidget.getValue());\n            return this.openSettingsFile(query.query);\n        }\n        openSettingsFile(query) {\n            const currentSettingsTarget = this.settingsTargetsWidget.settingsTarget;\n            const options = { query };\n            if (currentSettingsTarget === configuration_1.ConfigurationTarget.USER) {\n                return this.preferencesService.openGlobalSettings(true, options);\n            }\n            else if (currentSettingsTarget === configuration_1.ConfigurationTarget.WORKSPACE) {\n                return this.preferencesService.openWorkspaceSettings(true, options);\n            }\n            else {\n                return this.preferencesService.openFolderSettings(currentSettingsTarget, true, options);\n            }\n        }\n        createBody(parent) {\n            const bodyContainer = DOM.append(parent, $('.settings-body'));\n            this.noResultsMessage = DOM.append(bodyContainer, $('.no-results-message'));\n            this.noResultsMessage.innerText = nls_1.localize('noResults', \"No Settings Found\");\n            this.clearFilterLinkContainer = $('span.clear-search-filters');\n            this.clearFilterLinkContainer.textContent = ' - ';\n            const clearFilterLink = DOM.append(this.clearFilterLinkContainer, $('a.pointer.prominent', { tabindex: 0 }, nls_1.localize('clearSearchFilters', 'Clear Filters')));\n            this._register(DOM.addDisposableListener(clearFilterLink, DOM.EventType.CLICK, (e) => {\n                DOM.EventHelper.stop(e, false);\n                this.clearSearchFilters();\n            }));\n            DOM.append(this.noResultsMessage, this.clearFilterLinkContainer);\n            const clearSearchContainer = $('span.clear-search');\n            clearSearchContainer.textContent = ' - ';\n            const clearSearch = DOM.append(clearSearchContainer, $('a.pointer.prominent', { tabindex: 0 }, nls_1.localize('clearSearch', 'Clear Search')));\n            this._register(DOM.addDisposableListener(clearSearch, DOM.EventType.CLICK, (e) => {\n                DOM.EventHelper.stop(e, false);\n                this.clearSearchResults();\n                this.focusSearch();\n            }));\n            DOM.append(this.noResultsMessage, clearSearchContainer);\n            this._register(styler_1.attachStylerCallback(this.themeService, { editorForeground: colorRegistry_1.editorForeground }, colors => {\n                this.noResultsMessage.style.color = colors.editorForeground ? colors.editorForeground.toString() : null;\n            }));\n            this.createTOC(bodyContainer);\n            this.createFocusSink(bodyContainer, e => {\n                if (DOM.findParentWithClass(e.relatedTarget, 'settings-editor-tree')) {\n                    if (this.settingsTree.scrollTop > 0) {\n                        const firstElement = this.settingsTree.firstVisibleElement;\n                        this.settingsTree.reveal(firstElement, 0.1);\n                        return true;\n                    }\n                }\n                else {\n                    const firstControl = this.settingsTree.getHTMLElement().querySelector(settingsTree_1.AbstractSettingRenderer.CONTROL_SELECTOR);\n                    if (firstControl) {\n                        firstControl.focus();\n                    }\n                }\n                return false;\n            }, 'settings list focus helper');\n            this.createSettingsTree(bodyContainer);\n            this.createFocusSink(bodyContainer, e => {\n                if (DOM.findParentWithClass(e.relatedTarget, 'settings-editor-tree')) {\n                    if (this.settingsTree.scrollTop < this.settingsTree.scrollHeight) {\n                        const lastElement = this.settingsTree.lastVisibleElement;\n                        this.settingsTree.reveal(lastElement, 0.9);\n                        return true;\n                    }\n                }\n                return false;\n            }, 'settings list focus helper');\n        }\n        createFocusSink(container, callback, label) {\n            const listFocusSink = DOM.append(container, $('.settings-tree-focus-sink'));\n            listFocusSink.setAttribute('aria-label', label);\n            listFocusSink.tabIndex = 0;\n            this._register(DOM.addDisposableListener(listFocusSink, 'focus', (e) => {\n                if (e.relatedTarget && callback(e)) {\n                    e.relatedTarget.focus();\n                }\n            }));\n            return listFocusSink;\n        }\n        createTOC(parent) {\n            this.tocTreeModel = new tocTree_1.TOCTreeModel(this.viewState);\n            this.tocTreeContainer = DOM.append(parent, $('.settings-toc-container'));\n            this.tocTree = this._register(this.instantiationService.createInstance(tocTree_1.TOCTree, DOM.append(this.tocTreeContainer, $('.settings-toc-wrapper')), this.viewState));\n            this._register(this.tocTree.onDidChangeFocus(e => {\n                const element = e.elements[0];\n                if (this.tocFocusedElement === element) {\n                    return;\n                }\n                this.tocFocusedElement = element;\n                this.tocTree.setSelection(element ? [element] : []);\n                if (this.searchResultModel) {\n                    if (this.viewState.filterToCategory !== element) {\n                        this.viewState.filterToCategory = types_1.withNullAsUndefined(element);\n                        this.renderTree();\n                        this.settingsTree.scrollTop = 0;\n                    }\n                }\n                else if (element && (!e.browserEvent || !e.browserEvent.fromScroll)) {\n                    this.settingsTree.reveal(element, 0);\n                }\n            }));\n            this._register(this.tocTree.onDidFocus(() => {\n                this.tocRowFocused.set(true);\n            }));\n            this._register(this.tocTree.onDidBlur(() => {\n                this.tocRowFocused.set(false);\n            }));\n        }\n        createSettingsTree(parent) {\n            this.settingsTreeContainer = DOM.append(parent, $('.settings-tree-container'));\n            // Add  ARIA extra labels div\n            this.settingsAriaExtraLabelsContainer = DOM.append(this.settingsTreeContainer, $('.settings-aria-extra-labels'));\n            this.settingsAriaExtraLabelsContainer.id = 'settings_aria_extra_labels';\n            // Add global labels here\n            const labelDiv = DOM.append(this.settingsAriaExtraLabelsContainer, $('.settings-aria-extra-label'));\n            labelDiv.id = 'settings_aria_more_actions_shortcut_label';\n            labelDiv.setAttribute('aria-label', '');\n            this.settingRenderers = this.instantiationService.createInstance(settingsTree_1.SettingTreeRenderers);\n            this._register(this.settingRenderers.onDidChangeSetting(e => this.onDidChangeSetting(e.key, e.value, e.type)));\n            this._register(this.settingRenderers.onDidOpenSettings(settingKey => {\n                this.openSettingsFile(settingKey);\n            }));\n            this._register(this.settingRenderers.onDidClickSettingLink(settingName => this.onDidClickSetting(settingName)));\n            this._register(this.settingRenderers.onDidFocusSetting(element => {\n                this.lastFocusedSettingElement = element.setting.key;\n                this.settingsTree.reveal(element);\n            }));\n            this._register(this.settingRenderers.onDidClickOverrideElement((element) => {\n                if (configuration_1.ConfigurationTargetToString(configuration_1.ConfigurationTarget.WORKSPACE) === element.scope.toUpperCase()) {\n                    this.settingsTargetsWidget.updateTarget(configuration_1.ConfigurationTarget.WORKSPACE);\n                }\n                else if (configuration_1.ConfigurationTargetToString(configuration_1.ConfigurationTarget.USER) === element.scope.toUpperCase()) {\n                    this.settingsTargetsWidget.updateTarget(configuration_1.ConfigurationTarget.USER);\n                }\n                this.searchWidget.setValue(element.targetKey);\n            }));\n            this.settingsTree = this._register(this.instantiationService.createInstance(settingsTree_1.SettingsTree, this.settingsTreeContainer, this.viewState, this.settingRenderers.allRenderers));\n            this.settingsTree.getHTMLElement().attributes.removeNamedItem('tabindex');\n            this._register(this.settingsTree.onDidScroll(() => {\n                if (this.settingsTree.scrollTop === this.settingsTreeScrollTop) {\n                    return;\n                }\n                this.settingsTreeScrollTop = this.settingsTree.scrollTop;\n                // setTimeout because calling setChildren on the settingsTree can trigger onDidScroll, so it fires when\n                // setChildren has called on the settings tree but not the toc tree yet, so their rendered elements are out of sync\n                setTimeout(() => {\n                    this.updateTreeScrollSync();\n                }, 0);\n            }));\n        }\n        notifyNoSaveNeeded() {\n            if (!this.storageService.getBoolean('hasNotifiedOfSettingsAutosave', storage_1.StorageScope.GLOBAL, false)) {\n                this.storageService.store('hasNotifiedOfSettingsAutosave', true, storage_1.StorageScope.GLOBAL);\n                this.notificationService.info(nls_1.localize('settingsNoSaveNeeded', \"Your changes are automatically saved as you edit.\"));\n            }\n        }\n        onDidChangeSetting(key, value, type) {\n            this.notifyNoSaveNeeded();\n            if (this.pendingSettingUpdate && this.pendingSettingUpdate.key !== key) {\n                this.updateChangedSetting(key, value);\n            }\n            this.pendingSettingUpdate = { key, value };\n            if (SettingsEditor2.shouldSettingUpdateFast(type)) {\n                this.settingFastUpdateDelayer.trigger(() => this.updateChangedSetting(key, value));\n            }\n            else {\n                this.settingSlowUpdateDelayer.trigger(() => this.updateChangedSetting(key, value));\n            }\n        }\n        updateTreeScrollSync() {\n            this.settingRenderers.cancelSuggesters();\n            if (this.searchResultModel) {\n                return;\n            }\n            if (!this.tocTreeModel) {\n                return;\n            }\n            const elementToSync = this.settingsTree.firstVisibleElement;\n            const element = elementToSync instanceof settingsTreeModels_1.SettingsTreeSettingElement ? elementToSync.parent :\n                elementToSync instanceof settingsTreeModels_1.SettingsTreeGroupElement ? elementToSync :\n                    null;\n            // It's possible for this to be called when the TOC and settings tree are out of sync - e.g. when the settings tree has deferred a refresh because\n            // it is focused. So, bail if element doesn't exist in the TOC.\n            let nodeExists = true;\n            try {\n                this.tocTree.getNode(element);\n            }\n            catch (e) {\n                nodeExists = false;\n            }\n            if (!nodeExists) {\n                return;\n            }\n            if (element && this.tocTree.getSelection()[0] !== element) {\n                const ancestors = this.getAncestors(element);\n                ancestors.forEach(e => this.tocTree.expand(e));\n                this.tocTree.reveal(element);\n                const elementTop = this.tocTree.getRelativeTop(element);\n                if (typeof elementTop !== 'number') {\n                    return;\n                }\n                this.tocTree.collapseAll();\n                ancestors.forEach(e => this.tocTree.expand(e));\n                if (elementTop < 0 || elementTop > 1) {\n                    this.tocTree.reveal(element);\n                }\n                else {\n                    this.tocTree.reveal(element, elementTop);\n                }\n                this.tocTree.expand(element);\n                this.tocTree.setSelection([element]);\n                const fakeKeyboardEvent = new KeyboardEvent('keydown');\n                fakeKeyboardEvent.fromScroll = true;\n                this.tocTree.setFocus([element], fakeKeyboardEvent);\n            }\n        }\n        getAncestors(element) {\n            const ancestors = [];\n            while (element.parent) {\n                if (element.parent.id !== 'root') {\n                    ancestors.push(element.parent);\n                }\n                element = element.parent;\n            }\n            return ancestors.reverse();\n        }\n        updateChangedSetting(key, value) {\n            // ConfigurationService displays the error if this fails.\n            // Force a render afterwards because onDidConfigurationUpdate doesn't fire if the update doesn't result in an effective setting value change\n            const settingsTarget = this.settingsTargetsWidget.settingsTarget;\n            const resource = uri_1.URI.isUri(settingsTarget) ? settingsTarget : undefined;\n            const configurationTarget = (resource ? configuration_1.ConfigurationTarget.WORKSPACE_FOLDER : settingsTarget);\n            const overrides = { resource };\n            const isManualReset = value === undefined;\n            // If the user is changing the value back to the default, do a 'reset' instead\n            const inspected = this.configurationService.inspect(key, overrides);\n            if (inspected.default === value) {\n                value = undefined;\n            }\n            return this.configurationService.updateValue(key, value, overrides, configurationTarget)\n                .then(() => {\n                this.renderTree(key, isManualReset);\n                const reportModifiedProps = {\n                    key,\n                    query: this.searchWidget.getValue(),\n                    searchResults: this.searchResultModel && this.searchResultModel.getUniqueResults(),\n                    rawResults: this.searchResultModel && this.searchResultModel.getRawResults(),\n                    showConfiguredOnly: !!this.viewState.tagFilters && this.viewState.tagFilters.has(preferences_1.MODIFIED_SETTING_TAG),\n                    isReset: typeof value === 'undefined',\n                    settingsTarget: this.settingsTargetsWidget.settingsTarget\n                };\n                return this.reportModifiedSetting(reportModifiedProps);\n            });\n        }\n        reportModifiedSetting(props) {\n            this.pendingSettingUpdate = null;\n            let groupId = undefined;\n            let nlpIndex = undefined;\n            let displayIndex = undefined;\n            if (props.searchResults) {\n                const remoteResult = props.searchResults[settingsTreeModels_1.SearchResultIdx.Remote];\n                const localResult = props.searchResults[settingsTreeModels_1.SearchResultIdx.Local];\n                const localIndex = arrays.firstIndex(localResult.filterMatches, m => m.setting.key === props.key);\n                groupId = localIndex >= 0 ?\n                    'local' :\n                    'remote';\n                displayIndex = localIndex >= 0 ?\n                    localIndex :\n                    remoteResult && (arrays.firstIndex(remoteResult.filterMatches, m => m.setting.key === props.key) + localResult.filterMatches.length);\n                if (this.searchResultModel) {\n                    const rawResults = this.searchResultModel.getRawResults();\n                    if (rawResults[settingsTreeModels_1.SearchResultIdx.Remote]) {\n                        const _nlpIndex = arrays.firstIndex(rawResults[settingsTreeModels_1.SearchResultIdx.Remote].filterMatches, m => m.setting.key === props.key);\n                        nlpIndex = _nlpIndex >= 0 ? _nlpIndex : undefined;\n                    }\n                }\n            }\n            const reportedTarget = props.settingsTarget === configuration_1.ConfigurationTarget.USER ? 'user' :\n                props.settingsTarget === configuration_1.ConfigurationTarget.WORKSPACE ? 'workspace' :\n                    'folder';\n            const data = {\n                key: props.key,\n                query: props.query,\n                groupId,\n                nlpIndex,\n                displayIndex,\n                showConfiguredOnly: props.showConfiguredOnly,\n                isReset: props.isReset,\n                target: reportedTarget\n            };\n            /* __GDPR__\n                \"settingsEditor.settingModified\" : {\n                    \"key\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"query\" : { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" },\n                    \"groupId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"nlpIndex\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"displayIndex\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"showConfiguredOnly\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"isReset\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                    \"target\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                }\n            */\n            this.telemetryService.publicLog('settingsEditor.settingModified', data);\n        }\n        render(token) {\n            if (this.input) {\n                return this.input.resolve()\n                    .then((model) => {\n                    if (token.isCancellationRequested) {\n                        return undefined;\n                    }\n                    this._register(model.onDidChangeGroups(() => this.onConfigUpdate()));\n                    this.defaultSettingsEditorModel = model;\n                    return this.onConfigUpdate();\n                });\n            }\n            return Promise.resolve(null);\n        }\n        onSearchModeToggled() {\n            DOM.removeClass(this.rootElement, 'no-toc-search');\n            if (this.configurationService.getValue('workbench.settings.settingsSearchTocBehavior') === 'hide') {\n                DOM.toggleClass(this.rootElement, 'no-toc-search', !!this.searchResultModel);\n            }\n        }\n        scheduleRefresh(element, key = '') {\n            if (key && this.scheduledRefreshes.has(key)) {\n                return;\n            }\n            if (!key) {\n                this.scheduledRefreshes.forEach(r => r.dispose());\n                this.scheduledRefreshes.clear();\n            }\n            const scheduledRefreshTracker = DOM.trackFocus(element);\n            this.scheduledRefreshes.set(key, scheduledRefreshTracker);\n            scheduledRefreshTracker.onDidBlur(() => {\n                scheduledRefreshTracker.dispose();\n                this.scheduledRefreshes.delete(key);\n                this.onConfigUpdate([key]);\n            });\n        }\n        onConfigUpdate(keys, forceRefresh = false) {\n            if (keys && this.settingsTreeModel) {\n                return this.updateElementsByKey(keys);\n            }\n            const groups = this.defaultSettingsEditorModel.settingsGroups.slice(1); // Without commonlyUsed\n            const dividedGroups = collections.groupBy(groups, g => g.contributedByExtension ? 'extension' : 'core');\n            const settingsResult = settingsTree_1.resolveSettingsTree(settingsLayout_1.tocData, dividedGroups.core);\n            const resolvedSettingsRoot = settingsResult.tree;\n            // Warn for settings not included in layout\n            if (settingsResult.leftoverSettings.size && !this.hasWarnedMissingSettings) {\n                const settingKeyList = [];\n                settingsResult.leftoverSettings.forEach(s => {\n                    settingKeyList.push(s.key);\n                });\n                this.logService.warn(`SettingsEditor2: Settings not included in settingsLayout.ts: ${settingKeyList.join(', ')}`);\n                this.hasWarnedMissingSettings = true;\n            }\n            const commonlyUsed = settingsTree_1.resolveSettingsTree(settingsLayout_1.commonlyUsedData, dividedGroups.core);\n            resolvedSettingsRoot.children.unshift(commonlyUsed.tree);\n            resolvedSettingsRoot.children.push(settingsTree_1.resolveExtensionsSettings(dividedGroups.extension || []));\n            if (this.searchResultModel) {\n                this.searchResultModel.updateChildren();\n            }\n            if (this.settingsTreeModel) {\n                this.settingsTreeModel.update(resolvedSettingsRoot);\n                // Make sure that all extensions' settings are included in search results\n                const cachedState = this.group && this.input && this.editorMemento.loadEditorState(this.group, this.input);\n                if (cachedState && cachedState.searchQuery) {\n                    this.triggerSearch(cachedState.searchQuery);\n                }\n                else {\n                    this.renderTree(undefined, forceRefresh);\n                    this.refreshTOCTree();\n                }\n            }\n            else {\n                this.settingsTreeModel = this.instantiationService.createInstance(settingsTreeModels_1.SettingsTreeModel, this.viewState);\n                this.settingsTreeModel.update(resolvedSettingsRoot);\n                this.tocTreeModel.settingsTreeRoot = this.settingsTreeModel.root;\n                this.refreshTOCTree();\n                this.refreshTree();\n                this.tocTree.collapseAll();\n            }\n        }\n        updateElementsByKey(keys) {\n            if (keys.length) {\n                if (this.searchResultModel) {\n                    keys.forEach(key => this.searchResultModel.updateElementsByName(key));\n                }\n                if (this.settingsTreeModel) {\n                    keys.forEach(key => this.settingsTreeModel.updateElementsByName(key));\n                }\n                keys.forEach(key => this.renderTree(key));\n            }\n            else {\n                return this.renderTree();\n            }\n        }\n        getActiveElementInSettingsTree() {\n            return (document.activeElement && DOM.isAncestor(document.activeElement, this.settingsTree.getHTMLElement())) ?\n                document.activeElement :\n                null;\n        }\n        renderTree(key, force = false) {\n            if (!force && key && this.scheduledRefreshes.has(key)) {\n                this.updateModifiedLabelForKey(key);\n                return;\n            }\n            // If the context view is focused, delay rendering settings\n            if (this.contextViewFocused()) {\n                const element = document.querySelector('.context-view');\n                if (element) {\n                    this.scheduleRefresh(element, key);\n                }\n                return;\n            }\n            // If a setting control is currently focused, schedule a refresh for later\n            const activeElement = this.getActiveElementInSettingsTree();\n            const focusedSetting = activeElement && this.settingRenderers.getSettingDOMElementForDOMElement(activeElement);\n            if (focusedSetting && !force) {\n                // If a single setting is being refreshed, it's ok to refresh now if that is not the focused setting\n                if (key) {\n                    const focusedKey = focusedSetting.getAttribute(settingsTree_1.AbstractSettingRenderer.SETTING_KEY_ATTR);\n                    if (focusedKey === key &&\n                        !DOM.hasClass(focusedSetting, 'setting-item-exclude')) { // update `exclude`s live, as they have a separate \"submit edit\" step built in before this\n                        this.updateModifiedLabelForKey(key);\n                        this.scheduleRefresh(focusedSetting, key);\n                        return;\n                    }\n                }\n                else {\n                    this.scheduleRefresh(focusedSetting);\n                    return;\n                }\n            }\n            this.renderResultCountMessages();\n            if (key) {\n                const elements = this.currentSettingsModel.getElementsByName(key);\n                if (elements && elements.length) {\n                    // TODO https://github.com/Microsoft/vscode/issues/57360\n                    this.refreshTree();\n                }\n                else {\n                    // Refresh requested for a key that we don't know about\n                    return;\n                }\n            }\n            else {\n                this.refreshTree();\n            }\n            return;\n        }\n        contextViewFocused() {\n            return !!DOM.findParentWithClass(document.activeElement, 'context-view');\n        }\n        refreshTree() {\n            if (this.isVisible()) {\n                this.settingsTree.setChildren(null, createGroupIterator(this.currentSettingsModel.root));\n            }\n        }\n        refreshTOCTree() {\n            if (this.isVisible()) {\n                this.tocTreeModel.update();\n                this.tocTree.setChildren(null, tocTree_1.createTOCIterator(this.tocTreeModel, this.tocTree));\n            }\n        }\n        updateModifiedLabelForKey(key) {\n            const dataElements = this.currentSettingsModel.getElementsByName(key);\n            const isModified = dataElements && dataElements[0] && dataElements[0].isConfigured; // all elements are either configured or not\n            const elements = this.settingRenderers.getDOMElementsForSettingKey(this.settingsTree.getHTMLElement(), key);\n            if (elements && elements[0]) {\n                DOM.toggleClass(elements[0], 'is-configured', !!isModified);\n            }\n        }\n        onSearchInputChanged() {\n            const query = this.searchWidget.getValue().trim();\n            this.delayedFilterLogging.cancel();\n            this.triggerSearch(query.replace(/›/g, ' ')).then(() => {\n                if (query && this.searchResultModel) {\n                    this.delayedFilterLogging.trigger(() => this.reportFilteringUsed(query, this.searchResultModel.getUniqueResults()));\n                }\n            });\n        }\n        parseSettingFromJSON(query) {\n            const match = query.match(/\"([a-zA-Z.]+)\": /);\n            return match && match[1];\n        }\n        triggerSearch(query) {\n            this.viewState.tagFilters = new Set();\n            if (query) {\n                const parsedQuery = settingsTreeModels_1.parseQuery(query);\n                query = parsedQuery.query;\n                parsedQuery.tags.forEach(tag => this.viewState.tagFilters.add(tag));\n            }\n            if (query && query !== '@') {\n                query = this.parseSettingFromJSON(query) || query;\n                return this.triggerFilterPreferences(query);\n            }\n            else {\n                if (this.viewState.tagFilters && this.viewState.tagFilters.size) {\n                    this.searchResultModel = this.createFilterModel();\n                }\n                else {\n                    this.searchResultModel = null;\n                }\n                this.localSearchDelayer.cancel();\n                this.remoteSearchThrottle.cancel();\n                if (this.searchInProgress) {\n                    this.searchInProgress.cancel();\n                    this.searchInProgress.dispose();\n                    this.searchInProgress = null;\n                }\n                this.viewState.filterToCategory = undefined;\n                this.tocTreeModel.currentSearchModel = this.searchResultModel;\n                this.onSearchModeToggled();\n                if (this.searchResultModel) {\n                    // Added a filter model\n                    this.tocTree.setSelection([]);\n                    this.tocTree.expandAll();\n                    this.renderResultCountMessages();\n                    this.refreshTree();\n                }\n                else {\n                    // Leaving search mode\n                    this.tocTree.collapseAll();\n                    this.renderResultCountMessages();\n                    this.refreshTree();\n                }\n                this.refreshTOCTree();\n            }\n            return Promise.resolve();\n        }\n        /**\n         * Return a fake SearchResultModel which can hold a flat list of all settings, to be filtered (@modified etc)\n         */\n        createFilterModel() {\n            const filterModel = this.instantiationService.createInstance(settingsTreeModels_1.SearchResultModel, this.viewState);\n            const fullResult = {\n                filterMatches: []\n            };\n            for (const g of this.defaultSettingsEditorModel.settingsGroups.slice(1)) {\n                for (const sect of g.sections) {\n                    for (const setting of sect.settings) {\n                        fullResult.filterMatches.push({ setting, matches: [], score: 0 });\n                    }\n                }\n            }\n            filterModel.setResult(0, fullResult);\n            return filterModel;\n        }\n        reportFilteringUsed(query, results) {\n            const nlpResult = results[settingsTreeModels_1.SearchResultIdx.Remote];\n            const nlpMetadata = nlpResult && nlpResult.metadata;\n            const durations = {};\n            durations['nlpResult'] = nlpMetadata && nlpMetadata.duration;\n            // Count unique results\n            const counts = {};\n            const filterResult = results[settingsTreeModels_1.SearchResultIdx.Local];\n            if (filterResult) {\n                counts['filterResult'] = filterResult.filterMatches.length;\n            }\n            if (nlpResult) {\n                counts['nlpResult'] = nlpResult.filterMatches.length;\n            }\n            const requestCount = nlpMetadata && nlpMetadata.requestCount;\n            const data = {\n                query,\n                durations,\n                counts,\n                requestCount\n            };\n            /* __GDPR__\n                \"settingsEditor.filter\" : {\n                    \"query\": { \"classification\": \"CustomerContent\", \"purpose\": \"FeatureInsight\" },\n                    \"durations.nlpResult\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"counts.nlpResult\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"counts.filterResult\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true },\n                    \"requestCount\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                }\n            */\n            this.telemetryService.publicLog('settingsEditor.filter', data);\n        }\n        triggerFilterPreferences(query) {\n            if (this.searchInProgress) {\n                this.searchInProgress.cancel();\n                this.searchInProgress = null;\n            }\n            // Trigger the local search. If it didn't find an exact match, trigger the remote search.\n            const searchInProgress = this.searchInProgress = new cancellation_1.CancellationTokenSource();\n            return this.localSearchDelayer.trigger(() => {\n                if (searchInProgress && !searchInProgress.token.isCancellationRequested) {\n                    return this.localFilterPreferences(query).then(result => {\n                        if (result && !result.exactMatch) {\n                            this.remoteSearchThrottle.trigger(() => {\n                                return searchInProgress && !searchInProgress.token.isCancellationRequested ?\n                                    this.remoteSearchPreferences(query, this.searchInProgress.token) :\n                                    Promise.resolve();\n                            });\n                        }\n                    });\n                }\n                else {\n                    return Promise.resolve();\n                }\n            });\n        }\n        localFilterPreferences(query, token) {\n            const localSearchProvider = this.preferencesSearchService.getLocalSearchProvider(query);\n            return this.filterOrSearchPreferences(query, settingsTreeModels_1.SearchResultIdx.Local, localSearchProvider, token);\n        }\n        remoteSearchPreferences(query, token) {\n            const remoteSearchProvider = this.preferencesSearchService.getRemoteSearchProvider(query);\n            const newExtSearchProvider = this.preferencesSearchService.getRemoteSearchProvider(query, true);\n            return Promise.all([\n                this.filterOrSearchPreferences(query, settingsTreeModels_1.SearchResultIdx.Remote, remoteSearchProvider, token),\n                this.filterOrSearchPreferences(query, settingsTreeModels_1.SearchResultIdx.NewExtensions, newExtSearchProvider, token)\n            ]).then(() => { });\n        }\n        filterOrSearchPreferences(query, type, searchProvider, token) {\n            return this._filterOrSearchPreferencesModel(query, this.defaultSettingsEditorModel, searchProvider, token).then(result => {\n                if (token && token.isCancellationRequested) {\n                    // Handle cancellation like this because cancellation is lost inside the search provider due to async/await\n                    return null;\n                }\n                if (!this.searchResultModel) {\n                    this.searchResultModel = this.instantiationService.createInstance(settingsTreeModels_1.SearchResultModel, this.viewState);\n                    this.searchResultModel.setResult(type, result);\n                    this.tocTreeModel.currentSearchModel = this.searchResultModel;\n                    this.onSearchModeToggled();\n                }\n                else {\n                    this.searchResultModel.setResult(type, result);\n                    this.tocTreeModel.update();\n                }\n                this.tocTree.setSelection([]);\n                this.viewState.filterToCategory = undefined;\n                this.tocTree.expandAll();\n                this.renderTree(undefined, true);\n                this.refreshTOCTree();\n                return result;\n            });\n        }\n        renderResultCountMessages() {\n            if (!this.currentSettingsModel) {\n                return;\n            }\n            if (this.tocTreeModel && this.tocTreeModel.settingsTreeRoot) {\n                const count = this.tocTreeModel.settingsTreeRoot.count;\n                switch (count) {\n                    case 0:\n                        this.countElement.innerText = nls_1.localize('noResults', \"No Settings Found\");\n                        break;\n                    case 1:\n                        this.countElement.innerText = nls_1.localize('oneResult', \"1 Setting Found\");\n                        break;\n                    default: this.countElement.innerText = nls_1.localize('moreThanOneResult', \"{0} Settings Found\", count);\n                }\n                this.countElement.style.display = 'block';\n                DOM.toggleClass(this.rootElement, 'no-results', count === 0);\n                this.clearFilterLinkContainer.style.display = this.viewState.tagFilters && this.viewState.tagFilters.size > 0\n                    ? 'initial'\n                    : 'none';\n            }\n        }\n        _filterOrSearchPreferencesModel(filter, model, provider, token) {\n            const searchP = provider ? provider.searchModel(model, token) : Promise.resolve(null);\n            return searchP\n                .then(null, err => {\n                if (errors_1.isPromiseCanceledError(err)) {\n                    return Promise.reject(err);\n                }\n                else {\n                    /* __GDPR__\n                        \"settingsEditor.searchError\" : {\n                            \"message\": { \"classification\": \"CallstackOrException\", \"purpose\": \"FeatureInsight\" },\n                            \"filter\": { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                        }\n                    */\n                    const message = errors_1.getErrorMessage(err).trim();\n                    if (message && message !== 'Error') {\n                        // \"Error\" = any generic network error\n                        this.telemetryService.publicLog('settingsEditor.searchError', { message, filter });\n                        this.logService.info('Setting search error: ' + message);\n                    }\n                    return Promise.resolve(null);\n                }\n            });\n        }\n        layoutTrees(dimension) {\n            const listHeight = dimension.height - (76 + 11 /* header height + padding*/);\n            const settingsTreeHeight = listHeight - 14;\n            this.settingsTreeContainer.style.height = `${settingsTreeHeight}px`;\n            this.settingsTree.layout(settingsTreeHeight, dimension.width);\n            const tocTreeHeight = listHeight - 16;\n            this.tocTreeContainer.style.height = `${tocTreeHeight}px`;\n            this.tocTree.layout(tocTreeHeight);\n        }\n        saveState() {\n            if (this.isVisible()) {\n                const searchQuery = this.searchWidget.getValue().trim();\n                const target = this.settingsTargetsWidget.settingsTarget;\n                if (this.group && this.input) {\n                    this.editorMemento.saveEditorState(this.group, this.input, { searchQuery, target });\n                }\n            }\n            super.saveState();\n        }\n    };\n    SettingsEditor2.ID = 'workbench.editor.settings2';\n    SettingsEditor2.NUM_INSTANCES = 0;\n    SettingsEditor2.SETTING_UPDATE_FAST_DEBOUNCE = 200;\n    SettingsEditor2.SETTING_UPDATE_SLOW_DEBOUNCE = 1000;\n    SettingsEditor2.SUGGESTIONS = [\n        `@${preferences_1.MODIFIED_SETTING_TAG}`, '@tag:usesOnlineServices'\n    ];\n    SettingsEditor2 = __decorate([\n        __param(0, telemetry_1.ITelemetryService),\n        __param(1, configuration_1.IConfigurationService),\n        __param(2, themeService_1.IThemeService),\n        __param(3, preferences_2.IPreferencesService),\n        __param(4, instantiation_1.IInstantiationService),\n        __param(5, preferences_1.IPreferencesSearchService),\n        __param(6, log_1.ILogService),\n        __param(7, contextkey_1.IContextKeyService),\n        __param(8, storage_1.IStorageService),\n        __param(9, notification_1.INotificationService),\n        __param(10, editorGroupsService_1.IEditorGroupsService),\n        __param(11, keybinding_1.IKeybindingService)\n    ], SettingsEditor2);\n    exports.SettingsEditor2 = SettingsEditor2;\n});\n",null]}