{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/output/common/outputChannelModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/output/common/outputChannelModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/platform/instantiation/common/instantiation\", \"vs/base/common/strings\", \"vs/base/common/event\", \"vs/base/common/async\", \"vs/platform/files/common/files\", \"vs/editor/common/services/modelService\", \"vs/editor/common/services/modeService\", \"vs/base/common/lifecycle\", \"vs/base/common/types\", \"vs/editor/common/core/editOperation\", \"vs/editor/common/core/position\", \"vs/base/common/arrays\", \"vs/base/common/uint\"], function (require, exports, instantiation_1, strings, event_1, async_1, files_1, modelService_1, modeService_1, lifecycle_1, types_1, editOperation_1, position_1, arrays_1, uint_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.IOutputChannelModelService = instantiation_1.createDecorator('outputChannelModelService');\n    let AsbtractOutputChannelModelService = class AsbtractOutputChannelModelService {\n        constructor(instantiationService) {\n            this.instantiationService = instantiationService;\n        }\n        createOutputChannelModel(id, modelUri, mimeType, file) {\n            return file ? this.instantiationService.createInstance(FileOutputChannelModel, modelUri, mimeType, file) : this.instantiationService.createInstance(BufferredOutputChannel, modelUri, mimeType);\n        }\n    };\n    AsbtractOutputChannelModelService = __decorate([\n        __param(0, instantiation_1.IInstantiationService)\n    ], AsbtractOutputChannelModelService);\n    exports.AsbtractOutputChannelModelService = AsbtractOutputChannelModelService;\n    class AbstractFileOutputChannelModel extends lifecycle_1.Disposable {\n        constructor(modelUri, mimeType, file, fileService, modelService, modeService) {\n            super();\n            this.modelUri = modelUri;\n            this.mimeType = mimeType;\n            this.file = file;\n            this.fileService = fileService;\n            this.modelService = modelService;\n            this.modeService = modeService;\n            this._onDidAppendedContent = new event_1.Emitter();\n            this.onDidAppendedContent = this._onDidAppendedContent.event;\n            this._onDispose = new event_1.Emitter();\n            this.onDispose = this._onDispose.event;\n            this.startOffset = 0;\n            this.endOffset = 0;\n            this.modelUpdater = new async_1.RunOnceScheduler(() => this.updateModel(), 300);\n            this._register(lifecycle_1.toDisposable(() => this.modelUpdater.cancel()));\n        }\n        clear(till) {\n            if (this.modelUpdater.isScheduled()) {\n                this.modelUpdater.cancel();\n                this.onUpdateModelCancelled();\n            }\n            if (this.model) {\n                this.model.setValue('');\n            }\n            this.endOffset = types_1.isNumber(till) ? till : this.endOffset;\n            this.startOffset = this.endOffset;\n        }\n        update() { }\n        createModel(content) {\n            if (this.model) {\n                this.model.setValue(content);\n            }\n            else {\n                this.model = this.modelService.createModel(content, this.modeService.create(this.mimeType), this.modelUri);\n                this.onModelCreated(this.model);\n                const disposables = [];\n                disposables.push(this.model.onWillDispose(() => {\n                    this.onModelWillDispose(this.model);\n                    this.model = null;\n                    lifecycle_1.dispose(disposables);\n                }));\n            }\n            return this.model;\n        }\n        appendToModel(content) {\n            if (this.model && content) {\n                const lastLine = this.model.getLineCount();\n                const lastLineMaxColumn = this.model.getLineMaxColumn(lastLine);\n                this.model.applyEdits([editOperation_1.EditOperation.insert(new position_1.Position(lastLine, lastLineMaxColumn), content)]);\n                this._onDidAppendedContent.fire();\n            }\n        }\n        onModelCreated(model) { }\n        onModelWillDispose(model) { }\n        onUpdateModelCancelled() { }\n        updateModel() { }\n        dispose() {\n            this._onDispose.fire();\n            super.dispose();\n        }\n    }\n    exports.AbstractFileOutputChannelModel = AbstractFileOutputChannelModel;\n    class OutputFileListener extends lifecycle_1.Disposable {\n        constructor(file, fileService) {\n            super();\n            this.file = file;\n            this.fileService = fileService;\n            this._onDidContentChange = new event_1.Emitter();\n            this.onDidContentChange = this._onDidContentChange.event;\n            this.watching = false;\n            this.syncDelayer = new async_1.ThrottledDelayer(500);\n        }\n        watch(eTag) {\n            if (!this.watching) {\n                this.etag = eTag;\n                this.poll();\n                this.watching = true;\n            }\n        }\n        poll() {\n            const loop = () => this.doWatch().then(() => this.poll());\n            this.syncDelayer.trigger(loop);\n        }\n        doWatch() {\n            return this.fileService.resolveFile(this.file, { resolveMetadata: true })\n                .then(stat => {\n                if (stat.etag !== this.etag) {\n                    this.etag = stat.etag;\n                    this._onDidContentChange.fire(stat.size);\n                }\n            });\n        }\n        unwatch() {\n            if (this.watching) {\n                this.syncDelayer.cancel();\n                this.watching = false;\n            }\n        }\n        dispose() {\n            this.unwatch();\n            super.dispose();\n        }\n    }\n    /**\n     * An output channel driven by a file and does not support appending messages.\n     */\n    let FileOutputChannelModel = class FileOutputChannelModel extends AbstractFileOutputChannelModel {\n        constructor(modelUri, mimeType, file, fileService, modelService, modeService) {\n            super(modelUri, mimeType, file, fileService, modelService, modeService);\n            this.updateInProgress = false;\n            this.etag = '';\n            this.loadModelPromise = null;\n            this.fileHandler = this._register(new OutputFileListener(this.file, this.fileService));\n            this._register(this.fileHandler.onDidContentChange(size => this.update(size)));\n            this._register(lifecycle_1.toDisposable(() => this.fileHandler.unwatch()));\n        }\n        loadModel() {\n            this.loadModelPromise = this.fileService.resolveContent(this.file, { position: this.startOffset, encoding: 'utf8' })\n                .then(content => {\n                this.endOffset = this.startOffset + this.getByteLength(content.value);\n                this.etag = content.etag;\n                return this.createModel(content.value);\n            });\n            return this.loadModelPromise;\n        }\n        clear(till) {\n            const loadModelPromise = this.loadModelPromise ? this.loadModelPromise : Promise.resolve();\n            loadModelPromise.then(() => {\n                super.clear(till);\n                this.update();\n            });\n        }\n        append(message) {\n            throw new Error('Not supported');\n        }\n        updateModel() {\n            if (this.model) {\n                this.fileService.resolveContent(this.file, { position: this.endOffset, encoding: 'utf8' })\n                    .then(content => {\n                    this.etag = content.etag;\n                    if (content.value) {\n                        this.endOffset = this.endOffset + this.getByteLength(content.value);\n                        this.appendToModel(content.value);\n                    }\n                    this.updateInProgress = false;\n                }, () => this.updateInProgress = false);\n            }\n            else {\n                this.updateInProgress = false;\n            }\n        }\n        onModelCreated(model) {\n            this.fileHandler.watch(this.etag);\n        }\n        onModelWillDispose(model) {\n            this.fileHandler.unwatch();\n        }\n        onUpdateModelCancelled() {\n            this.updateInProgress = false;\n        }\n        getByteLength(str) {\n            if (typeof Buffer !== 'undefined') {\n                return Buffer.from(str).byteLength;\n            }\n            return uint_1.toUint8ArrayBuffer(str).byteLength;\n        }\n        update(size) {\n            if (this.model) {\n                if (!this.updateInProgress) {\n                    this.updateInProgress = true;\n                    if (types_1.isNumber(size) && this.endOffset > size) { // Reset - Content is removed\n                        this.startOffset = this.endOffset = 0;\n                        this.model.setValue('');\n                    }\n                    this.modelUpdater.schedule();\n                }\n            }\n        }\n    };\n    FileOutputChannelModel = __decorate([\n        __param(3, files_1.IFileService),\n        __param(4, modelService_1.IModelService),\n        __param(5, modeService_1.IModeService)\n    ], FileOutputChannelModel);\n    let BufferredOutputChannel = class BufferredOutputChannel extends lifecycle_1.Disposable {\n        constructor(modelUri, mimeType, modelService, modeService) {\n            super();\n            this.modelUri = modelUri;\n            this.mimeType = mimeType;\n            this.modelService = modelService;\n            this.modeService = modeService;\n            this.file = null;\n            this.scrollLock = false;\n            this._onDidAppendedContent = new event_1.Emitter();\n            this.onDidAppendedContent = this._onDidAppendedContent.event;\n            this._onDispose = new event_1.Emitter();\n            this.onDispose = this._onDispose.event;\n            this.lastReadId = undefined;\n            this.modelUpdater = new async_1.RunOnceScheduler(() => this.updateModel(), 300);\n            this._register(lifecycle_1.toDisposable(() => this.modelUpdater.cancel()));\n            this.bufferredContent = new BufferedContent();\n            this._register(lifecycle_1.toDisposable(() => this.bufferredContent.clear()));\n        }\n        append(output) {\n            this.bufferredContent.append(output);\n            if (!this.modelUpdater.isScheduled()) {\n                this.modelUpdater.schedule();\n            }\n        }\n        update() { }\n        clear() {\n            if (this.modelUpdater.isScheduled()) {\n                this.modelUpdater.cancel();\n            }\n            if (this.model) {\n                this.model.setValue('');\n            }\n            this.bufferredContent.clear();\n            this.lastReadId = undefined;\n        }\n        loadModel() {\n            const { value, id } = this.bufferredContent.getDelta(this.lastReadId);\n            if (this.model) {\n                this.model.setValue(value);\n            }\n            else {\n                this.model = this.createModel(value);\n            }\n            this.lastReadId = id;\n            return Promise.resolve(this.model);\n        }\n        createModel(content) {\n            const model = this.modelService.createModel(content, this.modeService.create(this.mimeType), this.modelUri);\n            const disposables = [];\n            disposables.push(model.onWillDispose(() => {\n                this.model = null;\n                lifecycle_1.dispose(disposables);\n            }));\n            return model;\n        }\n        updateModel() {\n            if (this.model) {\n                const { value, id } = this.bufferredContent.getDelta(this.lastReadId);\n                this.lastReadId = id;\n                const lastLine = this.model.getLineCount();\n                const lastLineMaxColumn = this.model.getLineMaxColumn(lastLine);\n                this.model.applyEdits([editOperation_1.EditOperation.insert(new position_1.Position(lastLine, lastLineMaxColumn), value)]);\n                this._onDidAppendedContent.fire();\n            }\n        }\n        dispose() {\n            this._onDispose.fire();\n            super.dispose();\n        }\n    };\n    BufferredOutputChannel = __decorate([\n        __param(2, modelService_1.IModelService),\n        __param(3, modeService_1.IModeService)\n    ], BufferredOutputChannel);\n    exports.BufferredOutputChannel = BufferredOutputChannel;\n    class BufferedContent {\n        constructor() {\n            this.data = [];\n            this.dataIds = [];\n            this.idPool = 0;\n            this.length = 0;\n        }\n        append(content) {\n            this.data.push(content);\n            this.dataIds.push(++this.idPool);\n            this.length += content.length;\n            this.trim();\n        }\n        clear() {\n            this.data.length = 0;\n            this.dataIds.length = 0;\n            this.length = 0;\n        }\n        trim() {\n            if (this.length < BufferedContent.MAX_OUTPUT_LENGTH * 1.2) {\n                return;\n            }\n            while (this.length > BufferedContent.MAX_OUTPUT_LENGTH) {\n                this.dataIds.shift();\n                const removed = this.data.shift();\n                if (removed) {\n                    this.length -= removed.length;\n                }\n            }\n        }\n        getDelta(previousId) {\n            let idx = -1;\n            if (previousId !== undefined) {\n                idx = arrays_1.binarySearch(this.dataIds, previousId, (a, b) => a - b);\n            }\n            const id = this.idPool;\n            if (idx >= 0) {\n                const value = strings.removeAnsiEscapeCodes(this.data.slice(idx + 1).join(''));\n                return { value, id };\n            }\n            else {\n                const value = strings.removeAnsiEscapeCodes(this.data.join(''));\n                return { value, id };\n            }\n        }\n    }\n    BufferedContent.MAX_OUTPUT_LENGTH = 10000 /* Max. number of output lines to show in output */ * 100 /* Guestimated chars per line */;\n});\n",null]}