{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar event_1 = require(\"vs/base/common/event\");\nvar lifecycle_1 = require(\"vs/base/common/lifecycle\");\nvar async_1 = require(\"vs/base/common/async\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\nvar errors = require(\"vs/base/common/errors\");\nvar buffer_1 = require(\"vs/base/common/buffer\");\nvar RequestType;\n(function (RequestType) {\n    RequestType[RequestType[\"Promise\"] = 100] = \"Promise\";\n    RequestType[RequestType[\"PromiseCancel\"] = 101] = \"PromiseCancel\";\n    RequestType[RequestType[\"EventListen\"] = 102] = \"EventListen\";\n    RequestType[RequestType[\"EventDispose\"] = 103] = \"EventDispose\";\n})(RequestType = exports.RequestType || (exports.RequestType = {}));\nvar ResponseType;\n(function (ResponseType) {\n    ResponseType[ResponseType[\"Initialize\"] = 200] = \"Initialize\";\n    ResponseType[ResponseType[\"PromiseSuccess\"] = 201] = \"PromiseSuccess\";\n    ResponseType[ResponseType[\"PromiseError\"] = 202] = \"PromiseError\";\n    ResponseType[ResponseType[\"PromiseErrorObj\"] = 203] = \"PromiseErrorObj\";\n    ResponseType[ResponseType[\"EventFire\"] = 204] = \"EventFire\";\n})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));\nvar State;\n(function (State) {\n    State[State[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    State[State[\"Idle\"] = 1] = \"Idle\";\n})(State || (State = {}));\nvar BufferReader = /** @class */ (function () {\n    function BufferReader(buffer) {\n        this.buffer = buffer;\n        this.pos = 0;\n    }\n    BufferReader.prototype.read = function (bytes) {\n        var result = this.buffer.slice(this.pos, this.pos + bytes);\n        this.pos += result.byteLength;\n        return result;\n    };\n    return BufferReader;\n}());\nvar BufferWriter = /** @class */ (function () {\n    function BufferWriter() {\n        this.buffers = [];\n    }\n    Object.defineProperty(BufferWriter.prototype, \"buffer\", {\n        get: function () {\n            return buffer_1.VSBuffer.concat(this.buffers);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BufferWriter.prototype.write = function (buffer) {\n        this.buffers.push(buffer);\n    };\n    return BufferWriter;\n}());\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Undefined\"] = 0] = \"Undefined\";\n    DataType[DataType[\"String\"] = 1] = \"String\";\n    DataType[DataType[\"Buffer\"] = 2] = \"Buffer\";\n    DataType[DataType[\"VSBuffer\"] = 3] = \"VSBuffer\";\n    DataType[DataType[\"Array\"] = 4] = \"Array\";\n    DataType[DataType[\"Object\"] = 5] = \"Object\";\n})(DataType || (DataType = {}));\nfunction createSizeBuffer(size) {\n    var result = buffer_1.VSBuffer.alloc(4);\n    result.writeUint32BE(size, 0);\n    return result;\n}\nfunction readSizeBuffer(reader) {\n    return reader.read(4).readUint32BE(0);\n}\nfunction createOneByteBuffer(value) {\n    var result = buffer_1.VSBuffer.alloc(1);\n    result.writeUint8(value, 0);\n    return result;\n}\nvar BufferPresets = {\n    Undefined: createOneByteBuffer(DataType.Undefined),\n    String: createOneByteBuffer(DataType.String),\n    Buffer: createOneByteBuffer(DataType.Buffer),\n    VSBuffer: createOneByteBuffer(DataType.VSBuffer),\n    Array: createOneByteBuffer(DataType.Array),\n    Object: createOneByteBuffer(DataType.Object),\n};\nvar hasBuffer = (typeof Buffer !== 'undefined');\nfunction serialize(writer, data) {\n    if (typeof data === 'undefined') {\n        writer.write(BufferPresets.Undefined);\n    }\n    else if (typeof data === 'string') {\n        var buffer = buffer_1.VSBuffer.fromString(data);\n        writer.write(BufferPresets.String);\n        writer.write(createSizeBuffer(buffer.byteLength));\n        writer.write(buffer);\n    }\n    else if (hasBuffer && Buffer.isBuffer(data)) {\n        var buffer = buffer_1.VSBuffer.wrap(data);\n        writer.write(BufferPresets.Buffer);\n        writer.write(createSizeBuffer(buffer.byteLength));\n        writer.write(buffer);\n    }\n    else if (data instanceof buffer_1.VSBuffer) {\n        writer.write(BufferPresets.VSBuffer);\n        writer.write(createSizeBuffer(data.byteLength));\n        writer.write(data);\n    }\n    else if (Array.isArray(data)) {\n        writer.write(BufferPresets.Array);\n        writer.write(createSizeBuffer(data.length));\n        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n            var el = data_1[_i];\n            serialize(writer, el);\n        }\n    }\n    else {\n        var buffer = buffer_1.VSBuffer.fromString(JSON.stringify(data));\n        writer.write(BufferPresets.Object);\n        writer.write(createSizeBuffer(buffer.byteLength));\n        writer.write(buffer);\n    }\n}\nfunction deserialize(reader) {\n    var type = reader.read(1).readUint8(0);\n    switch (type) {\n        case DataType.Undefined: return undefined;\n        case DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n        case DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;\n        case DataType.VSBuffer: return reader.read(readSizeBuffer(reader));\n        case DataType.Array: {\n            var length = readSizeBuffer(reader);\n            var result = [];\n            for (var i = 0; i < length; i++) {\n                result.push(deserialize(reader));\n            }\n            return result;\n        }\n        case DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n    }\n}\nvar ChannelServer = /** @class */ (function () {\n    function ChannelServer(protocol, ctx) {\n        var _this = this;\n        this.protocol = protocol;\n        this.ctx = ctx;\n        this.channels = new Map();\n        this.activeRequests = new Map();\n        this.protocolListener = this.protocol.onMessage(function (msg) { return _this.onRawMessage(msg); });\n        this.sendResponse({ type: ResponseType.Initialize });\n    }\n    ChannelServer.prototype.registerChannel = function (channelName, channel) {\n        this.channels.set(channelName, channel);\n    };\n    ChannelServer.prototype.sendResponse = function (response) {\n        switch (response.type) {\n            case ResponseType.Initialize:\n                return this.send([response.type]);\n            case ResponseType.PromiseSuccess:\n            case ResponseType.PromiseError:\n            case ResponseType.EventFire:\n            case ResponseType.PromiseErrorObj:\n                return this.send([response.type, response.id], response.data);\n        }\n    };\n    ChannelServer.prototype.send = function (header, body) {\n        if (body === void 0) { body = undefined; }\n        var writer = new BufferWriter();\n        serialize(writer, header);\n        serialize(writer, body);\n        this.sendBuffer(writer.buffer);\n    };\n    ChannelServer.prototype.sendBuffer = function (message) {\n        try {\n            this.protocol.send(message);\n        }\n        catch (err) {\n            // noop\n        }\n    };\n    ChannelServer.prototype.onRawMessage = function (message) {\n        var reader = new BufferReader(message);\n        var header = deserialize(reader);\n        var body = deserialize(reader);\n        var type = header[0];\n        switch (type) {\n            case RequestType.Promise:\n                return this.onPromise({ type: type, id: header[1], channelName: header[2], name: header[3], arg: body });\n            case RequestType.EventListen:\n                return this.onEventListen({ type: type, id: header[1], channelName: header[2], name: header[3], arg: body });\n            case RequestType.PromiseCancel:\n                return this.disposeActiveRequest({ type: type, id: header[1] });\n            case RequestType.EventDispose:\n                return this.disposeActiveRequest({ type: type, id: header[1] });\n        }\n    };\n    ChannelServer.prototype.onPromise = function (request) {\n        var _this = this;\n        var channel = this.channels.get(request.channelName);\n        if (!channel) {\n            throw new Error('Unknown channel');\n        }\n        var cancellationTokenSource = new cancellation_1.CancellationTokenSource();\n        var promise;\n        try {\n            promise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n        }\n        catch (err) {\n            promise = Promise.reject(err);\n        }\n        var id = request.id;\n        promise.then(function (data) {\n            _this.sendResponse({ id: id, data: data, type: ResponseType.PromiseSuccess });\n            _this.activeRequests.delete(request.id);\n        }, function (err) {\n            if (err instanceof Error) {\n                _this.sendResponse({\n                    id: id, data: {\n                        message: err.message,\n                        name: err.name,\n                        stack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n                    }, type: ResponseType.PromiseError\n                });\n            }\n            else {\n                _this.sendResponse({ id: id, data: err, type: ResponseType.PromiseErrorObj });\n            }\n            _this.activeRequests.delete(request.id);\n        });\n        var disposable = lifecycle_1.toDisposable(function () { return cancellationTokenSource.cancel(); });\n        this.activeRequests.set(request.id, disposable);\n    };\n    ChannelServer.prototype.onEventListen = function (request) {\n        var _this = this;\n        var channel = this.channels.get(request.channelName);\n        if (!channel) {\n            throw new Error('Unknown channel');\n        }\n        var id = request.id;\n        var event = channel.listen(this.ctx, request.name, request.arg);\n        var disposable = event(function (data) { return _this.sendResponse({ id: id, data: data, type: ResponseType.EventFire }); });\n        this.activeRequests.set(request.id, disposable);\n    };\n    ChannelServer.prototype.disposeActiveRequest = function (request) {\n        var disposable = this.activeRequests.get(request.id);\n        if (disposable) {\n            disposable.dispose();\n            this.activeRequests.delete(request.id);\n        }\n    };\n    ChannelServer.prototype.dispose = function () {\n        if (this.protocolListener) {\n            this.protocolListener.dispose();\n            this.protocolListener = null;\n        }\n        this.activeRequests.forEach(function (d) { return d.dispose(); });\n        this.activeRequests.clear();\n    };\n    return ChannelServer;\n}());\nexports.ChannelServer = ChannelServer;\nvar ChannelClient = /** @class */ (function () {\n    function ChannelClient(protocol) {\n        var _this = this;\n        this.protocol = protocol;\n        this.state = State.Uninitialized;\n        this.activeRequests = new Set();\n        this.handlers = new Map();\n        this.lastRequestId = 0;\n        this._onDidInitialize = new event_1.Emitter();\n        this.onDidInitialize = this._onDidInitialize.event;\n        this.protocolListener = this.protocol.onMessage(function (msg) { return _this.onBuffer(msg); });\n    }\n    ChannelClient.prototype.getChannel = function (channelName) {\n        var that = this;\n        return {\n            call: function (command, arg, cancellationToken) {\n                return that.requestPromise(channelName, command, arg, cancellationToken);\n            },\n            listen: function (event, arg) {\n                return that.requestEvent(channelName, event, arg);\n            }\n        };\n    };\n    ChannelClient.prototype.requestPromise = function (channelName, name, arg, cancellationToken) {\n        var _this = this;\n        if (cancellationToken === void 0) { cancellationToken = cancellation_1.CancellationToken.None; }\n        var id = this.lastRequestId++;\n        var type = RequestType.Promise;\n        var request = { id: id, type: type, channelName: channelName, name: name, arg: arg };\n        if (cancellationToken.isCancellationRequested) {\n            return Promise.reject(errors.canceled());\n        }\n        var disposable;\n        var result = new Promise(function (c, e) {\n            if (cancellationToken.isCancellationRequested) {\n                return e(errors.canceled());\n            }\n            var uninitializedPromise = async_1.createCancelablePromise(function (_) { return _this.whenInitialized(); });\n            uninitializedPromise.then(function () {\n                uninitializedPromise = null;\n                var handler = function (response) {\n                    switch (response.type) {\n                        case ResponseType.PromiseSuccess:\n                            _this.handlers.delete(id);\n                            c(response.data);\n                            break;\n                        case ResponseType.PromiseError:\n                            _this.handlers.delete(id);\n                            var error = new Error(response.data.message);\n                            error.stack = response.data.stack;\n                            error.name = response.data.name;\n                            e(error);\n                            break;\n                        case ResponseType.PromiseErrorObj:\n                            _this.handlers.delete(id);\n                            e(response.data);\n                            break;\n                    }\n                };\n                _this.handlers.set(id, handler);\n                _this.sendRequest(request);\n            });\n            var cancel = function () {\n                if (uninitializedPromise) {\n                    uninitializedPromise.cancel();\n                    uninitializedPromise = null;\n                }\n                else {\n                    _this.sendRequest({ id: id, type: RequestType.PromiseCancel });\n                }\n                e(errors.canceled());\n            };\n            var cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n            disposable = lifecycle_1.combinedDisposable([lifecycle_1.toDisposable(cancel), cancellationTokenListener]);\n            _this.activeRequests.add(disposable);\n        });\n        return result.finally(function () { return _this.activeRequests.delete(disposable); });\n    };\n    ChannelClient.prototype.requestEvent = function (channelName, name, arg) {\n        var _this = this;\n        var id = this.lastRequestId++;\n        var type = RequestType.EventListen;\n        var request = { id: id, type: type, channelName: channelName, name: name, arg: arg };\n        var uninitializedPromise = null;\n        var emitter = new event_1.Emitter({\n            onFirstListenerAdd: function () {\n                uninitializedPromise = async_1.createCancelablePromise(function (_) { return _this.whenInitialized(); });\n                uninitializedPromise.then(function () {\n                    uninitializedPromise = null;\n                    _this.activeRequests.add(emitter);\n                    _this.sendRequest(request);\n                });\n            },\n            onLastListenerRemove: function () {\n                if (uninitializedPromise) {\n                    uninitializedPromise.cancel();\n                    uninitializedPromise = null;\n                }\n                else {\n                    _this.activeRequests.delete(emitter);\n                    _this.sendRequest({ id: id, type: RequestType.EventDispose });\n                }\n            }\n        });\n        var handler = function (res) { return emitter.fire(res.data); };\n        this.handlers.set(id, handler);\n        return emitter.event;\n    };\n    ChannelClient.prototype.sendRequest = function (request) {\n        switch (request.type) {\n            case RequestType.Promise:\n            case RequestType.EventListen:\n                return this.send([request.type, request.id, request.channelName, request.name], request.arg);\n            case RequestType.PromiseCancel:\n            case RequestType.EventDispose:\n                return this.send([request.type, request.id]);\n        }\n    };\n    ChannelClient.prototype.send = function (header, body) {\n        if (body === void 0) { body = undefined; }\n        var writer = new BufferWriter();\n        serialize(writer, header);\n        serialize(writer, body);\n        this.sendBuffer(writer.buffer);\n    };\n    ChannelClient.prototype.sendBuffer = function (message) {\n        try {\n            this.protocol.send(message);\n        }\n        catch (err) {\n            // noop\n        }\n    };\n    ChannelClient.prototype.onBuffer = function (message) {\n        var reader = new BufferReader(message);\n        var header = deserialize(reader);\n        var body = deserialize(reader);\n        var type = header[0];\n        switch (type) {\n            case ResponseType.Initialize:\n                return this.onResponse({ type: header[0] });\n            case ResponseType.PromiseSuccess:\n            case ResponseType.PromiseError:\n            case ResponseType.EventFire:\n            case ResponseType.PromiseErrorObj:\n                return this.onResponse({ type: header[0], id: header[1], data: body });\n        }\n    };\n    ChannelClient.prototype.onResponse = function (response) {\n        if (response.type === ResponseType.Initialize) {\n            this.state = State.Idle;\n            this._onDidInitialize.fire();\n            return;\n        }\n        var handler = this.handlers.get(response.id);\n        if (handler) {\n            handler(response);\n        }\n    };\n    ChannelClient.prototype.whenInitialized = function () {\n        if (this.state === State.Idle) {\n            return Promise.resolve();\n        }\n        else {\n            return event_1.Event.toPromise(this.onDidInitialize);\n        }\n    };\n    ChannelClient.prototype.dispose = function () {\n        if (this.protocolListener) {\n            this.protocolListener.dispose();\n            this.protocolListener = null;\n        }\n        this.activeRequests.forEach(function (p) { return p.dispose(); });\n        this.activeRequests.clear();\n    };\n    return ChannelClient;\n}());\nexports.ChannelClient = ChannelClient;\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nvar IPCServer = /** @class */ (function () {\n    function IPCServer(onDidClientConnect) {\n        var _this = this;\n        this.channels = new Map();\n        this._connections = new Set();\n        this._onDidChangeConnections = new event_1.Emitter();\n        this.onDidChangeConnections = this._onDidChangeConnections.event;\n        onDidClientConnect(function (_a) {\n            var protocol = _a.protocol, onDidClientDisconnect = _a.onDidClientDisconnect;\n            var onFirstMessage = event_1.Event.once(protocol.onMessage);\n            onFirstMessage(function (msg) {\n                var reader = new BufferReader(msg);\n                var ctx = deserialize(reader);\n                var channelServer = new ChannelServer(protocol, ctx);\n                var channelClient = new ChannelClient(protocol);\n                _this.channels.forEach(function (channel, name) { return channelServer.registerChannel(name, channel); });\n                var connection = { channelClient: channelClient, ctx: ctx };\n                _this._connections.add(connection);\n                _this._onDidChangeConnections.fire(connection);\n                onDidClientDisconnect(function () {\n                    channelServer.dispose();\n                    channelClient.dispose();\n                    _this._connections.delete(connection);\n                });\n            });\n        });\n    }\n    Object.defineProperty(IPCServer.prototype, \"connections\", {\n        get: function () {\n            var result = [];\n            this._connections.forEach(function (ctx) { return result.push(ctx); });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    IPCServer.prototype.getChannel = function (channelName, router) {\n        var that = this;\n        return {\n            call: function (command, arg, cancellationToken) {\n                var channelPromise = router.routeCall(that, command, arg)\n                    .then(function (connection) { return connection.channelClient.getChannel(channelName); });\n                return getDelayedChannel(channelPromise)\n                    .call(command, arg, cancellationToken);\n            },\n            listen: function (event, arg) {\n                var channelPromise = router.routeEvent(that, event, arg)\n                    .then(function (connection) { return connection.channelClient.getChannel(channelName); });\n                return getDelayedChannel(channelPromise)\n                    .listen(event, arg);\n            }\n        };\n    };\n    IPCServer.prototype.registerChannel = function (channelName, channel) {\n        this.channels.set(channelName, channel);\n    };\n    IPCServer.prototype.dispose = function () {\n        this.channels.clear();\n        this._connections.clear();\n        this._onDidChangeConnections.dispose();\n    };\n    return IPCServer;\n}());\nexports.IPCServer = IPCServer;\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nvar IPCClient = /** @class */ (function () {\n    function IPCClient(protocol, ctx) {\n        var writer = new BufferWriter();\n        serialize(writer, ctx);\n        protocol.send(writer.buffer);\n        this.channelClient = new ChannelClient(protocol);\n        this.channelServer = new ChannelServer(protocol, ctx);\n    }\n    IPCClient.prototype.getChannel = function (channelName) {\n        return this.channelClient.getChannel(channelName);\n    };\n    IPCClient.prototype.registerChannel = function (channelName, channel) {\n        this.channelServer.registerChannel(channelName, channel);\n    };\n    IPCClient.prototype.dispose = function () {\n        this.channelClient.dispose();\n        this.channelServer.dispose();\n    };\n    return IPCClient;\n}());\nexports.IPCClient = IPCClient;\nfunction getDelayedChannel(promise) {\n    return {\n        call: function (command, arg, cancellationToken) {\n            return promise.then(function (c) { return c.call(command, arg, cancellationToken); });\n        },\n        listen: function (event, arg) {\n            var relay = new event_1.Relay();\n            promise.then(function (c) { return relay.input = c.listen(event, arg); });\n            return relay.event;\n        }\n    };\n}\nexports.getDelayedChannel = getDelayedChannel;\nfunction getNextTickChannel(channel) {\n    var didTick = false;\n    return {\n        call: function (command, arg, cancellationToken) {\n            if (didTick) {\n                return channel.call(command, arg, cancellationToken);\n            }\n            return async_1.timeout(0)\n                .then(function () { return didTick = true; })\n                .then(function () { return channel.call(command, arg, cancellationToken); });\n        },\n        listen: function (event, arg) {\n            if (didTick) {\n                return channel.listen(event, arg);\n            }\n            var relay = new event_1.Relay();\n            async_1.timeout(0)\n                .then(function () { return didTick = true; })\n                .then(function () { return relay.input = channel.listen(event, arg); });\n            return relay.event;\n        }\n    };\n}\nexports.getNextTickChannel = getNextTickChannel;\nvar StaticRouter = /** @class */ (function () {\n    function StaticRouter(fn) {\n        this.fn = fn;\n    }\n    StaticRouter.prototype.routeCall = function (hub) {\n        return this.route(hub);\n    };\n    StaticRouter.prototype.routeEvent = function (hub) {\n        return this.route(hub);\n    };\n    StaticRouter.prototype.route = function (hub) {\n        return tslib_1.__awaiter(this, void 0, Promise, function () {\n            var _i, _a, connection;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _i = 0, _a = hub.connections;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < _a.length)) return [3 /*break*/, 4];\n                        connection = _a[_i];\n                        return [4 /*yield*/, Promise.resolve(this.fn(connection.ctx))];\n                    case 2:\n                        if (_b.sent()) {\n                            return [2 /*return*/, Promise.resolve(connection)];\n                        }\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4: return [4 /*yield*/, event_1.Event.toPromise(hub.onDidChangeConnections)];\n                    case 5:\n                        _b.sent();\n                        return [4 /*yield*/, this.route(hub)];\n                    case 6: return [2 /*return*/, _b.sent()];\n                }\n            });\n        });\n    };\n    return StaticRouter;\n}());\nexports.StaticRouter = StaticRouter;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/common/ipc.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event, Emitter, Relay } from 'vs/base/common/event';\nimport { IDisposable, toDisposable, combinedDisposable } from 'vs/base/common/lifecycle';\nimport { CancelablePromise, createCancelablePromise, timeout } from 'vs/base/common/async';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport * as errors from 'vs/base/common/errors';\nimport { IServerChannel, IChannel } from 'vs/base/parts/ipc/common/ipc';\nimport { VSBuffer } from 'vs/base/common/buffer';\n\n/**\n * An `IChannel` is an abstraction over a collection of commands.\n * You can `call` several commands on a channel, each taking at\n * most one single argument. A `call` always returns a promise\n * with at most one single return value.\n */\nexport interface IChannel {\n\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(event: string, arg?: any): Event<T>;\n}\n\n/**\n * An `IServerChannel` is the couter part to `IChannel`,\n * on the server-side. You should implement this interface\n * if you'd like to handle remote promises or events.\n */\nexport interface IServerChannel<TContext = string> {\n\tcall<T>(ctx: TContext, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T>;\n\tlisten<T>(ctx: TContext, event: string, arg?: any): Event<T>;\n}\n\n\nexport const enum RequestType {\n\tPromise = 100,\n\tPromiseCancel = 101,\n\tEventListen = 102,\n\tEventDispose = 103\n}\n\ntype IRawPromiseRequest = { type: RequestType.Promise; id: number; channelName: string; name: string; arg: any; };\ntype IRawPromiseCancelRequest = { type: RequestType.PromiseCancel, id: number };\ntype IRawEventListenRequest = { type: RequestType.EventListen; id: number; channelName: string; name: string; arg: any; };\ntype IRawEventDisposeRequest = { type: RequestType.EventDispose, id: number };\ntype IRawRequest = IRawPromiseRequest | IRawPromiseCancelRequest | IRawEventListenRequest | IRawEventDisposeRequest;\n\nexport const enum ResponseType {\n\tInitialize = 200,\n\tPromiseSuccess = 201,\n\tPromiseError = 202,\n\tPromiseErrorObj = 203,\n\tEventFire = 204\n}\n\ntype IRawInitializeResponse = { type: ResponseType.Initialize };\ntype IRawPromiseSuccessResponse = { type: ResponseType.PromiseSuccess; id: number; data: any };\ntype IRawPromiseErrorResponse = { type: ResponseType.PromiseError; id: number; data: { message: string, name: string, stack: string[] | undefined } };\ntype IRawPromiseErrorObjResponse = { type: ResponseType.PromiseErrorObj; id: number; data: any };\ntype IRawEventFireResponse = { type: ResponseType.EventFire; id: number; data: any };\ntype IRawResponse = IRawInitializeResponse | IRawPromiseSuccessResponse | IRawPromiseErrorResponse | IRawPromiseErrorObjResponse | IRawEventFireResponse;\n\ninterface IHandler {\n\t(response: IRawResponse): void;\n}\n\nexport interface IMessagePassingProtocol {\n\tsend(buffer: VSBuffer): void;\n\tonMessage: Event<VSBuffer>;\n}\n\nenum State {\n\tUninitialized,\n\tIdle\n}\n\n/**\n * An `IChannelServer` hosts a collection of channels. You are\n * able to register channels onto it, provided a channel name.\n */\nexport interface IChannelServer<TContext = string> {\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void;\n}\n\n/**\n * An `IChannelClient` has access to a collection of channels. You\n * are able to get those channels, given their channel name.\n */\nexport interface IChannelClient {\n\tgetChannel<T extends IChannel>(channelName: string): T;\n}\n\nexport interface Client<TContext> {\n\treadonly ctx: TContext;\n}\n\nexport interface IConnectionHub<TContext> {\n\treadonly connections: Connection<TContext>[];\n\treadonly onDidChangeConnections: Event<Connection<TContext>>;\n}\n\n/**\n * An `IClientRouter` is responsible for routing calls to specific\n * channels, in scenarios in which there are multiple possible\n * channels (each from a separate client) to pick from.\n */\nexport interface IClientRouter<TContext = string> {\n\trouteCall(hub: IConnectionHub<TContext>, command: string, arg?: any, cancellationToken?: CancellationToken): Promise<Client<TContext>>;\n\trouteEvent(hub: IConnectionHub<TContext>, event: string, arg?: any): Promise<Client<TContext>>;\n}\n\n/**\n * Similar to the `IChannelClient`, you can get channels from this\n * collection of channels. The difference being that in the\n * `IRoutingChannelClient`, there are multiple clients providing\n * the same channel. You'll need to pass in an `IClientRouter` in\n * order to pick the right one.\n */\nexport interface IRoutingChannelClient<TContext = string> {\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T;\n}\n\ninterface IReader {\n\tread(bytes: number): VSBuffer;\n}\n\ninterface IWriter {\n\twrite(buffer: VSBuffer): void;\n}\n\nclass BufferReader implements IReader {\n\n\tprivate pos = 0;\n\n\tconstructor(private buffer: VSBuffer) { }\n\n\tread(bytes: number): VSBuffer {\n\t\tconst result = this.buffer.slice(this.pos, this.pos + bytes);\n\t\tthis.pos += result.byteLength;\n\t\treturn result;\n\t}\n}\n\nclass BufferWriter implements IWriter {\n\n\tprivate buffers: VSBuffer[] = [];\n\n\tget buffer(): VSBuffer {\n\t\treturn VSBuffer.concat(this.buffers);\n\t}\n\n\twrite(buffer: VSBuffer): void {\n\t\tthis.buffers.push(buffer);\n\t}\n}\n\nenum DataType {\n\tUndefined = 0,\n\tString = 1,\n\tBuffer = 2,\n\tVSBuffer = 3,\n\tArray = 4,\n\tObject = 5\n}\n\nfunction createSizeBuffer(size: number): VSBuffer {\n\tconst result = VSBuffer.alloc(4);\n\tresult.writeUint32BE(size, 0);\n\treturn result;\n}\n\nfunction readSizeBuffer(reader: IReader): number {\n\treturn reader.read(4).readUint32BE(0);\n}\n\nfunction createOneByteBuffer(value: number): VSBuffer {\n\tconst result = VSBuffer.alloc(1);\n\tresult.writeUint8(value, 0);\n\treturn result;\n}\n\nconst BufferPresets = {\n\tUndefined: createOneByteBuffer(DataType.Undefined),\n\tString: createOneByteBuffer(DataType.String),\n\tBuffer: createOneByteBuffer(DataType.Buffer),\n\tVSBuffer: createOneByteBuffer(DataType.VSBuffer),\n\tArray: createOneByteBuffer(DataType.Array),\n\tObject: createOneByteBuffer(DataType.Object),\n};\n\ndeclare var Buffer: any;\nconst hasBuffer = (typeof Buffer !== 'undefined');\n\nfunction serialize(writer: IWriter, data: any): void {\n\tif (typeof data === 'undefined') {\n\t\twriter.write(BufferPresets.Undefined);\n\t} else if (typeof data === 'string') {\n\t\tconst buffer = VSBuffer.fromString(data);\n\t\twriter.write(BufferPresets.String);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (hasBuffer && Buffer.isBuffer(data)) {\n\t\tconst buffer = VSBuffer.wrap(data);\n\t\twriter.write(BufferPresets.Buffer);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t} else if (data instanceof VSBuffer) {\n\t\twriter.write(BufferPresets.VSBuffer);\n\t\twriter.write(createSizeBuffer(data.byteLength));\n\t\twriter.write(data);\n\t} else if (Array.isArray(data)) {\n\t\twriter.write(BufferPresets.Array);\n\t\twriter.write(createSizeBuffer(data.length));\n\n\t\tfor (const el of data) {\n\t\t\tserialize(writer, el);\n\t\t}\n\t} else {\n\t\tconst buffer = VSBuffer.fromString(JSON.stringify(data));\n\t\twriter.write(BufferPresets.Object);\n\t\twriter.write(createSizeBuffer(buffer.byteLength));\n\t\twriter.write(buffer);\n\t}\n}\n\nfunction deserialize(reader: IReader): any {\n\tconst type = reader.read(1).readUint8(0);\n\n\tswitch (type) {\n\t\tcase DataType.Undefined: return undefined;\n\t\tcase DataType.String: return reader.read(readSizeBuffer(reader)).toString();\n\t\tcase DataType.Buffer: return reader.read(readSizeBuffer(reader)).buffer;\n\t\tcase DataType.VSBuffer: return reader.read(readSizeBuffer(reader));\n\t\tcase DataType.Array: {\n\t\t\tconst length = readSizeBuffer(reader);\n\t\t\tconst result: any[] = [];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(deserialize(reader));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\t\tcase DataType.Object: return JSON.parse(reader.read(readSizeBuffer(reader)).toString());\n\t}\n}\n\nexport class ChannelServer<TContext = string> implements IChannelServer<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate activeRequests = new Map<number, IDisposable>();\n\tprivate protocolListener: IDisposable | null;\n\n\tconstructor(private protocol: IMessagePassingProtocol, private ctx: TContext) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onRawMessage(msg));\n\t\tthis.sendResponse({ type: ResponseType.Initialize });\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tprivate sendResponse(response: IRawResponse): void {\n\t\tswitch (response.type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.send([response.type]);\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.send([response.type, response.id], response.data);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onRawMessage(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type = header[0] as RequestType;\n\n\t\tswitch (type) {\n\t\t\tcase RequestType.Promise:\n\t\t\t\treturn this.onPromise({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.onEventListen({ type, id: header[1], channelName: header[2], name: header[3], arg: body });\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.disposeActiveRequest({ type, id: header[1] });\n\t\t}\n\t}\n\n\tprivate onPromise(request: IRawPromiseRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\t\tconst cancellationTokenSource = new CancellationTokenSource();\n\t\tlet promise: Promise<any>;\n\n\t\ttry {\n\t\t\tpromise = channel.call(this.ctx, request.name, request.arg, cancellationTokenSource.token);\n\t\t} catch (err) {\n\t\t\tpromise = Promise.reject(err);\n\t\t}\n\n\t\tconst id = request.id;\n\n\t\tpromise.then(data => {\n\t\t\tthis.sendResponse(<IRawResponse>{ id, data, type: ResponseType.PromiseSuccess });\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}, err => {\n\t\t\tif (err instanceof Error) {\n\t\t\t\tthis.sendResponse(<IRawResponse>{\n\t\t\t\t\tid, data: {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\tname: err.name,\n\t\t\t\t\t\tstack: err.stack ? (err.stack.split ? err.stack.split('\\n') : err.stack) : undefined\n\t\t\t\t\t}, type: ResponseType.PromiseError\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.sendResponse(<IRawResponse>{ id, data: err, type: ResponseType.PromiseErrorObj });\n\t\t\t}\n\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t});\n\n\t\tconst disposable = toDisposable(() => cancellationTokenSource.cancel());\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate onEventListen(request: IRawEventListenRequest): void {\n\t\tconst channel = this.channels.get(request.channelName);\n\t\tif (!channel) {\n\t\t\tthrow new Error('Unknown channel');\n\t\t}\n\n\t\tconst id = request.id;\n\t\tconst event = channel.listen(this.ctx, request.name, request.arg);\n\t\tconst disposable = event(data => this.sendResponse(<IRawResponse>{ id, data, type: ResponseType.EventFire }));\n\n\t\tthis.activeRequests.set(request.id, disposable);\n\t}\n\n\tprivate disposeActiveRequest(request: IRawRequest): void {\n\t\tconst disposable = this.activeRequests.get(request.id);\n\n\t\tif (disposable) {\n\t\t\tdisposable.dispose();\n\t\t\tthis.activeRequests.delete(request.id);\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(d => d.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport class ChannelClient implements IChannelClient, IDisposable {\n\n\tprivate state: State = State.Uninitialized;\n\tprivate activeRequests = new Set<IDisposable>();\n\tprivate handlers = new Map<number, IHandler>();\n\tprivate lastRequestId: number = 0;\n\tprivate protocolListener: IDisposable | null;\n\n\tprivate _onDidInitialize = new Emitter<void>();\n\treadonly onDidInitialize = this._onDidInitialize.event;\n\n\tconstructor(private protocol: IMessagePassingProtocol) {\n\t\tthis.protocolListener = this.protocol.onMessage(msg => this.onBuffer(msg));\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\treturn that.requestPromise(channelName, command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\treturn that.requestEvent(channelName, event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tprivate requestPromise(channelName: string, name: string, arg?: any, cancellationToken = CancellationToken.None): Promise<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.Promise;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\treturn Promise.reject(errors.canceled());\n\t\t}\n\n\t\tlet disposable: IDisposable;\n\n\t\tconst result = new Promise((c, e) => {\n\t\t\tif (cancellationToken.isCancellationRequested) {\n\t\t\t\treturn e(errors.canceled());\n\t\t\t}\n\n\t\t\tlet uninitializedPromise: CancelablePromise<void> | null = createCancelablePromise(_ => this.whenInitialized());\n\t\t\tuninitializedPromise.then(() => {\n\t\t\t\tuninitializedPromise = null;\n\n\t\t\t\tconst handler: IHandler = response => {\n\t\t\t\t\tswitch (response.type) {\n\t\t\t\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tc(response.data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseError:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\tconst error = new Error(response.data.message);\n\t\t\t\t\t\t\t(<any>error).stack = response.data.stack;\n\t\t\t\t\t\t\terror.name = response.data.name;\n\t\t\t\t\t\t\te(error);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\t\t\t\tthis.handlers.delete(id);\n\t\t\t\t\t\t\te(response.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.handlers.set(id, handler);\n\t\t\t\tthis.sendRequest(request);\n\t\t\t});\n\n\t\t\tconst cancel = () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.PromiseCancel });\n\t\t\t\t}\n\n\t\t\t\te(errors.canceled());\n\t\t\t};\n\n\t\t\tconst cancellationTokenListener = cancellationToken.onCancellationRequested(cancel);\n\t\t\tdisposable = combinedDisposable([toDisposable(cancel), cancellationTokenListener]);\n\t\t\tthis.activeRequests.add(disposable);\n\t\t});\n\n\t\treturn result.finally(() => this.activeRequests.delete(disposable));\n\t}\n\n\tprivate requestEvent(channelName: string, name: string, arg?: any): Event<any> {\n\t\tconst id = this.lastRequestId++;\n\t\tconst type = RequestType.EventListen;\n\t\tconst request: IRawRequest = { id, type, channelName, name, arg };\n\n\t\tlet uninitializedPromise: CancelablePromise<void> | null = null;\n\n\t\tconst emitter = new Emitter<any>({\n\t\t\tonFirstListenerAdd: () => {\n\t\t\t\tuninitializedPromise = createCancelablePromise(_ => this.whenInitialized());\n\t\t\t\tuninitializedPromise.then(() => {\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t\tthis.activeRequests.add(emitter);\n\t\t\t\t\tthis.sendRequest(request);\n\t\t\t\t});\n\t\t\t},\n\t\t\tonLastListenerRemove: () => {\n\t\t\t\tif (uninitializedPromise) {\n\t\t\t\t\tuninitializedPromise.cancel();\n\t\t\t\t\tuninitializedPromise = null;\n\t\t\t\t} else {\n\t\t\t\t\tthis.activeRequests.delete(emitter);\n\t\t\t\t\tthis.sendRequest({ id, type: RequestType.EventDispose });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tconst handler: IHandler = (res: IRawEventFireResponse) => emitter.fire(res.data);\n\t\tthis.handlers.set(id, handler);\n\n\t\treturn emitter.event;\n\t}\n\n\tprivate sendRequest(request: IRawRequest): void {\n\t\tswitch (request.type) {\n\t\t\tcase RequestType.Promise:\n\t\t\tcase RequestType.EventListen:\n\t\t\t\treturn this.send([request.type, request.id, request.channelName, request.name], request.arg);\n\n\t\t\tcase RequestType.PromiseCancel:\n\t\t\tcase RequestType.EventDispose:\n\t\t\t\treturn this.send([request.type, request.id]);\n\t\t}\n\t}\n\n\tprivate send(header: any, body: any = undefined): void {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, header);\n\t\tserialize(writer, body);\n\t\tthis.sendBuffer(writer.buffer);\n\t}\n\n\tprivate sendBuffer(message: VSBuffer): void {\n\t\ttry {\n\t\t\tthis.protocol.send(message);\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\t}\n\n\tprivate onBuffer(message: VSBuffer): void {\n\t\tconst reader = new BufferReader(message);\n\t\tconst header = deserialize(reader);\n\t\tconst body = deserialize(reader);\n\t\tconst type: ResponseType = header[0];\n\n\t\tswitch (type) {\n\t\t\tcase ResponseType.Initialize:\n\t\t\t\treturn this.onResponse({ type: header[0] });\n\n\t\t\tcase ResponseType.PromiseSuccess:\n\t\t\tcase ResponseType.PromiseError:\n\t\t\tcase ResponseType.EventFire:\n\t\t\tcase ResponseType.PromiseErrorObj:\n\t\t\t\treturn this.onResponse({ type: header[0], id: header[1], data: body });\n\t\t}\n\t}\n\n\tprivate onResponse(response: IRawResponse): void {\n\t\tif (response.type === ResponseType.Initialize) {\n\t\t\tthis.state = State.Idle;\n\t\t\tthis._onDidInitialize.fire();\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler = this.handlers.get(response.id);\n\n\t\tif (handler) {\n\t\t\thandler(response);\n\t\t}\n\t}\n\n\tprivate whenInitialized(): Promise<void> {\n\t\tif (this.state === State.Idle) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn Event.toPromise(this.onDidInitialize);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tif (this.protocolListener) {\n\t\t\tthis.protocolListener.dispose();\n\t\t\tthis.protocolListener = null;\n\t\t}\n\t\tthis.activeRequests.forEach(p => p.dispose());\n\t\tthis.activeRequests.clear();\n\t}\n}\n\nexport interface ClientConnectionEvent {\n\tprotocol: IMessagePassingProtocol;\n\tonDidClientDisconnect: Event<void>;\n}\n\ninterface Connection<TContext> extends Client<TContext> {\n\treadonly channelClient: ChannelClient;\n}\n\n/**\n * An `IPCServer` is both a channel server and a routing channel\n * client.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCServer<TContext = string> implements IChannelServer<TContext>, IRoutingChannelClient<TContext>, IConnectionHub<TContext>, IDisposable {\n\n\tprivate channels = new Map<string, IServerChannel<TContext>>();\n\tprivate _connections = new Set<Connection<TContext>>();\n\n\tprivate _onDidChangeConnections = new Emitter<Connection<TContext>>();\n\treadonly onDidChangeConnections: Event<Connection<TContext>> = this._onDidChangeConnections.event;\n\n\tget connections(): Connection<TContext>[] {\n\t\tconst result: Connection<TContext>[] = [];\n\t\tthis._connections.forEach(ctx => result.push(ctx));\n\t\treturn result;\n\t}\n\n\tconstructor(onDidClientConnect: Event<ClientConnectionEvent>) {\n\t\tonDidClientConnect(({ protocol, onDidClientDisconnect }) => {\n\t\t\tconst onFirstMessage = Event.once(protocol.onMessage);\n\n\t\t\tonFirstMessage(msg => {\n\t\t\t\tconst reader = new BufferReader(msg);\n\t\t\t\tconst ctx = deserialize(reader) as TContext;\n\n\t\t\t\tconst channelServer = new ChannelServer(protocol, ctx);\n\t\t\t\tconst channelClient = new ChannelClient(protocol);\n\n\t\t\t\tthis.channels.forEach((channel, name) => channelServer.registerChannel(name, channel));\n\n\t\t\t\tconst connection: Connection<TContext> = { channelClient, ctx };\n\t\t\t\tthis._connections.add(connection);\n\t\t\t\tthis._onDidChangeConnections.fire(connection);\n\n\t\t\t\tonDidClientDisconnect(() => {\n\t\t\t\t\tchannelServer.dispose();\n\t\t\t\t\tchannelClient.dispose();\n\t\t\t\t\tthis._connections.delete(connection);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string, router: IClientRouter<TContext>): T {\n\t\tconst that = this;\n\n\t\treturn {\n\t\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken) {\n\t\t\t\tconst channelPromise = router.routeCall(that, command, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.call(command, arg, cancellationToken);\n\t\t\t},\n\t\t\tlisten(event: string, arg: any) {\n\t\t\t\tconst channelPromise = router.routeEvent(that, event, arg)\n\t\t\t\t\t.then(connection => (connection as Connection<TContext>).channelClient.getChannel(channelName));\n\n\t\t\t\treturn getDelayedChannel(channelPromise)\n\t\t\t\t\t.listen(event, arg);\n\t\t\t}\n\t\t} as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channels.set(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channels.clear();\n\t\tthis._connections.clear();\n\t\tthis._onDidChangeConnections.dispose();\n\t}\n}\n\n/**\n * An `IPCClient` is both a channel client and a channel server.\n *\n * As the owner of a protocol, you should extend both this\n * and the `IPCClient` classes to get IPC implementations\n * for your protocol.\n */\nexport class IPCClient<TContext = string> implements IChannelClient, IChannelServer<TContext>, IDisposable {\n\n\tprivate channelClient: ChannelClient;\n\tprivate channelServer: ChannelServer<TContext>;\n\n\tconstructor(protocol: IMessagePassingProtocol, ctx: TContext) {\n\t\tconst writer = new BufferWriter();\n\t\tserialize(writer, ctx);\n\t\tprotocol.send(writer.buffer);\n\n\t\tthis.channelClient = new ChannelClient(protocol);\n\t\tthis.channelServer = new ChannelServer(protocol, ctx);\n\t}\n\n\tgetChannel<T extends IChannel>(channelName: string): T {\n\t\treturn this.channelClient.getChannel(channelName) as T;\n\t}\n\n\tregisterChannel(channelName: string, channel: IServerChannel<TContext>): void {\n\t\tthis.channelServer.registerChannel(channelName, channel);\n\t}\n\n\tdispose(): void {\n\t\tthis.channelClient.dispose();\n\t\tthis.channelServer.dispose();\n\t}\n}\n\nexport function getDelayedChannel<T extends IChannel>(promise: Promise<T>): T {\n\treturn {\n\t\tcall(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\treturn promise.then(c => c.call<T>(command, arg, cancellationToken));\n\t\t},\n\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tconst relay = new Relay<any>();\n\t\t\tpromise.then(c => relay.input = c.listen(event, arg));\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport function getNextTickChannel<T extends IChannel>(channel: T): T {\n\tlet didTick = false;\n\n\treturn {\n\t\tcall<T>(command: string, arg?: any, cancellationToken?: CancellationToken): Promise<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.call(command, arg, cancellationToken);\n\t\t\t}\n\n\t\t\treturn timeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => channel.call<T>(command, arg, cancellationToken));\n\t\t},\n\t\tlisten<T>(event: string, arg?: any): Event<T> {\n\t\t\tif (didTick) {\n\t\t\t\treturn channel.listen<T>(event, arg);\n\t\t\t}\n\n\t\t\tconst relay = new Relay<T>();\n\n\t\t\ttimeout(0)\n\t\t\t\t.then(() => didTick = true)\n\t\t\t\t.then(() => relay.input = channel.listen<T>(event, arg));\n\n\t\t\treturn relay.event;\n\t\t}\n\t} as T;\n}\n\nexport class StaticRouter<TContext = string> implements IClientRouter<TContext> {\n\n\tconstructor(private fn: (ctx: TContext) => boolean | Promise<boolean>) { }\n\n\trouteCall(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\trouteEvent(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\treturn this.route(hub);\n\t}\n\n\tprivate async route(hub: IConnectionHub<TContext>): Promise<Client<TContext>> {\n\t\tfor (const connection of hub.connections) {\n\t\t\tif (await Promise.resolve(this.fn(connection.ctx))) {\n\t\t\t\treturn Promise.resolve(connection);\n\t\t\t}\n\t\t}\n\n\t\tawait Event.toPromise(hub.onDidChangeConnections);\n\t\treturn await this.route(hub);\n\t}\n}\n"]}]}