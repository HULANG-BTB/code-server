{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/ipc/node/ipc.cp.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"child_process\", \"vs/base/common/lifecycle\", \"vs/base/common/async\", \"vs/base/common/objects\", \"vs/base/common/event\", \"vs/base/node/processes\", \"vs/base/parts/ipc/common/ipc\", \"vs/base/common/console\", \"vs/base/common/cancellation\", \"vs/base/common/errors\", \"vs/base/common/buffer\"], function (require, exports, child_process_1, lifecycle_1, async_1, objects_1, event_1, processes_1, ipc_1, console_1, cancellation_1, errors, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * This implementation doesn't perform well since it uses base64 encoding for buffers.\n     * We should move all implementations to use named ipc.net, so we stop depending on cp.fork.\n     */\n    class Server extends ipc_1.ChannelServer {\n        constructor(ctx) {\n            super({\n                send: r => {\n                    try {\n                        if (process.send) {\n                            process.send(r.buffer.toString('base64'));\n                        }\n                    }\n                    catch (e) { /* not much to do */ }\n                },\n                onMessage: event_1.Event.fromNodeEventEmitter(process, 'message', msg => buffer_1.VSBuffer.wrap(Buffer.from(msg, 'base64')))\n            }, ctx);\n            process.once('disconnect', () => this.dispose());\n        }\n    }\n    exports.Server = Server;\n    class Client {\n        constructor(modulePath, options) {\n            this.modulePath = modulePath;\n            this.options = options;\n            this.activeRequests = new Set();\n            this.channels = new Map();\n            this._onDidProcessExit = new event_1.Emitter();\n            this.onDidProcessExit = this._onDidProcessExit.event;\n            const timeout = options && options.timeout ? options.timeout : 60000;\n            this.disposeDelayer = new async_1.Delayer(timeout);\n            this.child = null;\n            this._client = null;\n        }\n        getChannel(channelName) {\n            const that = this;\n            return {\n                call(command, arg, cancellationToken) {\n                    return that.requestPromise(channelName, command, arg, cancellationToken);\n                },\n                listen(event, arg) {\n                    return that.requestEvent(channelName, event, arg);\n                }\n            };\n        }\n        requestPromise(channelName, name, arg, cancellationToken = cancellation_1.CancellationToken.None) {\n            if (!this.disposeDelayer) {\n                return Promise.reject(new Error('disposed'));\n            }\n            if (cancellationToken.isCancellationRequested) {\n                return Promise.reject(errors.canceled());\n            }\n            this.disposeDelayer.cancel();\n            const channel = this.getCachedChannel(channelName);\n            const result = async_1.createCancelablePromise(token => channel.call(name, arg, token));\n            const cancellationTokenListener = cancellationToken.onCancellationRequested(() => result.cancel());\n            const disposable = lifecycle_1.toDisposable(() => result.cancel());\n            this.activeRequests.add(disposable);\n            result.finally(() => {\n                cancellationTokenListener.dispose();\n                this.activeRequests.delete(disposable);\n                if (this.activeRequests.size === 0) {\n                    this.disposeDelayer.trigger(() => this.disposeClient());\n                }\n            });\n            return result;\n        }\n        requestEvent(channelName, name, arg) {\n            if (!this.disposeDelayer) {\n                return event_1.Event.None;\n            }\n            this.disposeDelayer.cancel();\n            let listener;\n            const emitter = new event_1.Emitter({\n                onFirstListenerAdd: () => {\n                    const channel = this.getCachedChannel(channelName);\n                    const event = channel.listen(name, arg);\n                    listener = event(emitter.fire, emitter);\n                    this.activeRequests.add(listener);\n                },\n                onLastListenerRemove: () => {\n                    this.activeRequests.delete(listener);\n                    listener.dispose();\n                    if (this.activeRequests.size === 0 && this.disposeDelayer) {\n                        this.disposeDelayer.trigger(() => this.disposeClient());\n                    }\n                }\n            });\n            return emitter.event;\n        }\n        get client() {\n            if (!this._client) {\n                const args = this.options && this.options.args ? this.options.args : [];\n                const forkOpts = Object.create(null);\n                forkOpts.env = objects_1.assign(objects_1.deepClone(process.env), { 'VSCODE_PARENT_PID': String(process.pid) });\n                if (this.options && this.options.env) {\n                    forkOpts.env = objects_1.assign(forkOpts.env, this.options.env);\n                }\n                if (this.options && this.options.freshExecArgv) {\n                    forkOpts.execArgv = [];\n                }\n                if (this.options && typeof this.options.debug === 'number') {\n                    forkOpts.execArgv = ['--nolazy', '--inspect=' + this.options.debug];\n                }\n                if (this.options && typeof this.options.debugBrk === 'number') {\n                    forkOpts.execArgv = ['--nolazy', '--inspect-brk=' + this.options.debugBrk];\n                }\n                this.child = child_process_1.fork(this.modulePath, args, forkOpts);\n                const onMessageEmitter = new event_1.Emitter();\n                const onRawMessage = event_1.Event.fromNodeEventEmitter(this.child, 'message', msg => msg);\n                onRawMessage(msg => {\n                    // Handle remote console logs specially\n                    if (console_1.isRemoteConsoleLog(msg)) {\n                        console_1.log(msg, `IPC Library: ${this.options.serverName}`);\n                        return;\n                    }\n                    // Anything else goes to the outside\n                    onMessageEmitter.fire(buffer_1.VSBuffer.wrap(Buffer.from(msg, 'base64')));\n                });\n                const sender = this.options.useQueue ? processes_1.createQueuedSender(this.child) : this.child;\n                const send = (r) => this.child && this.child.connected && sender.send(r.buffer.toString('base64'));\n                const onMessage = onMessageEmitter.event;\n                const protocol = { send, onMessage };\n                this._client = new ipc_1.ChannelClient(protocol);\n                const onExit = () => this.disposeClient();\n                process.once('exit', onExit);\n                this.child.on('error', err => console.warn('IPC \"' + this.options.serverName + '\" errored with ' + err));\n                this.child.on('exit', (code, signal) => {\n                    process.removeListener('exit', onExit);\n                    this.activeRequests.forEach(r => lifecycle_1.dispose(r));\n                    this.activeRequests.clear();\n                    if (code !== 0 && signal !== 'SIGTERM') {\n                        console.warn('IPC \"' + this.options.serverName + '\" crashed with exit code ' + code + ' and signal ' + signal);\n                    }\n                    if (this.disposeDelayer) {\n                        this.disposeDelayer.cancel();\n                    }\n                    this.disposeClient();\n                    this._onDidProcessExit.fire({ code, signal });\n                });\n            }\n            return this._client;\n        }\n        getCachedChannel(name) {\n            let channel = this.channels.get(name);\n            if (!channel) {\n                channel = this.client.getChannel(name);\n                this.channels.set(name, channel);\n            }\n            return channel;\n        }\n        disposeClient() {\n            if (this._client) {\n                if (this.child) {\n                    this.child.kill();\n                    this.child = null;\n                }\n                this._client = null;\n                this.channels.clear();\n            }\n        }\n        dispose() {\n            this._onDidProcessExit.dispose();\n            this.disposeDelayer.cancel();\n            this.disposeDelayer = null; // StrictNullOverride: nulling out ok in dispose\n            this.disposeClient();\n            this.activeRequests.clear();\n        }\n    }\n    exports.Client = Client;\n});\n",null]}