{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/task.contribution.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/tasks/electron-browser/task.contribution.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"semver\", \"vs/workbench/contrib/tasks/browser/taskQuickOpen\", \"vs/base/common/severity\", \"vs/base/common/objects\", \"vs/base/common/uri\", \"vs/base/common/actions\", \"vs/base/browser/dom\", \"vs/base/common/lifecycle\", \"vs/base/common/event\", \"vs/base/common/types\", \"vs/base/common/keyCodes\", \"vs/base/common/processes\", \"vs/base/common/strings\", \"vs/base/common/parsers\", \"vs/base/common/uuid\", \"vs/base/common/platform\", \"vs/base/common/map\", \"vs/base/browser/ui/octiconLabel/octiconLabel\", \"vs/platform/registry/common/platform\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/actions/common/actions\", \"vs/platform/instantiation/common/extensions\", \"vs/platform/markers/common/markers\", \"vs/platform/telemetry/common/telemetry\", \"vs/platform/configuration/common/configuration\", \"vs/platform/files/common/files\", \"vs/workbench/services/extensions/common/extensions\", \"vs/platform/commands/common/commands\", \"vs/platform/keybinding/common/keybindingsRegistry\", \"vs/workbench/contrib/tasks/common/problemMatcher\", \"vs/platform/storage/common/storage\", \"vs/platform/progress/common/progress\", \"vs/platform/opener/common/opener\", \"vs/platform/windows/common/windows\", \"vs/platform/notification/common/notification\", \"vs/platform/dialogs/common/dialogs\", \"vs/editor/common/services/modelService\", \"vs/platform/jsonschemas/common/jsonContributionRegistry\", \"vs/workbench/browser/parts/statusbar/statusbar\", \"vs/platform/statusbar/common/statusbar\", \"vs/workbench/browser/quickopen\", \"vs/workbench/services/panel/common/panelService\", \"vs/workbench/contrib/markers/browser/constants\", \"vs/workbench/services/layout/browser/layoutService\", \"vs/workbench/services/editor/common/editorService\", \"vs/workbench/services/configurationResolver/common/configurationResolver\", \"vs/platform/workspace/common/workspace\", \"vs/workbench/services/textfile/common/textfiles\", \"vs/workbench/contrib/output/common/output\", \"vs/workbench/browser/actions\", \"vs/workbench/contrib/terminal/common/terminal\", \"vs/workbench/contrib/tasks/common/taskSystem\", \"vs/workbench/contrib/tasks/common/tasks\", \"vs/workbench/contrib/tasks/common/taskService\", \"vs/workbench/contrib/tasks/common/taskTemplates\", \"../common/taskConfiguration\", \"vs/workbench/contrib/tasks/node/processTaskSystem\", \"./terminalTaskSystem\", \"vs/workbench/contrib/tasks/node/processRunnerDetector\", \"../browser/quickOpen\", \"vs/workbench/common/theme\", \"vs/platform/theme/common/themeService\", \"vs/platform/quickinput/common/quickInput\", \"vs/workbench/contrib/tasks/common/taskDefinitionRegistry\", \"vs/platform/contextkey/common/contextkey\", \"vs/workbench/common/contributions\", \"vs/workbench/common/actions\", \"vs/workbench/contrib/tasks/electron-browser/runAutomaticTasks\", \"../common/jsonSchema_v1\", \"../common/jsonSchema_v2\", \"vs/css!../common/media/task.contribution\"], function (require, exports, nls, semver, taskQuickOpen_1, severity_1, Objects, uri_1, actions_1, Dom, lifecycle_1, event_1, Types, keyCodes_1, processes_1, strings, parsers_1, UUID, Platform, map_1, octiconLabel_1, platform_1, lifecycle_2, actions_2, extensions_1, markers_1, telemetry_1, configuration_1, files_1, extensions_2, commands_1, keybindingsRegistry_1, problemMatcher_1, storage_1, progress_1, opener_1, windows_1, notification_1, dialogs_1, modelService_1, jsonContributionRegistry, statusbar_1, statusbar_2, quickopen_1, panelService_1, constants_1, layoutService_1, editorService_1, configurationResolver_1, workspace_1, textfiles_1, output_1, actions_3, terminal_1, taskSystem_1, tasks_1, taskService_1, taskTemplates_1, TaskConfig, processTaskSystem_1, terminalTaskSystem_1, processRunnerDetector_1, quickOpen_1, theme_1, themeService_1, quickInput_1, taskDefinitionRegistry_1, contextkey_1, contributions_1, actions_4, runAutomaticTasks_1, jsonSchema_v1_1, jsonSchema_v2_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let tasksCategory = nls.localize('tasksCategory', \"Tasks\");\n    const workbenchRegistry = platform_1.Registry.as(contributions_1.Extensions.Workbench);\n    workbenchRegistry.registerWorkbenchContribution(runAutomaticTasks_1.RunAutomaticTasks, lifecycle_2.LifecyclePhase.Eventually);\n    const actionRegistry = platform_1.Registry.as(actions_4.Extensions.WorkbenchActions);\n    actionRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(runAutomaticTasks_1.AllowAutomaticTaskRunning, runAutomaticTasks_1.AllowAutomaticTaskRunning.ID, runAutomaticTasks_1.AllowAutomaticTaskRunning.LABEL), 'Tasks: Allow Automatic Tasks in Folder', tasksCategory);\n    actionRegistry.registerWorkbenchAction(new actions_2.SyncActionDescriptor(runAutomaticTasks_1.DisallowAutomaticTaskRunning, runAutomaticTasks_1.DisallowAutomaticTaskRunning.ID, runAutomaticTasks_1.DisallowAutomaticTaskRunning.LABEL), 'Tasks: Disallow Automatic Tasks in Folder', tasksCategory);\n    var ConfigureTaskAction;\n    (function (ConfigureTaskAction) {\n        ConfigureTaskAction.ID = 'workbench.action.tasks.configureTaskRunner';\n        ConfigureTaskAction.TEXT = nls.localize('ConfigureTaskRunnerAction.label', \"Configure Task\");\n    })(ConfigureTaskAction || (ConfigureTaskAction = {}));\n    let BuildStatusBarItem = class BuildStatusBarItem extends theme_1.Themable {\n        constructor(panelService, markerService, taskService, layoutService, themeService, contextService) {\n            super(themeService);\n            this.panelService = panelService;\n            this.markerService = markerService;\n            this.taskService = taskService;\n            this.layoutService = layoutService;\n            this.contextService = contextService;\n            this.activeCount = 0;\n            this.icons = [];\n            this.registerListeners();\n        }\n        registerListeners() {\n            this._register(this.contextService.onDidChangeWorkbenchState(() => this.updateStyles()));\n        }\n        updateStyles() {\n            super.updateStyles();\n            this.icons.forEach(icon => {\n                icon.style.backgroundColor = this.getColor(this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY ? theme_1.STATUS_BAR_FOREGROUND : theme_1.STATUS_BAR_NO_FOLDER_FOREGROUND);\n            });\n        }\n        render(container) {\n            let callOnDispose = [];\n            const element = document.createElement('div');\n            const label = document.createElement('a');\n            const errorIcon = document.createElement('div');\n            const warningIcon = document.createElement('div');\n            const infoIcon = document.createElement('div');\n            const error = document.createElement('div');\n            const warning = document.createElement('div');\n            const info = document.createElement('div');\n            const building = document.createElement('div');\n            const errorTitle = (n) => nls.localize('totalErrors', \"{0} Errors\", n);\n            const warningTitle = (n) => nls.localize('totalWarnings', \"{0} Warnings\", n);\n            const infoTitle = (n) => nls.localize('totalInfos', \"{0} Infos\", n);\n            Dom.addClass(element, 'task-statusbar-item');\n            element.title = nls.localize('problems', \"Problems\");\n            Dom.addClass(label, 'task-statusbar-item-label');\n            element.appendChild(label);\n            Dom.addClass(errorIcon, 'task-statusbar-item-label-error');\n            Dom.addClass(errorIcon, 'mask-icon');\n            label.appendChild(errorIcon);\n            this.icons.push(errorIcon);\n            Dom.addClass(error, 'task-statusbar-item-label-counter');\n            error.innerHTML = '0';\n            error.title = errorIcon.title = errorTitle(0);\n            label.appendChild(error);\n            Dom.addClass(warningIcon, 'task-statusbar-item-label-warning');\n            Dom.addClass(warningIcon, 'mask-icon');\n            label.appendChild(warningIcon);\n            this.icons.push(warningIcon);\n            Dom.addClass(warning, 'task-statusbar-item-label-counter');\n            warning.innerHTML = '0';\n            warning.title = warningIcon.title = warningTitle(0);\n            label.appendChild(warning);\n            Dom.addClass(infoIcon, 'task-statusbar-item-label-info');\n            Dom.addClass(infoIcon, 'mask-icon');\n            label.appendChild(infoIcon);\n            this.icons.push(infoIcon);\n            Dom.hide(infoIcon);\n            Dom.addClass(info, 'task-statusbar-item-label-counter');\n            label.appendChild(info);\n            Dom.hide(info);\n            Dom.addClass(building, 'task-statusbar-item-building');\n            element.appendChild(building);\n            building.innerHTML = nls.localize('building', 'Building...');\n            Dom.hide(building);\n            callOnDispose.push(Dom.addDisposableListener(label, 'click', (e) => {\n                const panel = this.panelService.getActivePanel();\n                if (panel && panel.getId() === constants_1.default.MARKERS_PANEL_ID) {\n                    this.layoutService.setPanelHidden(true);\n                }\n                else {\n                    this.panelService.openPanel(constants_1.default.MARKERS_PANEL_ID, true);\n                }\n            }));\n            const manyProblems = nls.localize('manyProblems', \"10K+\");\n            const packNumber = (n) => n > 9999 ? manyProblems : n > 999 ? n.toString().charAt(0) + 'K' : n.toString();\n            let updateLabel = (stats) => {\n                error.innerHTML = packNumber(stats.errors);\n                error.title = errorIcon.title = errorTitle(stats.errors);\n                warning.innerHTML = packNumber(stats.warnings);\n                warning.title = warningIcon.title = warningTitle(stats.warnings);\n                if (stats.infos > 0) {\n                    info.innerHTML = packNumber(stats.infos);\n                    info.title = infoIcon.title = infoTitle(stats.infos);\n                    Dom.show(info);\n                    Dom.show(infoIcon);\n                }\n                else {\n                    Dom.hide(info);\n                    Dom.hide(infoIcon);\n                }\n            };\n            this.markerService.onMarkerChanged((changedResources) => {\n                updateLabel(this.markerService.getStatistics());\n            });\n            callOnDispose.push(this.taskService.onDidStateChange((event) => {\n                if (this.ignoreEvent(event)) {\n                    return;\n                }\n                switch (event.kind) {\n                    case tasks_1.TaskEventKind.Active:\n                        this.activeCount++;\n                        if (this.activeCount === 1) {\n                            Dom.show(building);\n                        }\n                        break;\n                    case tasks_1.TaskEventKind.Inactive:\n                        // Since the exiting of the sub process is communicated async we can't order inactive and terminate events.\n                        // So try to treat them accordingly.\n                        if (this.activeCount > 0) {\n                            this.activeCount--;\n                            if (this.activeCount === 0) {\n                                Dom.hide(building);\n                            }\n                        }\n                        break;\n                    case tasks_1.TaskEventKind.Terminated:\n                        if (this.activeCount !== 0) {\n                            Dom.hide(building);\n                            this.activeCount = 0;\n                        }\n                        break;\n                }\n            }));\n            container.appendChild(element);\n            this.updateStyles();\n            return lifecycle_1.toDisposable(() => {\n                callOnDispose = lifecycle_1.dispose(callOnDispose);\n            });\n        }\n        ignoreEvent(event) {\n            if (!this.taskService.inTerminal()) {\n                return false;\n            }\n            if (event.group !== tasks_1.TaskGroup.Build) {\n                return true;\n            }\n            if (!event.__task) {\n                return false;\n            }\n            return event.__task.configurationProperties.problemMatchers === undefined || event.__task.configurationProperties.problemMatchers.length === 0;\n        }\n    };\n    BuildStatusBarItem = __decorate([\n        __param(0, panelService_1.IPanelService),\n        __param(1, markers_1.IMarkerService),\n        __param(2, taskService_1.ITaskService),\n        __param(3, layoutService_1.IWorkbenchLayoutService),\n        __param(4, themeService_1.IThemeService),\n        __param(5, workspace_1.IWorkspaceContextService)\n    ], BuildStatusBarItem);\n    let TaskStatusBarItem = class TaskStatusBarItem extends theme_1.Themable {\n        constructor(taskService, themeService) {\n            super(themeService);\n            this.taskService = taskService;\n        }\n        updateStyles() {\n            super.updateStyles();\n        }\n        render(container) {\n            let callOnDispose = [];\n            const element = document.createElement('a');\n            Dom.addClass(element, 'task-statusbar-runningItem');\n            let labelElement = document.createElement('div');\n            Dom.addClass(labelElement, 'task-statusbar-runningItem-label');\n            element.appendChild(labelElement);\n            let label = new octiconLabel_1.OcticonLabel(labelElement);\n            label.title = nls.localize('runningTasks', \"Show Running Tasks\");\n            Dom.hide(element);\n            callOnDispose.push(Dom.addDisposableListener(labelElement, 'click', (e) => {\n                this.taskService.runShowTasks();\n            }));\n            let updateStatus = () => {\n                this.taskService.getActiveTasks().then(tasks => {\n                    if (tasks.length === 0) {\n                        Dom.hide(element);\n                    }\n                    else {\n                        label.text = `$(tools) ${tasks.length}`;\n                        Dom.show(element);\n                    }\n                });\n            };\n            callOnDispose.push(this.taskService.onDidStateChange((event) => {\n                if (event.kind === tasks_1.TaskEventKind.Changed) {\n                    updateStatus();\n                }\n            }));\n            container.appendChild(element);\n            this.updateStyles();\n            updateStatus();\n            return {\n                dispose: () => {\n                    callOnDispose = lifecycle_1.dispose(callOnDispose);\n                }\n            };\n        }\n    };\n    TaskStatusBarItem = __decorate([\n        __param(0, taskService_1.ITaskService),\n        __param(1, themeService_1.IThemeService)\n    ], TaskStatusBarItem);\n    class ProblemReporter {\n        constructor(_outputChannel) {\n            this._outputChannel = _outputChannel;\n            this._validationStatus = new parsers_1.ValidationStatus();\n        }\n        info(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Info;\n            this._outputChannel.append(message + '\\n');\n        }\n        warn(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Warning;\n            this._outputChannel.append(message + '\\n');\n        }\n        error(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Error;\n            this._outputChannel.append(message + '\\n');\n        }\n        fatal(message) {\n            this._validationStatus.state = parsers_1.ValidationState.Fatal;\n            this._outputChannel.append(message + '\\n');\n        }\n        get status() {\n            return this._validationStatus;\n        }\n    }\n    class TaskMap {\n        constructor() {\n            this._store = new Map();\n        }\n        forEach(callback) {\n            this._store.forEach(callback);\n        }\n        get(workspaceFolder) {\n            let result = Types.isString(workspaceFolder) ? this._store.get(workspaceFolder) : this._store.get(workspaceFolder.uri.toString());\n            if (!result) {\n                result = [];\n                Types.isString(workspaceFolder) ? this._store.set(workspaceFolder, result) : this._store.set(workspaceFolder.uri.toString(), result);\n            }\n            return result;\n        }\n        add(workspaceFolder, ...task) {\n            let values = Types.isString(workspaceFolder) ? this._store.get(workspaceFolder) : this._store.get(workspaceFolder.uri.toString());\n            if (!values) {\n                values = [];\n                Types.isString(workspaceFolder) ? this._store.set(workspaceFolder, values) : this._store.set(workspaceFolder.uri.toString(), values);\n            }\n            values.push(...task);\n        }\n        all() {\n            let result = [];\n            this._store.forEach((values) => result.push(...values));\n            return result;\n        }\n    }\n    let TaskService = class TaskService extends lifecycle_1.Disposable {\n        constructor(configurationService, markerService, outputService, editorService, fileService, contextService, telemetryService, textFileService, lifecycleService, modelService, extensionService, quickInputService, configurationResolverService, terminalService, storageService, progressService, openerService, _windowService, dialogService, notificationService, contextKeyService) {\n            super();\n            this.configurationService = configurationService;\n            this.markerService = markerService;\n            this.outputService = outputService;\n            this.editorService = editorService;\n            this.fileService = fileService;\n            this.contextService = contextService;\n            this.telemetryService = telemetryService;\n            this.textFileService = textFileService;\n            this.modelService = modelService;\n            this.extensionService = extensionService;\n            this.quickInputService = quickInputService;\n            this.configurationResolverService = configurationResolverService;\n            this.terminalService = terminalService;\n            this.storageService = storageService;\n            this.progressService = progressService;\n            this.openerService = openerService;\n            this._windowService = _windowService;\n            this.dialogService = dialogService;\n            this.notificationService = notificationService;\n            this._configHasErrors = false;\n            this._workspaceTasksPromise = undefined;\n            this._taskSystem = undefined;\n            this._taskSystemListener = undefined;\n            this._outputChannel = this.outputService.getChannel(TaskService.OutputChannelId);\n            this._providers = new Map();\n            this._taskSystemInfos = new Map();\n            this._register(this.contextService.onDidChangeWorkspaceFolders(() => {\n                if (!this._taskSystem && !this._workspaceTasksPromise) {\n                    return;\n                }\n                let folderSetup = this.computeWorkspaceFolderSetup();\n                if (this.executionEngine !== folderSetup[2]) {\n                    if (this._taskSystem && this._taskSystem.getActiveTasks().length > 0) {\n                        this.notificationService.prompt(severity_1.default.Info, nls.localize('TaskSystem.noHotSwap', 'Changing the task execution engine with an active task running requires to reload the Window'), [{\n                                label: nls.localize('reloadWindow', \"Reload Window\"),\n                                run: () => this._windowService.reloadWindow()\n                            }], { sticky: true });\n                        return;\n                    }\n                    else {\n                        this.disposeTaskSystemListeners();\n                        this._taskSystem = undefined;\n                    }\n                }\n                this.updateSetup(folderSetup);\n                this.updateWorkspaceTasks();\n            }));\n            this._register(this.configurationService.onDidChangeConfiguration(() => {\n                if (!this._taskSystem && !this._workspaceTasksPromise) {\n                    return;\n                }\n                if (!this._taskSystem || this._taskSystem instanceof terminalTaskSystem_1.TerminalTaskSystem) {\n                    this._outputChannel.clear();\n                }\n                this.updateWorkspaceTasks(tasks_1.TaskRunSource.ConfigurationChange);\n            }));\n            this._taskRunningState = tasks_1.TASK_RUNNING_STATE.bindTo(contextKeyService);\n            this._register(lifecycleService.onBeforeShutdown(event => event.veto(this.beforeShutdown())));\n            this._register(storageService.onWillSaveState(() => this.saveState()));\n            this._onDidStateChange = this._register(new event_1.Emitter());\n            this.registerCommands();\n        }\n        get onDidStateChange() {\n            return this._onDidStateChange.event;\n        }\n        get supportsMultipleTaskExecutions() {\n            return this.inTerminal();\n        }\n        registerCommands() {\n            commands_1.CommandsRegistry.registerCommand({\n                id: 'workbench.action.tasks.runTask',\n                handler: (accessor, arg) => {\n                    this.runTaskCommand(arg);\n                },\n                description: {\n                    description: 'Run Task',\n                    args: [{\n                            name: 'args',\n                            schema: {\n                                'type': 'string',\n                            }\n                        }]\n                }\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.reRunTask', (accessor, arg) => {\n                this.reRunTaskCommand(arg);\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.restartTask', (accessor, arg) => {\n                this.runRestartTaskCommand(arg);\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.terminate', (accessor, arg) => {\n                this.runTerminateCommand(arg);\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.showLog', () => {\n                if (!this.canRunCommand()) {\n                    return;\n                }\n                this.showOutput();\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.build', () => {\n                if (!this.canRunCommand()) {\n                    return;\n                }\n                this.runBuildCommand();\n            });\n            keybindingsRegistry_1.KeybindingsRegistry.registerKeybindingRule({\n                id: 'workbench.action.tasks.build',\n                weight: keybindingsRegistry_1.KeybindingWeight.WorkbenchContrib,\n                when: undefined,\n                primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_B\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.test', () => {\n                if (!this.canRunCommand()) {\n                    return;\n                }\n                this.runTestCommand();\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.configureTaskRunner', () => {\n                this.runConfigureTasks();\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.configureDefaultBuildTask', () => {\n                this.runConfigureDefaultBuildTask();\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.configureDefaultTestTask', () => {\n                this.runConfigureDefaultTestTask();\n            });\n            commands_1.CommandsRegistry.registerCommand('workbench.action.tasks.showTasks', () => {\n                this.runShowTasks();\n            });\n        }\n        get workspaceFolders() {\n            if (!this._workspaceFolders) {\n                this.updateSetup();\n            }\n            return this._workspaceFolders;\n        }\n        get ignoredWorkspaceFolders() {\n            if (!this._ignoredWorkspaceFolders) {\n                this.updateSetup();\n            }\n            return this._ignoredWorkspaceFolders;\n        }\n        get executionEngine() {\n            if (this._executionEngine === undefined) {\n                this.updateSetup();\n            }\n            return this._executionEngine;\n        }\n        get schemaVersion() {\n            if (this._schemaVersion === undefined) {\n                this.updateSetup();\n            }\n            return this._schemaVersion;\n        }\n        get showIgnoreMessage() {\n            if (this._showIgnoreMessage === undefined) {\n                this._showIgnoreMessage = !this.storageService.getBoolean(TaskService.IgnoreTask010DonotShowAgain_key, storage_1.StorageScope.WORKSPACE, false);\n            }\n            return this._showIgnoreMessage;\n        }\n        updateSetup(setup) {\n            if (!setup) {\n                setup = this.computeWorkspaceFolderSetup();\n            }\n            this._workspaceFolders = setup[0];\n            if (this._ignoredWorkspaceFolders) {\n                if (this._ignoredWorkspaceFolders.length !== setup[1].length) {\n                    this._showIgnoreMessage = undefined;\n                }\n                else {\n                    let set = new Set();\n                    this._ignoredWorkspaceFolders.forEach(folder => set.add(folder.uri.toString()));\n                    for (let folder of setup[1]) {\n                        if (!set.has(folder.uri.toString())) {\n                            this._showIgnoreMessage = undefined;\n                            break;\n                        }\n                    }\n                }\n            }\n            this._ignoredWorkspaceFolders = setup[1];\n            this._executionEngine = setup[2];\n            this._schemaVersion = setup[3];\n        }\n        showOutput(runSource = tasks_1.TaskRunSource.User) {\n            if (runSource === tasks_1.TaskRunSource.User) {\n                this.notificationService.prompt(severity_1.default.Warning, nls.localize('taskServiceOutputPrompt', 'There are task errors. See the output for details.'), [{\n                        label: nls.localize('showOutput', \"Show output\"),\n                        run: () => {\n                            this.outputService.showChannel(this._outputChannel.id, true);\n                        }\n                    }]);\n            }\n        }\n        disposeTaskSystemListeners() {\n            if (this._taskSystemListener) {\n                this._taskSystemListener.dispose();\n            }\n        }\n        registerTaskProvider(provider) {\n            if (!provider) {\n                return {\n                    dispose: () => { }\n                };\n            }\n            let handle = TaskService.nextHandle++;\n            this._providers.set(handle, provider);\n            return {\n                dispose: () => {\n                    this._providers.delete(handle);\n                }\n            };\n        }\n        registerTaskSystem(key, info) {\n            this._taskSystemInfos.set(key, info);\n        }\n        extensionCallbackTaskComplete(task, result) {\n            if (!this._taskSystem) {\n                return Promise.resolve();\n            }\n            return this._taskSystem.customExecutionComplete(task, result);\n        }\n        getTask(folder, identifier, compareId = false) {\n            const name = Types.isString(folder) ? folder : folder.name;\n            if (this.ignoredWorkspaceFolders.some(ignored => ignored.name === name)) {\n                return Promise.reject(new Error(nls.localize('TaskServer.folderIgnored', 'The folder {0} is ignored since it uses task version 0.1.0', name)));\n            }\n            const key = !Types.isString(identifier)\n                ? tasks_1.TaskDefinition.createTaskIdentifier(identifier, console)\n                : identifier;\n            if (key === undefined) {\n                return Promise.resolve(undefined);\n            }\n            return this.getGroupedTasks().then((map) => {\n                const values = map.get(folder);\n                if (!values) {\n                    return undefined;\n                }\n                for (const task of values) {\n                    if (task.matches(key, compareId)) {\n                        return task;\n                    }\n                }\n                return undefined;\n            });\n        }\n        tasks(filter) {\n            let range = filter && filter.version ? filter.version : undefined;\n            let engine = this.executionEngine;\n            if (range && ((semver.satisfies('0.1.0', range) && engine === tasks_1.ExecutionEngine.Terminal) || (semver.satisfies('2.0.0', range) && engine === tasks_1.ExecutionEngine.Process))) {\n                return Promise.resolve([]);\n            }\n            return this.getGroupedTasks().then((map) => {\n                if (!filter || !filter.type) {\n                    return map.all();\n                }\n                let result = [];\n                map.forEach((tasks) => {\n                    for (let task of tasks) {\n                        if (tasks_1.ContributedTask.is(task) && task.defines.type === filter.type) {\n                            result.push(task);\n                        }\n                        else if (tasks_1.CustomTask.is(task)) {\n                            if (task.type === filter.type) {\n                                result.push(task);\n                            }\n                            else {\n                                let customizes = task.customizes();\n                                if (customizes && customizes.type === filter.type) {\n                                    result.push(task);\n                                }\n                            }\n                        }\n                    }\n                });\n                return result;\n            });\n        }\n        createSorter() {\n            return new tasks_1.TaskSorter(this.contextService.getWorkspace() ? this.contextService.getWorkspace().folders : []);\n        }\n        isActive() {\n            if (!this._taskSystem) {\n                return Promise.resolve(false);\n            }\n            return this._taskSystem.isActive();\n        }\n        getActiveTasks() {\n            if (!this._taskSystem) {\n                return Promise.resolve([]);\n            }\n            return Promise.resolve(this._taskSystem.getActiveTasks());\n        }\n        getRecentlyUsedTasks() {\n            if (this._recentlyUsedTasks) {\n                return this._recentlyUsedTasks;\n            }\n            this._recentlyUsedTasks = new map_1.LinkedMap();\n            let storageValue = this.storageService.get(TaskService.RecentlyUsedTasks_Key, storage_1.StorageScope.WORKSPACE);\n            if (storageValue) {\n                try {\n                    let values = JSON.parse(storageValue);\n                    if (Array.isArray(values)) {\n                        for (let value of values) {\n                            this._recentlyUsedTasks.set(value, value);\n                        }\n                    }\n                }\n                catch (error) {\n                    // Ignore. We use the empty result\n                }\n            }\n            return this._recentlyUsedTasks;\n        }\n        saveState() {\n            if (!this._taskSystem || !this._recentlyUsedTasks) {\n                return;\n            }\n            let values = this._recentlyUsedTasks.values();\n            if (values.length > 30) {\n                values = values.slice(0, 30);\n            }\n            this.storageService.store(TaskService.RecentlyUsedTasks_Key, JSON.stringify(values), storage_1.StorageScope.WORKSPACE);\n        }\n        openDocumentation() {\n            this.openerService.open(uri_1.URI.parse('https://go.microsoft.com/fwlink/?LinkId=733558'));\n        }\n        build() {\n            return this.getGroupedTasks().then((tasks) => {\n                let runnable = this.createRunnableTask(tasks, tasks_1.TaskGroup.Build);\n                if (!runnable || !runnable.task) {\n                    if (this.schemaVersion === tasks_1.JsonSchemaVersion.V0_1_0) {\n                        throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskService.noBuildTask1', 'No build task defined. Mark a task with \\'isBuildCommand\\' in the tasks.json file.'), taskSystem_1.TaskErrors.NoBuildTask);\n                    }\n                    else {\n                        throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskService.noBuildTask2', 'No build task defined. Mark a task with as a \\'build\\' group in the tasks.json file.'), taskSystem_1.TaskErrors.NoBuildTask);\n                    }\n                }\n                return this.executeTask(runnable.task, runnable.resolver);\n            }).then(value => value, (error) => {\n                this.handleError(error);\n                return Promise.reject(error);\n            });\n        }\n        runTest() {\n            return this.getGroupedTasks().then((tasks) => {\n                let runnable = this.createRunnableTask(tasks, tasks_1.TaskGroup.Test);\n                if (!runnable || !runnable.task) {\n                    if (this.schemaVersion === tasks_1.JsonSchemaVersion.V0_1_0) {\n                        throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskService.noTestTask1', 'No test task defined. Mark a task with \\'isTestCommand\\' in the tasks.json file.'), taskSystem_1.TaskErrors.NoTestTask);\n                    }\n                    else {\n                        throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskService.noTestTask2', 'No test task defined. Mark a task with as a \\'test\\' group in the tasks.json file.'), taskSystem_1.TaskErrors.NoTestTask);\n                    }\n                }\n                return this.executeTask(runnable.task, runnable.resolver);\n            }).then(value => value, (error) => {\n                this.handleError(error);\n                return Promise.reject(error);\n            });\n        }\n        run(task, options, runSource = tasks_1.TaskRunSource.System) {\n            if (!task) {\n                throw new taskSystem_1.TaskError(severity_1.default.Info, nls.localize('TaskServer.noTask', 'Task to execute is undefined'), taskSystem_1.TaskErrors.TaskNotFound);\n            }\n            return this.getGroupedTasks().then((grouped) => {\n                let resolver = this.createResolver(grouped);\n                if (options && options.attachProblemMatcher && this.shouldAttachProblemMatcher(task) && !tasks_1.InMemoryTask.is(task)) {\n                    return this.attachProblemMatcher(task).then((toExecute) => {\n                        if (toExecute) {\n                            return this.executeTask(toExecute, resolver);\n                        }\n                        else {\n                            return Promise.resolve(undefined);\n                        }\n                    });\n                }\n                return this.executeTask(task, resolver);\n            }).then((value) => {\n                if (runSource === tasks_1.TaskRunSource.User) {\n                    this.getWorkspaceTasks().then(workspaceTasks => {\n                        runAutomaticTasks_1.RunAutomaticTasks.promptForPermission(this, this.storageService, this.notificationService, workspaceTasks);\n                    });\n                }\n                return value;\n            }, (error) => {\n                this.handleError(error);\n                return Promise.reject(error);\n            });\n        }\n        shouldAttachProblemMatcher(task) {\n            if (!this.canCustomize(task)) {\n                return false;\n            }\n            if (task.configurationProperties.group !== undefined && task.configurationProperties.group !== tasks_1.TaskGroup.Build) {\n                return false;\n            }\n            if (task.configurationProperties.problemMatchers !== undefined && task.configurationProperties.problemMatchers.length > 0) {\n                return false;\n            }\n            if (tasks_1.ContributedTask.is(task)) {\n                return !task.hasDefinedMatchers && !!task.configurationProperties.problemMatchers && (task.configurationProperties.problemMatchers.length === 0);\n            }\n            if (tasks_1.CustomTask.is(task)) {\n                let configProperties = task._source.config.element;\n                return configProperties.problemMatcher === undefined && !task.hasDefinedMatchers;\n            }\n            return false;\n        }\n        attachProblemMatcher(task) {\n            let entries = [];\n            for (let key of problemMatcher_1.ProblemMatcherRegistry.keys()) {\n                let matcher = problemMatcher_1.ProblemMatcherRegistry.get(key);\n                if (matcher.deprecated) {\n                    continue;\n                }\n                if (matcher.name === matcher.label) {\n                    entries.push({ label: matcher.name, matcher: matcher });\n                }\n                else {\n                    entries.push({\n                        label: matcher.label,\n                        description: `$${matcher.name}`,\n                        matcher: matcher\n                    });\n                }\n            }\n            if (entries.length > 0) {\n                entries = entries.sort((a, b) => {\n                    if (a.label && b.label) {\n                        return a.label.localeCompare(b.label);\n                    }\n                    else {\n                        return 0;\n                    }\n                });\n                entries.unshift({ type: 'separator', label: nls.localize('TaskService.associate', 'associate') });\n                entries.unshift({ label: nls.localize('TaskService.attachProblemMatcher.continueWithout', 'Continue without scanning the task output'), matcher: undefined }, { label: nls.localize('TaskService.attachProblemMatcher.never', 'Never scan the task output'), matcher: undefined, never: true }, { label: nls.localize('TaskService.attachProblemMatcher.learnMoreAbout', 'Learn more about scanning the task output'), matcher: undefined, learnMore: true });\n                return this.quickInputService.pick(entries, {\n                    placeHolder: nls.localize('selectProblemMatcher', 'Select for which kind of errors and warnings to scan the task output'),\n                }).then((selected) => {\n                    if (selected) {\n                        if (selected.learnMore) {\n                            this.openDocumentation();\n                            return undefined;\n                        }\n                        else if (selected.never) {\n                            this.customize(task, { problemMatcher: [] }, true);\n                            return task;\n                        }\n                        else if (selected.matcher) {\n                            let newTask = task.clone();\n                            let matcherReference = `$${selected.matcher.name}`;\n                            let properties = { problemMatcher: [matcherReference] };\n                            newTask.configurationProperties.problemMatchers = [matcherReference];\n                            let matcher = problemMatcher_1.ProblemMatcherRegistry.get(selected.matcher.name);\n                            if (matcher && matcher.watching !== undefined) {\n                                properties.isBackground = true;\n                                newTask.configurationProperties.isBackground = true;\n                            }\n                            this.customize(task, properties, true);\n                            return newTask;\n                        }\n                        else {\n                            return task;\n                        }\n                    }\n                    else {\n                        return undefined;\n                    }\n                });\n            }\n            return Promise.resolve(task);\n        }\n        getTasksForGroup(group) {\n            return this.getGroupedTasks().then((groups) => {\n                let result = [];\n                groups.forEach((tasks) => {\n                    for (let task of tasks) {\n                        if (task.configurationProperties.group === group) {\n                            result.push(task);\n                        }\n                    }\n                });\n                return result;\n            });\n        }\n        needsFolderQualification() {\n            return this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE;\n        }\n        canCustomize(task) {\n            if (this.schemaVersion !== tasks_1.JsonSchemaVersion.V2_0_0) {\n                return false;\n            }\n            if (tasks_1.CustomTask.is(task)) {\n                return true;\n            }\n            if (tasks_1.ContributedTask.is(task)) {\n                return !!task.getWorkspaceFolder();\n            }\n            return false;\n        }\n        customize(task, properties, openConfig) {\n            const workspaceFolder = task.getWorkspaceFolder();\n            if (!workspaceFolder) {\n                return Promise.resolve(undefined);\n            }\n            let configuration = this.getConfiguration(workspaceFolder);\n            if (configuration.hasParseErrors) {\n                this.notificationService.warn(nls.localize('customizeParseErrors', 'The current task configuration has errors. Please fix the errors first before customizing a task.'));\n                return Promise.resolve(undefined);\n            }\n            let fileConfig = configuration.config;\n            let index;\n            let toCustomize;\n            let taskConfig = tasks_1.CustomTask.is(task) ? task._source.config : undefined;\n            if (taskConfig && taskConfig.element) {\n                index = taskConfig.index;\n                toCustomize = taskConfig.element;\n            }\n            else if (tasks_1.ContributedTask.is(task)) {\n                toCustomize = {};\n                let identifier = Objects.assign(Object.create(null), task.defines);\n                delete identifier['_key'];\n                Object.keys(identifier).forEach(key => toCustomize[key] = identifier[key]);\n                if (task.configurationProperties.problemMatchers && task.configurationProperties.problemMatchers.length > 0 && Types.isStringArray(task.configurationProperties.problemMatchers)) {\n                    toCustomize.problemMatcher = task.configurationProperties.problemMatchers;\n                }\n            }\n            if (!toCustomize) {\n                return Promise.resolve(undefined);\n            }\n            if (properties) {\n                for (let property of Object.getOwnPropertyNames(properties)) {\n                    let value = properties[property];\n                    if (value !== undefined && value !== null) {\n                        toCustomize[property] = value;\n                    }\n                }\n            }\n            else {\n                if (toCustomize.problemMatcher === undefined && task.configurationProperties.problemMatchers === undefined || (task.configurationProperties.problemMatchers && task.configurationProperties.problemMatchers.length === 0)) {\n                    toCustomize.problemMatcher = [];\n                }\n            }\n            let promise;\n            if (!fileConfig) {\n                let value = {\n                    version: '2.0.0',\n                    tasks: [toCustomize]\n                };\n                let content = [\n                    '{',\n                    nls.localize('tasksJsonComment', '\\t// See https://go.microsoft.com/fwlink/?LinkId=733558 \\n\\t// for the documentation about the tasks.json format'),\n                ].join('\\n') + JSON.stringify(value, null, '\\t').substr(1);\n                let editorConfig = this.configurationService.getValue();\n                if (editorConfig.editor.insertSpaces) {\n                    content = content.replace(/(\\n)(\\t+)/g, (_, s1, s2) => s1 + strings.repeat(' ', s2.length * editorConfig.editor.tabSize));\n                }\n                promise = this.fileService.createFile(workspaceFolder.toResource('.vscode/tasks.json'), content).then(() => { });\n            }\n            else {\n                // We have a global task configuration\n                if ((index === -1) && properties) {\n                    if (properties.problemMatcher !== undefined) {\n                        fileConfig.problemMatcher = properties.problemMatcher;\n                        promise = this.writeConfiguration(workspaceFolder, 'tasks.problemMatchers', fileConfig.problemMatcher);\n                    }\n                    else if (properties.group !== undefined) {\n                        fileConfig.group = properties.group;\n                        promise = this.writeConfiguration(workspaceFolder, 'tasks.group', fileConfig.group);\n                    }\n                }\n                else {\n                    if (!Array.isArray(fileConfig.tasks)) {\n                        fileConfig.tasks = [];\n                    }\n                    if (index === undefined) {\n                        fileConfig.tasks.push(toCustomize);\n                    }\n                    else {\n                        fileConfig.tasks[index] = toCustomize;\n                    }\n                    promise = this.writeConfiguration(workspaceFolder, 'tasks.tasks', fileConfig.tasks);\n                }\n            }\n            if (!promise) {\n                return Promise.resolve(undefined);\n            }\n            return promise.then(() => {\n                let event = {\n                    properties: properties ? Object.getOwnPropertyNames(properties) : []\n                };\n                /* __GDPR__\n                    \"taskService.customize\" : {\n                        \"properties\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n                    }\n                */\n                this.telemetryService.publicLog(TaskService.CustomizationTelemetryEventName, event);\n                if (openConfig) {\n                    let resource = workspaceFolder.toResource('.vscode/tasks.json');\n                    this.editorService.openEditor({\n                        resource,\n                        options: {\n                            pinned: false,\n                            forceReload: true // because content might have changed\n                        }\n                    });\n                }\n            });\n        }\n        writeConfiguration(workspaceFolder, key, value) {\n            if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n                return this.configurationService.updateValue(key, value, { resource: workspaceFolder.uri }, configuration_1.ConfigurationTarget.WORKSPACE);\n            }\n            else if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE) {\n                return this.configurationService.updateValue(key, value, { resource: workspaceFolder.uri }, configuration_1.ConfigurationTarget.WORKSPACE_FOLDER);\n            }\n            else {\n                return undefined;\n            }\n        }\n        openConfig(task) {\n            let resource;\n            if (task) {\n                resource = task.getWorkspaceFolder().toResource(task._source.config.file);\n            }\n            else {\n                resource = (this._workspaceFolders && (this._workspaceFolders.length > 0)) ? this._workspaceFolders[0].toResource('.vscode/tasks.json') : undefined;\n            }\n            return this.editorService.openEditor({\n                resource,\n                options: {\n                    pinned: false\n                }\n            }).then(() => undefined);\n        }\n        createRunnableTask(tasks, group) {\n            let resolverData = new Map();\n            let workspaceTasks = [];\n            let extensionTasks = [];\n            tasks.forEach((tasks, folder) => {\n                let data = resolverData.get(folder);\n                if (!data) {\n                    data = {\n                        id: new Map(),\n                        label: new Map(),\n                        identifier: new Map()\n                    };\n                    resolverData.set(folder, data);\n                }\n                for (let task of tasks) {\n                    data.id.set(task._id, task);\n                    data.label.set(task._label, task);\n                    if (task.configurationProperties.identifier) {\n                        data.identifier.set(task.configurationProperties.identifier, task);\n                    }\n                    if (group && task.configurationProperties.group === group) {\n                        if (task._source.kind === tasks_1.TaskSourceKind.Workspace) {\n                            workspaceTasks.push(task);\n                        }\n                        else {\n                            extensionTasks.push(task);\n                        }\n                    }\n                }\n            });\n            let resolver = {\n                resolve: (workspaceFolder, alias) => {\n                    let data = resolverData.get(workspaceFolder.uri.toString());\n                    if (!data) {\n                        return undefined;\n                    }\n                    return data.id.get(alias) || data.label.get(alias) || data.identifier.get(alias);\n                }\n            };\n            if (workspaceTasks.length > 0) {\n                if (workspaceTasks.length > 1) {\n                    this._outputChannel.append(nls.localize('moreThanOneBuildTask', 'There are many build tasks defined in the tasks.json. Executing the first one.\\n'));\n                }\n                return { task: workspaceTasks[0], resolver };\n            }\n            if (extensionTasks.length === 0) {\n                return undefined;\n            }\n            // We can only have extension tasks if we are in version 2.0.0. Then we can even run\n            // multiple build tasks.\n            if (extensionTasks.length === 1) {\n                return { task: extensionTasks[0], resolver };\n            }\n            else {\n                let id = UUID.generateUuid();\n                let task = new tasks_1.InMemoryTask(id, { kind: tasks_1.TaskSourceKind.InMemory, label: 'inMemory' }, id, 'inMemory', { reevaluateOnRerun: true }, {\n                    identifier: id,\n                    dependsOn: extensionTasks.map((extensionTask) => { return { workspaceFolder: extensionTask.getWorkspaceFolder(), task: extensionTask._id }; }),\n                    name: id,\n                });\n                return { task, resolver };\n            }\n        }\n        createResolver(grouped) {\n            let resolverData = new Map();\n            grouped.forEach((tasks, folder) => {\n                let data = resolverData.get(folder);\n                if (!data) {\n                    data = { label: new Map(), identifier: new Map(), taskIdentifier: new Map() };\n                    resolverData.set(folder, data);\n                }\n                for (let task of tasks) {\n                    data.label.set(task._label, task);\n                    if (task.configurationProperties.identifier) {\n                        data.identifier.set(task.configurationProperties.identifier, task);\n                    }\n                    let keyedIdentifier = task.getDefinition(true);\n                    if (keyedIdentifier !== undefined) {\n                        data.taskIdentifier.set(keyedIdentifier._key, task);\n                    }\n                }\n            });\n            return {\n                resolve: (workspaceFolder, identifier) => {\n                    let data = resolverData.get(workspaceFolder.uri.toString());\n                    if (!data || !identifier) {\n                        return undefined;\n                    }\n                    if (Types.isString(identifier)) {\n                        return data.label.get(identifier) || data.identifier.get(identifier);\n                    }\n                    else {\n                        let key = tasks_1.TaskDefinition.createTaskIdentifier(identifier, console);\n                        return key !== undefined ? data.taskIdentifier.get(key._key) : undefined;\n                    }\n                }\n            };\n        }\n        executeTask(task, resolver) {\n            return problemMatcher_1.ProblemMatcherRegistry.onReady().then(() => {\n                return this.textFileService.saveAll().then((value) => {\n                    let executeResult = this.getTaskSystem().run(task, resolver);\n                    return this.handleExecuteResult(executeResult);\n                });\n            });\n        }\n        handleExecuteResult(executeResult) {\n            if (executeResult.task.taskLoadMessages && executeResult.task.taskLoadMessages.length > 0) {\n                executeResult.task.taskLoadMessages.forEach(loadMessage => {\n                    this._outputChannel.append(loadMessage + '\\n');\n                });\n                this.showOutput();\n            }\n            let key = executeResult.task.getRecentlyUsedKey();\n            if (key) {\n                this.getRecentlyUsedTasks().set(key, key, map_1.Touch.AsOld);\n            }\n            if (executeResult.kind === taskSystem_1.TaskExecuteKind.Active) {\n                let active = executeResult.active;\n                if (active && active.same) {\n                    let message;\n                    if (active.background) {\n                        message = nls.localize('TaskSystem.activeSame.background', 'The task \\'{0}\\' is already active and in background mode.', executeResult.task.getQualifiedLabel());\n                    }\n                    else {\n                        message = nls.localize('TaskSystem.activeSame.noBackground', 'The task \\'{0}\\' is already active.', executeResult.task.getQualifiedLabel());\n                    }\n                    this.notificationService.prompt(severity_1.default.Info, message, [{\n                            label: nls.localize('terminateTask', \"Terminate Task\"),\n                            run: () => this.terminate(executeResult.task)\n                        },\n                        {\n                            label: nls.localize('restartTask', \"Restart Task\"),\n                            run: () => this.restart(executeResult.task)\n                        }], { sticky: true });\n                }\n                else {\n                    throw new taskSystem_1.TaskError(severity_1.default.Warning, nls.localize('TaskSystem.active', 'There is already a task running. Terminate it first before executing another task.'), taskSystem_1.TaskErrors.RunningTask);\n                }\n            }\n            return executeResult.promise;\n        }\n        restart(task) {\n            if (!this._taskSystem) {\n                return;\n            }\n            this._taskSystem.terminate(task).then((response) => {\n                if (response.success) {\n                    this.run(task).then(undefined, reason => {\n                        // eat the error, it has already been surfaced to the user and we don't care about it here\n                    });\n                }\n                else {\n                    this.notificationService.warn(nls.localize('TaskSystem.restartFailed', 'Failed to terminate and restart task {0}', Types.isString(task) ? task : task.configurationProperties.name));\n                }\n                return response;\n            });\n        }\n        terminate(task) {\n            if (!this._taskSystem) {\n                return Promise.resolve({ success: true, task: undefined });\n            }\n            return this._taskSystem.terminate(task);\n        }\n        terminateAll() {\n            if (!this._taskSystem) {\n                return Promise.resolve([]);\n            }\n            return this._taskSystem.terminateAll();\n        }\n        getTaskSystem() {\n            if (this._taskSystem) {\n                return this._taskSystem;\n            }\n            if (this.executionEngine === tasks_1.ExecutionEngine.Terminal) {\n                this._taskSystem = new terminalTaskSystem_1.TerminalTaskSystem(this.terminalService, this.outputService, this.markerService, this.modelService, this.configurationResolverService, this.telemetryService, this.contextService, this._windowService, TaskService.OutputChannelId, (workspaceFolder) => {\n                    if (!workspaceFolder) {\n                        return undefined;\n                    }\n                    return this._taskSystemInfos.get(workspaceFolder.uri.scheme);\n                });\n            }\n            else {\n                let system = new processTaskSystem_1.ProcessTaskSystem(this.markerService, this.modelService, this.telemetryService, this.outputService, this.configurationResolverService, TaskService.OutputChannelId);\n                system.hasErrors(this._configHasErrors);\n                this._taskSystem = system;\n            }\n            this._taskSystemListener = this._taskSystem.onDidStateChange((event) => {\n                if (this._taskSystem) {\n                    this._taskRunningState.set(this._taskSystem.isActiveSync());\n                }\n                this._onDidStateChange.fire(event);\n            });\n            return this._taskSystem;\n        }\n        getGroupedTasks() {\n            return Promise.all([this.extensionService.activateByEvent('onCommand:workbench.action.tasks.runTask'), taskDefinitionRegistry_1.TaskDefinitionRegistry.onReady()]).then(() => {\n                let validTypes = Object.create(null);\n                taskDefinitionRegistry_1.TaskDefinitionRegistry.all().forEach(definition => validTypes[definition.taskType] = true);\n                validTypes['shell'] = true;\n                validTypes['process'] = true;\n                return new Promise(resolve => {\n                    let result = [];\n                    let counter = 0;\n                    let done = (value) => {\n                        if (value) {\n                            result.push(value);\n                        }\n                        if (--counter === 0) {\n                            resolve(result);\n                        }\n                    };\n                    let error = (error) => {\n                        try {\n                            if (error && Types.isString(error.message)) {\n                                this._outputChannel.append('Error: ');\n                                this._outputChannel.append(error.message);\n                                this._outputChannel.append('\\n');\n                                this.showOutput();\n                            }\n                            else {\n                                this._outputChannel.append('Unknown error received while collecting tasks from providers.\\n');\n                                this.showOutput();\n                            }\n                        }\n                        finally {\n                            if (--counter === 0) {\n                                resolve(result);\n                            }\n                        }\n                    };\n                    if (this.schemaVersion === tasks_1.JsonSchemaVersion.V2_0_0 && this._providers.size > 0) {\n                        this._providers.forEach((provider) => {\n                            counter++;\n                            provider.provideTasks(validTypes).then(done, error);\n                        });\n                    }\n                    else {\n                        resolve(result);\n                    }\n                });\n            }).then((contributedTaskSets) => {\n                let result = new TaskMap();\n                let contributedTasks = new TaskMap();\n                for (let set of contributedTaskSets) {\n                    for (let task of set.tasks) {\n                        let workspaceFolder = task.getWorkspaceFolder();\n                        if (workspaceFolder) {\n                            contributedTasks.add(workspaceFolder, task);\n                        }\n                    }\n                }\n                return this.getWorkspaceTasks().then((customTasks) => {\n                    customTasks.forEach((folderTasks, key) => {\n                        let contributed = contributedTasks.get(key);\n                        if (!folderTasks.set) {\n                            if (contributed) {\n                                result.add(key, ...contributed);\n                            }\n                            return;\n                        }\n                        if (!contributed) {\n                            result.add(key, ...folderTasks.set.tasks);\n                        }\n                        else {\n                            let configurations = folderTasks.configurations;\n                            let legacyTaskConfigurations = folderTasks.set ? this.getLegacyTaskConfigurations(folderTasks.set) : undefined;\n                            let customTasksToDelete = [];\n                            if (configurations || legacyTaskConfigurations) {\n                                let unUsedConfigurations = new Set();\n                                if (configurations) {\n                                    Object.keys(configurations.byIdentifier).forEach(key => unUsedConfigurations.add(key));\n                                }\n                                for (let task of contributed) {\n                                    if (!tasks_1.ContributedTask.is(task)) {\n                                        continue;\n                                    }\n                                    if (configurations) {\n                                        let configuringTask = configurations.byIdentifier[task.defines._key];\n                                        if (configuringTask) {\n                                            unUsedConfigurations.delete(task.defines._key);\n                                            result.add(key, TaskConfig.createCustomTask(task, configuringTask));\n                                        }\n                                        else {\n                                            result.add(key, task);\n                                        }\n                                    }\n                                    else if (legacyTaskConfigurations) {\n                                        let configuringTask = legacyTaskConfigurations[task.defines._key];\n                                        if (configuringTask) {\n                                            result.add(key, TaskConfig.createCustomTask(task, configuringTask));\n                                            customTasksToDelete.push(configuringTask);\n                                        }\n                                        else {\n                                            result.add(key, task);\n                                        }\n                                    }\n                                    else {\n                                        result.add(key, task);\n                                    }\n                                }\n                                if (customTasksToDelete.length > 0) {\n                                    let toDelete = customTasksToDelete.reduce((map, task) => {\n                                        map[task._id] = true;\n                                        return map;\n                                    }, Object.create(null));\n                                    for (let task of folderTasks.set.tasks) {\n                                        if (toDelete[task._id]) {\n                                            continue;\n                                        }\n                                        result.add(key, task);\n                                    }\n                                }\n                                else {\n                                    result.add(key, ...folderTasks.set.tasks);\n                                }\n                                unUsedConfigurations.forEach((value) => {\n                                    let configuringTask = configurations.byIdentifier[value];\n                                    this._outputChannel.append(nls.localize('TaskService.noConfiguration', 'Error: The {0} task detection didn\\'t contribute a task for the following configuration:\\n{1}\\nThe task will be ignored.\\n', configuringTask.configures.type, JSON.stringify(configuringTask._source.config.element, undefined, 4)));\n                                    this.showOutput();\n                                });\n                            }\n                            else {\n                                result.add(key, ...folderTasks.set.tasks);\n                                result.add(key, ...contributed);\n                            }\n                        }\n                    });\n                    return result;\n                }, () => {\n                    // If we can't read the tasks.json file provide at least the contributed tasks\n                    let result = new TaskMap();\n                    for (let set of contributedTaskSets) {\n                        for (let task of set.tasks) {\n                            const folder = task.getWorkspaceFolder();\n                            if (folder) {\n                                result.add(folder, task);\n                            }\n                        }\n                    }\n                    return result;\n                });\n            });\n        }\n        getLegacyTaskConfigurations(workspaceTasks) {\n            let result;\n            function getResult() {\n                if (result) {\n                    return result;\n                }\n                result = Object.create(null);\n                return result;\n            }\n            for (let task of workspaceTasks.tasks) {\n                if (tasks_1.CustomTask.is(task)) {\n                    let commandName = task.command && task.command.name;\n                    // This is for backwards compatibility with the 0.1.0 task annotation code\n                    // if we had a gulp, jake or grunt command a task specification was a annotation\n                    if (commandName === 'gulp' || commandName === 'grunt' || commandName === 'jake') {\n                        let identifier = tasks_1.KeyedTaskIdentifier.create({\n                            type: commandName,\n                            task: task.configurationProperties.name\n                        });\n                        getResult()[identifier._key] = task;\n                    }\n                }\n            }\n            return result;\n        }\n        getWorkspaceTasks(runSource = tasks_1.TaskRunSource.User) {\n            if (this._workspaceTasksPromise) {\n                return this._workspaceTasksPromise;\n            }\n            this.updateWorkspaceTasks(runSource);\n            return this._workspaceTasksPromise;\n        }\n        updateWorkspaceTasks(runSource = tasks_1.TaskRunSource.User) {\n            this._workspaceTasksPromise = this.computeWorkspaceTasks(runSource).then(value => {\n                if (this.executionEngine === tasks_1.ExecutionEngine.Process && this._taskSystem instanceof processTaskSystem_1.ProcessTaskSystem) {\n                    // We can only have a process engine if we have one folder.\n                    value.forEach((value) => {\n                        this._configHasErrors = value.hasErrors;\n                        this._taskSystem.hasErrors(this._configHasErrors);\n                    });\n                }\n                return value;\n            });\n        }\n        computeWorkspaceTasks(runSource = tasks_1.TaskRunSource.User) {\n            if (this.workspaceFolders.length === 0) {\n                return Promise.resolve(new Map());\n            }\n            else {\n                let promises = [];\n                for (let folder of this.workspaceFolders) {\n                    promises.push(this.computeWorkspaceFolderTasks(folder, runSource).then((value) => value, () => undefined));\n                }\n                return Promise.all(promises).then((values) => {\n                    let result = new Map();\n                    for (let value of values) {\n                        if (value) {\n                            result.set(value.workspaceFolder.uri.toString(), value);\n                        }\n                    }\n                    return result;\n                });\n            }\n        }\n        computeWorkspaceFolderTasks(workspaceFolder, runSource = tasks_1.TaskRunSource.User) {\n            return (this.executionEngine === tasks_1.ExecutionEngine.Process\n                ? this.computeLegacyConfiguration(workspaceFolder)\n                : this.computeConfiguration(workspaceFolder)).\n                then((workspaceFolderConfiguration) => {\n                if (!workspaceFolderConfiguration || !workspaceFolderConfiguration.config || workspaceFolderConfiguration.hasErrors) {\n                    return Promise.resolve({ workspaceFolder, set: undefined, configurations: undefined, hasErrors: workspaceFolderConfiguration ? workspaceFolderConfiguration.hasErrors : false });\n                }\n                return problemMatcher_1.ProblemMatcherRegistry.onReady().then(() => {\n                    let taskSystemInfo = this._taskSystemInfos.get(workspaceFolder.uri.scheme);\n                    let problemReporter = new ProblemReporter(this._outputChannel);\n                    let parseResult = TaskConfig.parse(workspaceFolder, taskSystemInfo ? taskSystemInfo.platform : Platform.platform, workspaceFolderConfiguration.config, problemReporter);\n                    let hasErrors = false;\n                    if (!parseResult.validationStatus.isOK()) {\n                        hasErrors = true;\n                        this.showOutput(runSource);\n                    }\n                    if (problemReporter.status.isFatal()) {\n                        problemReporter.fatal(nls.localize('TaskSystem.configurationErrors', 'Error: the provided task configuration has validation errors and can\\'t not be used. Please correct the errors first.'));\n                        return { workspaceFolder, set: undefined, configurations: undefined, hasErrors };\n                    }\n                    let customizedTasks;\n                    if (parseResult.configured && parseResult.configured.length > 0) {\n                        customizedTasks = {\n                            byIdentifier: Object.create(null)\n                        };\n                        for (let task of parseResult.configured) {\n                            customizedTasks.byIdentifier[task.configures._key] = task;\n                        }\n                    }\n                    return { workspaceFolder, set: { tasks: parseResult.custom }, configurations: customizedTasks, hasErrors };\n                });\n            });\n        }\n        computeConfiguration(workspaceFolder) {\n            let { config, hasParseErrors } = this.getConfiguration(workspaceFolder);\n            return Promise.resolve({ workspaceFolder, config, hasErrors: hasParseErrors });\n        }\n        computeLegacyConfiguration(workspaceFolder) {\n            let { config, hasParseErrors } = this.getConfiguration(workspaceFolder);\n            if (hasParseErrors) {\n                return Promise.resolve({ workspaceFolder: workspaceFolder, hasErrors: true, config: undefined });\n            }\n            if (config) {\n                if (this.hasDetectorSupport(config)) {\n                    return new processRunnerDetector_1.ProcessRunnerDetector(workspaceFolder, this.fileService, this.contextService, this.configurationResolverService, config).detect(true).then((value) => {\n                        let hasErrors = this.printStderr(value.stderr);\n                        let detectedConfig = value.config;\n                        if (!detectedConfig) {\n                            return { workspaceFolder, config, hasErrors };\n                        }\n                        let result = Objects.deepClone(config);\n                        let configuredTasks = Object.create(null);\n                        const resultTasks = result.tasks;\n                        if (!resultTasks) {\n                            if (detectedConfig.tasks) {\n                                result.tasks = detectedConfig.tasks;\n                            }\n                        }\n                        else {\n                            resultTasks.forEach(task => {\n                                if (task.taskName) {\n                                    configuredTasks[task.taskName] = task;\n                                }\n                            });\n                            if (detectedConfig.tasks) {\n                                detectedConfig.tasks.forEach((task) => {\n                                    if (task.taskName && !configuredTasks[task.taskName]) {\n                                        resultTasks.push(task);\n                                    }\n                                });\n                            }\n                        }\n                        return { workspaceFolder, config: result, hasErrors };\n                    });\n                }\n                else {\n                    return Promise.resolve({ workspaceFolder, config, hasErrors: false });\n                }\n            }\n            else {\n                return new processRunnerDetector_1.ProcessRunnerDetector(workspaceFolder, this.fileService, this.contextService, this.configurationResolverService).detect(true).then((value) => {\n                    let hasErrors = this.printStderr(value.stderr);\n                    return { workspaceFolder, config: value.config, hasErrors };\n                });\n            }\n        }\n        computeWorkspaceFolderSetup() {\n            let workspaceFolders = [];\n            let ignoredWorkspaceFolders = [];\n            let executionEngine = tasks_1.ExecutionEngine.Terminal;\n            let schemaVersion = tasks_1.JsonSchemaVersion.V2_0_0;\n            if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n                let workspaceFolder = this.contextService.getWorkspace().folders[0];\n                workspaceFolders.push(workspaceFolder);\n                executionEngine = this.computeExecutionEngine(workspaceFolder);\n                schemaVersion = this.computeJsonSchemaVersion(workspaceFolder);\n            }\n            else if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.WORKSPACE) {\n                for (let workspaceFolder of this.contextService.getWorkspace().folders) {\n                    if (schemaVersion === this.computeJsonSchemaVersion(workspaceFolder)) {\n                        workspaceFolders.push(workspaceFolder);\n                    }\n                    else {\n                        ignoredWorkspaceFolders.push(workspaceFolder);\n                        this._outputChannel.append(nls.localize('taskService.ignoreingFolder', 'Ignoring task configurations for workspace folder {0}. Multi folder workspace task support requires that all folders use task version 2.0.0\\n', workspaceFolder.uri.fsPath));\n                    }\n                }\n            }\n            return [workspaceFolders, ignoredWorkspaceFolders, executionEngine, schemaVersion];\n        }\n        computeExecutionEngine(workspaceFolder) {\n            let { config } = this.getConfiguration(workspaceFolder);\n            if (!config) {\n                return tasks_1.ExecutionEngine._default;\n            }\n            return TaskConfig.ExecutionEngine.from(config);\n        }\n        computeJsonSchemaVersion(workspaceFolder) {\n            let { config } = this.getConfiguration(workspaceFolder);\n            if (!config) {\n                return tasks_1.JsonSchemaVersion.V2_0_0;\n            }\n            return TaskConfig.JsonSchemaVersion.from(config);\n        }\n        getConfiguration(workspaceFolder) {\n            let result = this.contextService.getWorkbenchState() !== workspace_1.WorkbenchState.EMPTY\n                ? Objects.deepClone(this.configurationService.getValue('tasks', { resource: workspaceFolder.uri }))\n                : undefined;\n            if (!result) {\n                return { config: undefined, hasParseErrors: false };\n            }\n            let parseErrors = result.$parseErrors;\n            if (parseErrors) {\n                let isAffected = false;\n                for (const parseError of parseErrors) {\n                    if (/tasks\\.json$/.test(parseError)) {\n                        isAffected = true;\n                        break;\n                    }\n                }\n                if (isAffected) {\n                    this._outputChannel.append(nls.localize('TaskSystem.invalidTaskJson', 'Error: The content of the tasks.json file has syntax errors. Please correct them before executing a task.\\n'));\n                    this.showOutput();\n                    return { config: undefined, hasParseErrors: true };\n                }\n            }\n            return { config: result, hasParseErrors: false };\n        }\n        printStderr(stderr) {\n            let result = false;\n            if (stderr && stderr.length > 0) {\n                stderr.forEach((line) => {\n                    result = true;\n                    this._outputChannel.append(line + '\\n');\n                });\n                this.showOutput();\n            }\n            return result;\n        }\n        inTerminal() {\n            if (this._taskSystem) {\n                return this._taskSystem instanceof terminalTaskSystem_1.TerminalTaskSystem;\n            }\n            return this.executionEngine === tasks_1.ExecutionEngine.Terminal;\n        }\n        hasDetectorSupport(config) {\n            if (!config.command || this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY) {\n                return false;\n            }\n            return processRunnerDetector_1.ProcessRunnerDetector.supports(TaskConfig.CommandString.value(config.command));\n        }\n        configureAction() {\n            const thisCapture = this;\n            return new class extends actions_1.Action {\n                constructor() {\n                    super(ConfigureTaskAction.ID, ConfigureTaskAction.TEXT, undefined, true, () => { thisCapture.runConfigureTasks(); return Promise.resolve(undefined); });\n                }\n            };\n        }\n        beforeShutdown() {\n            if (!this._taskSystem) {\n                return false;\n            }\n            if (!this._taskSystem.isActiveSync()) {\n                return false;\n            }\n            // The terminal service kills all terminal on shutdown. So there\n            // is nothing we can do to prevent this here.\n            if (this._taskSystem instanceof terminalTaskSystem_1.TerminalTaskSystem) {\n                return false;\n            }\n            let terminatePromise;\n            if (this._taskSystem.canAutoTerminate()) {\n                terminatePromise = Promise.resolve({ confirmed: true });\n            }\n            else {\n                terminatePromise = this.dialogService.confirm({\n                    message: nls.localize('TaskSystem.runningTask', 'There is a task running. Do you want to terminate it?'),\n                    primaryButton: nls.localize({ key: 'TaskSystem.terminateTask', comment: ['&& denotes a mnemonic'] }, \"&&Terminate Task\"),\n                    type: 'question'\n                });\n            }\n            return terminatePromise.then(res => {\n                if (res.confirmed) {\n                    return this._taskSystem.terminateAll().then((responses) => {\n                        let success = true;\n                        let code = undefined;\n                        for (let response of responses) {\n                            success = success && response.success;\n                            // We only have a code in the old output runner which only has one task\n                            // So we can use the first code.\n                            if (code === undefined && response.code !== undefined) {\n                                code = response.code;\n                            }\n                        }\n                        if (success) {\n                            this._taskSystem = undefined;\n                            this.disposeTaskSystemListeners();\n                            return false; // no veto\n                        }\n                        else if (code && code === processes_1.TerminateResponseCode.ProcessNotFound) {\n                            return this.dialogService.confirm({\n                                message: nls.localize('TaskSystem.noProcess', 'The launched task doesn\\'t exist anymore. If the task spawned background processes exiting VS Code might result in orphaned processes. To avoid this start the last background process with a wait flag.'),\n                                primaryButton: nls.localize({ key: 'TaskSystem.exitAnyways', comment: ['&& denotes a mnemonic'] }, \"&&Exit Anyways\"),\n                                type: 'info'\n                            }).then(res => !res.confirmed);\n                        }\n                        return true; // veto\n                    }, (err) => {\n                        return true; // veto\n                    });\n                }\n                return true; // veto\n            });\n        }\n        handleError(err) {\n            let showOutput = true;\n            if (err instanceof taskSystem_1.TaskError) {\n                let buildError = err;\n                let needsConfig = buildError.code === taskSystem_1.TaskErrors.NotConfigured || buildError.code === taskSystem_1.TaskErrors.NoBuildTask || buildError.code === taskSystem_1.TaskErrors.NoTestTask;\n                let needsTerminate = buildError.code === taskSystem_1.TaskErrors.RunningTask;\n                if (needsConfig || needsTerminate) {\n                    this.notificationService.prompt(buildError.severity, buildError.message, [{\n                            label: needsConfig ? ConfigureTaskAction.TEXT : nls.localize('TerminateAction.label', \"Terminate Task\"),\n                            run: () => {\n                                if (needsConfig) {\n                                    this.runConfigureTasks();\n                                }\n                                else {\n                                    this.runTerminateCommand();\n                                }\n                            }\n                        }]);\n                }\n                else {\n                    this.notificationService.notify({ severity: buildError.severity, message: buildError.message });\n                }\n            }\n            else if (err instanceof Error) {\n                let error = err;\n                this.notificationService.error(error.message);\n                showOutput = false;\n            }\n            else if (Types.isString(err)) {\n                this.notificationService.error(err);\n            }\n            else {\n                this.notificationService.error(nls.localize('TaskSystem.unknownError', 'An error has occurred while running a task. See task log for details.'));\n            }\n            if (showOutput) {\n                this.showOutput();\n            }\n        }\n        canRunCommand() {\n            if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.EMPTY) {\n                this.notificationService.info(nls.localize('TaskService.noWorkspace', 'Tasks are only available on a workspace folder.'));\n                return false;\n            }\n            return true;\n        }\n        createTaskQuickPickEntries(tasks, group = false, sort = false, selectedEntry) {\n            if (tasks === undefined || tasks === null || tasks.length === 0) {\n                return [];\n            }\n            const TaskQuickPickEntry = (task) => {\n                let description;\n                if (this.needsFolderQualification()) {\n                    let workspaceFolder = task.getWorkspaceFolder();\n                    if (workspaceFolder) {\n                        description = workspaceFolder.name;\n                    }\n                }\n                return { label: task._label, description, task };\n            };\n            function fillEntries(entries, tasks, groupLabel) {\n                if (tasks.length) {\n                    entries.push({ type: 'separator', label: groupLabel });\n                }\n                for (let task of tasks) {\n                    let entry = TaskQuickPickEntry(task);\n                    entry.buttons = [{ iconClass: 'quick-open-task-configure', tooltip: nls.localize('configureTask', \"Configure Task\") }];\n                    if (selectedEntry && (task === selectedEntry.task)) {\n                        entries.unshift(selectedEntry);\n                    }\n                    else {\n                        entries.push(entry);\n                    }\n                }\n            }\n            let entries;\n            if (group) {\n                entries = [];\n                if (tasks.length === 1) {\n                    entries.push(TaskQuickPickEntry(tasks[0]));\n                }\n                else {\n                    let recentlyUsedTasks = this.getRecentlyUsedTasks();\n                    let recent = [];\n                    let configured = [];\n                    let detected = [];\n                    let taskMap = Object.create(null);\n                    tasks.forEach(task => {\n                        let key = task.getRecentlyUsedKey();\n                        if (key) {\n                            taskMap[key] = task;\n                        }\n                    });\n                    recentlyUsedTasks.keys().forEach(key => {\n                        let task = taskMap[key];\n                        if (task) {\n                            recent.push(task);\n                        }\n                    });\n                    for (let task of tasks) {\n                        let key = task.getRecentlyUsedKey();\n                        if (!key || !recentlyUsedTasks.has(key)) {\n                            if (task._source.kind === tasks_1.TaskSourceKind.Workspace) {\n                                configured.push(task);\n                            }\n                            else {\n                                detected.push(task);\n                            }\n                        }\n                    }\n                    const sorter = this.createSorter();\n                    fillEntries(entries, recent, nls.localize('recentlyUsed', 'recently used tasks'));\n                    configured = configured.sort((a, b) => sorter.compare(a, b));\n                    fillEntries(entries, configured, nls.localize('configured', 'configured tasks'));\n                    detected = detected.sort((a, b) => sorter.compare(a, b));\n                    fillEntries(entries, detected, nls.localize('detected', 'detected tasks'));\n                }\n            }\n            else {\n                if (sort) {\n                    const sorter = this.createSorter();\n                    tasks = tasks.sort((a, b) => sorter.compare(a, b));\n                }\n                entries = tasks.map(task => TaskQuickPickEntry(task));\n            }\n            return entries;\n        }\n        showQuickPick(tasks, placeHolder, defaultEntry, group = false, sort = false, selectedEntry) {\n            let _createEntries = () => {\n                if (Array.isArray(tasks)) {\n                    return Promise.resolve(this.createTaskQuickPickEntries(tasks, group, sort, selectedEntry));\n                }\n                else {\n                    return tasks.then((tasks) => this.createTaskQuickPickEntries(tasks, group, sort, selectedEntry));\n                }\n            };\n            return this.quickInputService.pick(_createEntries().then((entries) => {\n                if ((entries.length === 0) && defaultEntry) {\n                    entries.push(defaultEntry);\n                }\n                return entries;\n            }), {\n                placeHolder,\n                matchOnDescription: true,\n                onDidTriggerItemButton: context => {\n                    let task = context.item.task;\n                    this.quickInputService.cancel();\n                    if (tasks_1.ContributedTask.is(task)) {\n                        this.customize(task, undefined, true);\n                    }\n                    else if (tasks_1.CustomTask.is(task)) {\n                        this.openConfig(task);\n                    }\n                }\n            }).then(entry => entry ? entry.task : undefined);\n        }\n        showIgnoredFoldersMessage() {\n            if (this.ignoredWorkspaceFolders.length === 0 || !this.showIgnoreMessage) {\n                return Promise.resolve(undefined);\n            }\n            this.notificationService.prompt(severity_1.default.Info, nls.localize('TaskService.ignoredFolder', 'The following workspace folders are ignored since they use task version 0.1.0: {0}', this.ignoredWorkspaceFolders.map(f => f.name).join(', ')), [{\n                    label: nls.localize('TaskService.notAgain', 'Don\\'t Show Again'),\n                    isSecondary: true,\n                    run: () => {\n                        this.storageService.store(TaskService.IgnoreTask010DonotShowAgain_key, true, storage_1.StorageScope.WORKSPACE);\n                        this._showIgnoreMessage = false;\n                    }\n                }]);\n            return Promise.resolve(undefined);\n        }\n        runTaskCommand(arg) {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            let identifier = this.getTaskIdentifier(arg);\n            if (identifier !== undefined) {\n                this.getGroupedTasks().then((grouped) => {\n                    let resolver = this.createResolver(grouped);\n                    let folders = this.contextService.getWorkspace().folders;\n                    for (let folder of folders) {\n                        let task = resolver.resolve(folder, identifier);\n                        if (task) {\n                            this.run(task).then(undefined, reason => {\n                                // eat the error, it has already been surfaced to the user and we don't care about it here\n                            });\n                            return;\n                        }\n                    }\n                    this.doRunTaskCommand(grouped.all());\n                }, () => {\n                    this.doRunTaskCommand();\n                });\n            }\n            else {\n                this.doRunTaskCommand();\n            }\n        }\n        doRunTaskCommand(tasks) {\n            this.showIgnoredFoldersMessage().then(() => {\n                this.showQuickPick(tasks ? tasks : this.tasks(), nls.localize('TaskService.pickRunTask', 'Select the task to run'), {\n                    label: nls.localize('TaslService.noEntryToRun', 'No task to run found. Configure Tasks...'),\n                    task: null\n                }, true).\n                    then((task) => {\n                    if (task === undefined) {\n                        return;\n                    }\n                    if (task === null) {\n                        this.runConfigureTasks();\n                    }\n                    else {\n                        this.run(task, { attachProblemMatcher: true }, tasks_1.TaskRunSource.User).then(undefined, reason => {\n                            // eat the error, it has already been surfaced to the user and we don't care about it here\n                        });\n                    }\n                });\n            });\n        }\n        reRunTaskCommand(arg) {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            problemMatcher_1.ProblemMatcherRegistry.onReady().then(() => {\n                return this.textFileService.saveAll().then((value) => {\n                    let executeResult = this.getTaskSystem().rerun();\n                    if (executeResult) {\n                        return this.handleExecuteResult(executeResult);\n                    }\n                    else {\n                        this.doRunTaskCommand();\n                        return Promise.resolve(undefined);\n                    }\n                });\n            });\n        }\n        splitPerGroupType(tasks) {\n            let none = [];\n            let defaults = [];\n            let users = [];\n            for (let task of tasks) {\n                if (task.configurationProperties.groupType === tasks_1.GroupType.default) {\n                    defaults.push(task);\n                }\n                else if (task.configurationProperties.groupType === tasks_1.GroupType.user) {\n                    users.push(task);\n                }\n                else {\n                    none.push(task);\n                }\n            }\n            return { none, defaults, users };\n        }\n        runBuildCommand() {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            if (this.schemaVersion === tasks_1.JsonSchemaVersion.V0_1_0) {\n                this.build();\n                return;\n            }\n            let options = {\n                location: progress_1.ProgressLocation.Window,\n                title: nls.localize('TaskService.fetchingBuildTasks', 'Fetching build tasks...')\n            };\n            let promise = this.getTasksForGroup(tasks_1.TaskGroup.Build).then((tasks) => {\n                if (tasks.length > 0) {\n                    let { defaults, users } = this.splitPerGroupType(tasks);\n                    if (defaults.length === 1) {\n                        this.run(defaults[0]).then(undefined, reason => {\n                            // eat the error, it has already been surfaced to the user and we don't care about it here\n                        });\n                        return;\n                    }\n                    else if (defaults.length + users.length > 0) {\n                        tasks = defaults.concat(users);\n                    }\n                }\n                this.showIgnoredFoldersMessage().then(() => {\n                    this.showQuickPick(tasks, nls.localize('TaskService.pickBuildTask', 'Select the build task to run'), {\n                        label: nls.localize('TaskService.noBuildTask', 'No build task to run found. Configure Build Task...'),\n                        task: null\n                    }, true).then((task) => {\n                        if (task === undefined) {\n                            return;\n                        }\n                        if (task === null) {\n                            this.runConfigureDefaultBuildTask();\n                            return;\n                        }\n                        this.run(task, { attachProblemMatcher: true }).then(undefined, reason => {\n                            // eat the error, it has already been surfaced to the user and we don't care about it here\n                        });\n                    });\n                });\n            });\n            this.progressService.withProgress(options, () => promise);\n        }\n        runTestCommand() {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            if (this.schemaVersion === tasks_1.JsonSchemaVersion.V0_1_0) {\n                this.runTest();\n                return;\n            }\n            let options = {\n                location: progress_1.ProgressLocation.Window,\n                title: nls.localize('TaskService.fetchingTestTasks', 'Fetching test tasks...')\n            };\n            let promise = this.getTasksForGroup(tasks_1.TaskGroup.Test).then((tasks) => {\n                if (tasks.length > 0) {\n                    let { defaults, users } = this.splitPerGroupType(tasks);\n                    if (defaults.length === 1) {\n                        this.run(defaults[0]).then(undefined, reason => {\n                            // eat the error, it has already been surfaced to the user and we don't care about it here\n                        });\n                        return;\n                    }\n                    else if (defaults.length + users.length > 0) {\n                        tasks = defaults.concat(users);\n                    }\n                }\n                this.showIgnoredFoldersMessage().then(() => {\n                    this.showQuickPick(tasks, nls.localize('TaskService.pickTestTask', 'Select the test task to run'), {\n                        label: nls.localize('TaskService.noTestTaskTerminal', 'No test task to run found. Configure Tasks...'),\n                        task: null\n                    }, true).then((task) => {\n                        if (task === undefined) {\n                            return;\n                        }\n                        if (task === null) {\n                            this.runConfigureTasks();\n                            return;\n                        }\n                        this.run(task).then(undefined, reason => {\n                            // eat the error, it has already been surfaced to the user and we don't care about it here\n                        });\n                    });\n                });\n            });\n            this.progressService.withProgress(options, () => promise);\n        }\n        runTerminateCommand(arg) {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            let runQuickPick = (promise) => {\n                this.showQuickPick(promise || this.getActiveTasks(), nls.localize('TaskService.tastToTerminate', 'Select task to terminate'), {\n                    label: nls.localize('TaskService.noTaskRunning', 'No task is currently running'),\n                    task: null\n                }, false, true).then(task => {\n                    if (task === undefined || task === null) {\n                        return;\n                    }\n                    this.terminate(task);\n                });\n            };\n            if (this.inTerminal()) {\n                let identifier = this.getTaskIdentifier(arg);\n                let promise;\n                if (identifier !== undefined) {\n                    promise = this.getActiveTasks();\n                    promise.then((tasks) => {\n                        for (let task of tasks) {\n                            if (task.matches(identifier)) {\n                                this.terminate(task);\n                                return;\n                            }\n                        }\n                        runQuickPick(promise);\n                    });\n                }\n                else {\n                    runQuickPick();\n                }\n            }\n            else {\n                this.isActive().then((active) => {\n                    if (active) {\n                        this.terminateAll().then((responses) => {\n                            // the output runner has only one task\n                            let response = responses[0];\n                            if (response.success) {\n                                return;\n                            }\n                            if (response.code && response.code === processes_1.TerminateResponseCode.ProcessNotFound) {\n                                this.notificationService.error(nls.localize('TerminateAction.noProcess', 'The launched process doesn\\'t exist anymore. If the task spawned background tasks exiting VS Code might result in orphaned processes.'));\n                            }\n                            else {\n                                this.notificationService.error(nls.localize('TerminateAction.failed', 'Failed to terminate running task'));\n                            }\n                        });\n                    }\n                });\n            }\n        }\n        runRestartTaskCommand(arg) {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            let runQuickPick = (promise) => {\n                this.showQuickPick(promise || this.getActiveTasks(), nls.localize('TaskService.tastToRestart', 'Select the task to restart'), {\n                    label: nls.localize('TaskService.noTaskToRestart', 'No task to restart'),\n                    task: null\n                }, false, true).then(task => {\n                    if (task === undefined || task === null) {\n                        return;\n                    }\n                    this.restart(task);\n                });\n            };\n            if (this.inTerminal()) {\n                let identifier = this.getTaskIdentifier(arg);\n                let promise;\n                if (identifier !== undefined) {\n                    promise = this.getActiveTasks();\n                    promise.then((tasks) => {\n                        for (let task of tasks) {\n                            if (task.matches(identifier)) {\n                                this.restart(task);\n                                return;\n                            }\n                        }\n                        runQuickPick(promise);\n                    });\n                }\n                else {\n                    runQuickPick();\n                }\n            }\n            else {\n                this.getActiveTasks().then((activeTasks) => {\n                    if (activeTasks.length === 0) {\n                        return;\n                    }\n                    let task = activeTasks[0];\n                    this.restart(task);\n                });\n            }\n        }\n        getTaskIdentifier(arg) {\n            let result = undefined;\n            if (Types.isString(arg)) {\n                result = arg;\n            }\n            else if (arg && Types.isString(arg.type)) {\n                result = tasks_1.TaskDefinition.createTaskIdentifier(arg, console);\n            }\n            return result;\n        }\n        runConfigureTasks() {\n            if (!this.canRunCommand()) {\n                return undefined;\n            }\n            let taskPromise;\n            if (this.schemaVersion === tasks_1.JsonSchemaVersion.V2_0_0) {\n                taskPromise = this.getGroupedTasks();\n            }\n            else {\n                taskPromise = Promise.resolve(new TaskMap());\n            }\n            let openTaskFile = (workspaceFolder) => {\n                let resource = workspaceFolder.toResource('.vscode/tasks.json');\n                let configFileCreated = false;\n                this.fileService.resolveFile(resource).then((stat) => stat, () => undefined).then((stat) => {\n                    if (stat) {\n                        return stat.resource;\n                    }\n                    return this.quickInputService.pick(taskTemplates_1.getTemplates(), { placeHolder: nls.localize('TaskService.template', 'Select a Task Template') }).then((selection) => {\n                        if (!selection) {\n                            return Promise.resolve(undefined);\n                        }\n                        let content = selection.content;\n                        let editorConfig = this.configurationService.getValue();\n                        if (editorConfig.editor.insertSpaces) {\n                            content = content.replace(/(\\n)(\\t+)/g, (_, s1, s2) => s1 + strings.repeat(' ', s2.length * editorConfig.editor.tabSize));\n                        }\n                        configFileCreated = true;\n                        /* __GDPR__\n                            \"taskService.template\" : {\n                                \"templateId\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n                                \"autoDetect\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\", \"isMeasurement\": true }\n                            }\n                        */\n                        return this.fileService.createFile(resource, content).then((result) => {\n                            this.telemetryService.publicLog(TaskService.TemplateTelemetryEventName, {\n                                templateId: selection.id,\n                                autoDetect: selection.autoDetect\n                            });\n                            return result.resource;\n                        });\n                    });\n                }).then((resource) => {\n                    if (!resource) {\n                        return;\n                    }\n                    this.editorService.openEditor({\n                        resource,\n                        options: {\n                            pinned: configFileCreated // pin only if config file is created #8727\n                        }\n                    });\n                });\n            };\n            let configureTask = (task) => {\n                if (tasks_1.ContributedTask.is(task)) {\n                    this.customize(task, undefined, true);\n                }\n                else if (tasks_1.CustomTask.is(task)) {\n                    this.openConfig(task);\n                }\n                else if (tasks_1.ConfiguringTask.is(task)) {\n                    // Do nothing.\n                }\n            };\n            function isTaskEntry(value) {\n                let candidate = value;\n                return candidate && !!candidate.task;\n            }\n            let stats = this.contextService.getWorkspace().folders.map((folder) => {\n                return this.fileService.resolveFile(folder.toResource('.vscode/tasks.json')).then(stat => stat, () => undefined);\n            });\n            let createLabel = nls.localize('TaskService.createJsonFile', 'Create tasks.json file from template');\n            let openLabel = nls.localize('TaskService.openJsonFile', 'Open tasks.json file');\n            let entries = Promise.all(stats).then((stats) => {\n                return taskPromise.then((taskMap) => {\n                    let entries = [];\n                    if (this.contextService.getWorkbenchState() === workspace_1.WorkbenchState.FOLDER) {\n                        let tasks = taskMap.all();\n                        let needsCreateOrOpen = true;\n                        if (tasks.length > 0) {\n                            tasks = tasks.sort((a, b) => a._label.localeCompare(b._label));\n                            for (let task of tasks) {\n                                entries.push({ label: task._label, task });\n                                if (!tasks_1.ContributedTask.is(task)) {\n                                    needsCreateOrOpen = false;\n                                }\n                            }\n                        }\n                        if (needsCreateOrOpen) {\n                            let label = stats[0] !== undefined ? openLabel : createLabel;\n                            if (entries.length) {\n                                entries.push({ type: 'separator' });\n                            }\n                            entries.push({ label, folder: this.contextService.getWorkspace().folders[0] });\n                        }\n                    }\n                    else {\n                        let folders = this.contextService.getWorkspace().folders;\n                        let index = 0;\n                        for (let folder of folders) {\n                            let tasks = taskMap.get(folder);\n                            if (tasks.length > 0) {\n                                tasks = tasks.slice().sort((a, b) => a._label.localeCompare(b._label));\n                                for (let i = 0; i < tasks.length; i++) {\n                                    let entry = { label: tasks[i]._label, task: tasks[i], description: folder.name };\n                                    if (i === 0) {\n                                        entries.push({ type: 'separator', label: folder.name });\n                                    }\n                                    entries.push(entry);\n                                }\n                            }\n                            else {\n                                let label = stats[index] !== undefined ? openLabel : createLabel;\n                                let entry = { label, folder: folder };\n                                entries.push({ type: 'separator', label: folder.name });\n                                entries.push(entry);\n                            }\n                            index++;\n                        }\n                    }\n                    return entries;\n                });\n            });\n            this.quickInputService.pick(entries, { placeHolder: nls.localize('TaskService.pickTask', 'Select a task to configure') }).\n                then((selection) => {\n                if (!selection) {\n                    return;\n                }\n                if (isTaskEntry(selection)) {\n                    configureTask(selection.task);\n                }\n                else {\n                    openTaskFile(selection.folder);\n                }\n            });\n        }\n        runConfigureDefaultBuildTask() {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            if (this.schemaVersion === tasks_1.JsonSchemaVersion.V2_0_0) {\n                this.tasks().then((tasks => {\n                    if (tasks.length === 0) {\n                        this.runConfigureTasks();\n                        return;\n                    }\n                    let selectedTask;\n                    let selectedEntry;\n                    for (let task of tasks) {\n                        if (task.configurationProperties.group === tasks_1.TaskGroup.Build && task.configurationProperties.groupType === tasks_1.GroupType.default) {\n                            selectedTask = task;\n                            break;\n                        }\n                    }\n                    if (selectedTask) {\n                        selectedEntry = {\n                            label: nls.localize('TaskService.defaultBuildTaskExists', '{0} is already marked as the default build task', selectedTask.getQualifiedLabel()),\n                            task: selectedTask\n                        };\n                    }\n                    this.showIgnoredFoldersMessage().then(() => {\n                        this.showQuickPick(tasks, nls.localize('TaskService.pickDefaultBuildTask', 'Select the task to be used as the default build task'), undefined, true, false, selectedEntry).\n                            then((task) => {\n                            if ((task === undefined) || (task === null)) {\n                                return;\n                            }\n                            if (task === selectedTask && tasks_1.CustomTask.is(task)) {\n                                this.openConfig(task);\n                            }\n                            if (!tasks_1.InMemoryTask.is(task)) {\n                                this.customize(task, { group: { kind: 'build', isDefault: true } }, true).then(() => {\n                                    if (selectedTask && (task !== selectedTask) && !tasks_1.InMemoryTask.is(selectedTask)) {\n                                        this.customize(selectedTask, { group: 'build' }, true);\n                                    }\n                                });\n                            }\n                        });\n                    });\n                }));\n            }\n            else {\n                this.runConfigureTasks();\n            }\n        }\n        runConfigureDefaultTestTask() {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            if (this.schemaVersion === tasks_1.JsonSchemaVersion.V2_0_0) {\n                this.tasks().then((tasks => {\n                    if (tasks.length === 0) {\n                        this.runConfigureTasks();\n                        return;\n                    }\n                    let selectedTask;\n                    let selectedEntry;\n                    for (let task of tasks) {\n                        if (task.configurationProperties.group === tasks_1.TaskGroup.Test && task.configurationProperties.groupType === tasks_1.GroupType.default) {\n                            selectedTask = task;\n                            break;\n                        }\n                    }\n                    if (selectedTask) {\n                        selectedEntry = {\n                            label: nls.localize('TaskService.defaultTestTaskExists', '{0} is already marked as the default test task.', selectedTask.getQualifiedLabel()),\n                            task: selectedTask\n                        };\n                    }\n                    this.showIgnoredFoldersMessage().then(() => {\n                        this.showQuickPick(tasks, nls.localize('TaskService.pickDefaultTestTask', 'Select the task to be used as the default test task'), undefined, true, false, selectedEntry).then((task) => {\n                            if (!task) {\n                                return;\n                            }\n                            if (task === selectedTask && tasks_1.CustomTask.is(task)) {\n                                this.openConfig(task);\n                            }\n                            if (!tasks_1.InMemoryTask.is(task)) {\n                                this.customize(task, { group: { kind: 'test', isDefault: true } }, true).then(() => {\n                                    if (selectedTask && (task !== selectedTask) && !tasks_1.InMemoryTask.is(selectedTask)) {\n                                        this.customize(selectedTask, { group: 'test' }, true);\n                                    }\n                                });\n                            }\n                        });\n                    });\n                }));\n            }\n            else {\n                this.runConfigureTasks();\n            }\n        }\n        runShowTasks() {\n            if (!this.canRunCommand()) {\n                return;\n            }\n            this.showQuickPick(this.getActiveTasks(), nls.localize('TaskService.pickShowTask', 'Select the task to show its output'), {\n                label: nls.localize('TaskService.noTaskIsRunning', 'No task is running'),\n                task: null\n            }, false, true).then((task) => {\n                if (task === undefined || task === null) {\n                    return;\n                }\n                this._taskSystem.revealTask(task);\n            });\n        }\n    };\n    // private static autoDetectTelemetryName: string = 'taskServer.autoDetect';\n    TaskService.RecentlyUsedTasks_Key = 'workbench.tasks.recentlyUsedTasks';\n    TaskService.IgnoreTask010DonotShowAgain_key = 'workbench.tasks.ignoreTask010Shown';\n    TaskService.CustomizationTelemetryEventName = 'taskService.customize';\n    TaskService.TemplateTelemetryEventName = 'taskService.template';\n    TaskService.OutputChannelId = 'tasks';\n    TaskService.OutputChannelLabel = nls.localize('tasks', \"Tasks\");\n    TaskService.nextHandle = 0;\n    TaskService = __decorate([\n        __param(0, configuration_1.IConfigurationService),\n        __param(1, markers_1.IMarkerService),\n        __param(2, output_1.IOutputService),\n        __param(3, editorService_1.IEditorService),\n        __param(4, files_1.IFileService),\n        __param(5, workspace_1.IWorkspaceContextService),\n        __param(6, telemetry_1.ITelemetryService),\n        __param(7, textfiles_1.ITextFileService),\n        __param(8, lifecycle_2.ILifecycleService),\n        __param(9, modelService_1.IModelService),\n        __param(10, extensions_2.IExtensionService),\n        __param(11, quickInput_1.IQuickInputService),\n        __param(12, configurationResolver_1.IConfigurationResolverService),\n        __param(13, terminal_1.ITerminalService),\n        __param(14, storage_1.IStorageService),\n        __param(15, progress_1.IProgressService2),\n        __param(16, opener_1.IOpenerService),\n        __param(17, windows_1.IWindowService),\n        __param(18, dialogs_1.IDialogService),\n        __param(19, notification_1.INotificationService),\n        __param(20, contextkey_1.IContextKeyService)\n    ], TaskService);\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '2_run',\n        command: {\n            id: 'workbench.action.tasks.runTask',\n            title: nls.localize({ key: 'miRunTask', comment: ['&& denotes a mnemonic'] }, \"&&Run Task...\")\n        },\n        order: 1\n    });\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '2_run',\n        command: {\n            id: 'workbench.action.tasks.build',\n            title: nls.localize({ key: 'miBuildTask', comment: ['&& denotes a mnemonic'] }, \"Run &&Build Task...\")\n        },\n        order: 2\n    });\n    // Manage Tasks\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '3_manage',\n        command: {\n            precondition: tasks_1.TASK_RUNNING_STATE,\n            id: 'workbench.action.tasks.showTasks',\n            title: nls.localize({ key: 'miRunningTask', comment: ['&& denotes a mnemonic'] }, \"Show Runnin&&g Tasks...\")\n        },\n        order: 1\n    });\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '3_manage',\n        command: {\n            precondition: tasks_1.TASK_RUNNING_STATE,\n            id: 'workbench.action.tasks.restartTask',\n            title: nls.localize({ key: 'miRestartTask', comment: ['&& denotes a mnemonic'] }, \"R&&estart Running Task...\")\n        },\n        order: 2\n    });\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '3_manage',\n        command: {\n            precondition: tasks_1.TASK_RUNNING_STATE,\n            id: 'workbench.action.tasks.terminate',\n            title: nls.localize({ key: 'miTerminateTask', comment: ['&& denotes a mnemonic'] }, \"&&Terminate Task...\")\n        },\n        order: 3\n    });\n    // Configure Tasks\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '4_configure',\n        command: {\n            id: 'workbench.action.tasks.configureTaskRunner',\n            title: nls.localize({ key: 'miConfigureTask', comment: ['&& denotes a mnemonic'] }, \"&&Configure Tasks...\")\n        },\n        order: 1\n    });\n    actions_2.MenuRegistry.appendMenuItem(actions_2.MenuId.MenubarTerminalMenu, {\n        group: '4_configure',\n        command: {\n            id: 'workbench.action.tasks.configureDefaultBuildTask',\n            title: nls.localize({ key: 'miConfigureBuildTask', comment: ['&& denotes a mnemonic'] }, \"Configure De&&fault Build Task...\")\n        },\n        order: 2\n    });\n    actions_2.MenuRegistry.addCommand({ id: ConfigureTaskAction.ID, title: { value: ConfigureTaskAction.TEXT, original: 'Configure Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.showLog', title: { value: nls.localize('ShowLogAction.label', \"Show Task Log\"), original: 'Show Task Log' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.runTask', title: { value: nls.localize('RunTaskAction.label', \"Run Task\"), original: 'Run Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.reRunTask', title: { value: nls.localize('ReRunTaskAction.label', \"Rerun Last Task\"), original: 'Rerun Last Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.restartTask', title: { value: nls.localize('RestartTaskAction.label', \"Restart Running Task\"), original: 'Restart Running Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.showTasks', title: { value: nls.localize('ShowTasksAction.label', \"Show Running Tasks\"), original: 'Show Running Tasks' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.terminate', title: { value: nls.localize('TerminateAction.label', \"Terminate Task\"), original: 'Terminate Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.build', title: { value: nls.localize('BuildAction.label', \"Run Build Task\"), original: 'Run Build Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.test', title: { value: nls.localize('TestAction.label', \"Run Test Task\"), original: 'Run Test Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.configureDefaultBuildTask', title: { value: nls.localize('ConfigureDefaultBuildTask.label', \"Configure Default Build Task\"), original: 'Configure Default Build Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    actions_2.MenuRegistry.addCommand({ id: 'workbench.action.tasks.configureDefaultTestTask', title: { value: nls.localize('ConfigureDefaultTestTask.label', \"Configure Default Test Task\"), original: 'Configure Default Test Task' }, category: { value: tasksCategory, original: 'Tasks' } });\n    // MenuRegistry.addCommand( { id: 'workbench.action.tasks.rebuild', title: nls.localize('RebuildAction.label', 'Run Rebuild Task'), category: tasksCategory });\n    // MenuRegistry.addCommand( { id: 'workbench.action.tasks.clean', title: nls.localize('CleanAction.label', 'Run Clean Task'), category: tasksCategory });\n    // Tasks Output channel. Register it before using it in Task Service.\n    let outputChannelRegistry = platform_1.Registry.as(output_1.Extensions.OutputChannels);\n    outputChannelRegistry.registerChannel({ id: TaskService.OutputChannelId, label: TaskService.OutputChannelLabel, log: false });\n    // Task Service\n    extensions_1.registerSingleton(taskService_1.ITaskService, TaskService, true);\n    // Register Quick Open\n    const quickOpenRegistry = (platform_1.Registry.as(quickopen_1.Extensions.Quickopen));\n    const tasksPickerContextKey = 'inTasksPicker';\n    quickOpenRegistry.registerQuickOpenHandler(new quickopen_1.QuickOpenHandlerDescriptor(taskQuickOpen_1.QuickOpenHandler, taskQuickOpen_1.QuickOpenHandler.ID, 'task ', tasksPickerContextKey, nls.localize('quickOpen.task', \"Run Task\")));\n    const actionBarRegistry = platform_1.Registry.as(actions_3.Extensions.Actionbar);\n    actionBarRegistry.registerActionBarContributor(actions_3.Scope.VIEWER, quickOpen_1.QuickOpenActionContributor);\n    // Status bar\n    let statusbarRegistry = platform_1.Registry.as(statusbar_1.Extensions.Statusbar);\n    statusbarRegistry.registerStatusbarItem(new statusbar_1.StatusbarItemDescriptor(BuildStatusBarItem, statusbar_2.StatusbarAlignment.LEFT, 50 /* Medium Priority */));\n    statusbarRegistry.registerStatusbarItem(new statusbar_1.StatusbarItemDescriptor(TaskStatusBarItem, statusbar_2.StatusbarAlignment.LEFT, 50 /* Medium Priority */));\n    // tasks.json validation\n    let schemaId = 'vscode://schemas/tasks';\n    let schema = {\n        id: schemaId,\n        description: 'Task definition file',\n        type: 'object',\n        default: {\n            version: '2.0.0',\n            tasks: [\n                {\n                    label: 'My Task',\n                    command: 'echo hello',\n                    type: 'shell',\n                    args: [],\n                    problemMatcher: ['$tsc'],\n                    presentation: {\n                        reveal: 'always'\n                    },\n                    group: 'build'\n                }\n            ]\n        }\n    };\n    schema.definitions = Object.assign({}, jsonSchema_v1_1.default.definitions, jsonSchema_v2_1.default.definitions);\n    schema.oneOf = [...(jsonSchema_v2_1.default.oneOf || []), ...(jsonSchema_v1_1.default.oneOf || [])];\n    let jsonRegistry = platform_1.Registry.as(jsonContributionRegistry.Extensions.JSONContribution);\n    jsonRegistry.registerSchema(schemaId, schema);\n    problemMatcher_1.ProblemMatcherRegistry.onMatcherChanged(() => {\n        jsonSchema_v2_1.updateProblemMatchers();\n        jsonRegistry.notifySchemaChanged(schemaId);\n    });\n});\n",null]}