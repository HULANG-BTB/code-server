{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeinset/electron-browser/codeInset.contribution.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/codeinset/electron-browser/codeInset.contribution.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/common/async\", \"vs/base/common/errors\", \"vs/base/common/lifecycle\", \"vs/editor/browser/core/editorState\", \"../common/codeInset\", \"./codeInsetWidget\", \"vs/editor/browser/editorExtensions\", \"vs/platform/registry/common/platform\", \"vs/platform/configuration/common/configurationRegistry\", \"vs/platform/configuration/common/configuration\"], function (require, exports, async_1, errors_1, lifecycle_1, editorState_1, codeInset_1, codeInsetWidget_1, editorExtensions_1, platform_1, configurationRegistry_1, configuration_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // import { localize } from 'vs/nls';\n    let CodeInsetController = class CodeInsetController {\n        constructor(_editor, _configService) {\n            this._editor = _editor;\n            this._configService = _configService;\n            this._pendingWebviews = new Map();\n            this._isEnabled = this._configService.getValue('editor.codeInsets');\n            this._globalToDispose = [];\n            this._localToDispose = [];\n            this._insetWidgets = [];\n            this._currentFindCodeInsetSymbolsPromise = null;\n            this._modelChangeCounter = 0;\n            this._globalToDispose.push(this._editor.onDidChangeModel(() => this._onModelChange()));\n            this._globalToDispose.push(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));\n            this._globalToDispose.push(this._configService.onDidChangeConfiguration(e => {\n                if (e.affectsConfiguration('editor.codeInsets')) {\n                    let prevIsEnabled = this._isEnabled;\n                    this._isEnabled = this._configService.getValue('editor.codeInsets');\n                    if (prevIsEnabled !== this._isEnabled) {\n                        this._onModelChange();\n                    }\n                }\n            }));\n            this._globalToDispose.push(codeInset_1.CodeInsetProviderRegistry.onDidChange(this._onModelChange, this));\n            this._onModelChange();\n        }\n        static get(editor) {\n            return editor.getContribution(CodeInsetController.ID);\n        }\n        dispose() {\n            this._localDispose();\n            this._globalToDispose = lifecycle_1.dispose(this._globalToDispose);\n        }\n        acceptWebview(symbolId, webviewElement) {\n            const pendingWebview = this._pendingWebviews.get(symbolId);\n            if (pendingWebview) {\n                pendingWebview(webviewElement);\n                this._pendingWebviews.delete(symbolId);\n                return true;\n            }\n            return false;\n        }\n        _localDispose() {\n            if (this._currentFindCodeInsetSymbolsPromise) {\n                this._currentFindCodeInsetSymbolsPromise.cancel();\n                this._currentFindCodeInsetSymbolsPromise = null;\n                this._modelChangeCounter++;\n            }\n            if (this._currentResolveCodeInsetSymbolsPromise) {\n                this._currentResolveCodeInsetSymbolsPromise.cancel();\n                this._currentResolveCodeInsetSymbolsPromise = null;\n            }\n            this._localToDispose = lifecycle_1.dispose(this._localToDispose);\n        }\n        getId() {\n            return CodeInsetController.ID;\n        }\n        _onModelChange() {\n            this._localDispose();\n            const model = this._editor.getModel();\n            if (!model || !this._isEnabled || !codeInset_1.CodeInsetProviderRegistry.has(model)) {\n                return;\n            }\n            for (const provider of codeInset_1.CodeInsetProviderRegistry.all(model)) {\n                if (typeof provider.onDidChange === 'function') {\n                    let registration = provider.onDidChange(() => scheduler.schedule());\n                    this._localToDispose.push(registration);\n                }\n            }\n            this._detectVisibleInsets = new async_1.RunOnceScheduler(() => {\n                this._onViewportChanged();\n            }, 500);\n            const scheduler = new async_1.RunOnceScheduler(() => {\n                const counterValue = ++this._modelChangeCounter;\n                if (this._currentFindCodeInsetSymbolsPromise) {\n                    this._currentFindCodeInsetSymbolsPromise.cancel();\n                }\n                this._currentFindCodeInsetSymbolsPromise = async_1.createCancelablePromise(token => codeInset_1.getCodeInsetData(model, token));\n                this._currentFindCodeInsetSymbolsPromise.then(codeInsetData => {\n                    if (counterValue === this._modelChangeCounter) { // only the last one wins\n                        this._renderCodeInsetSymbols(codeInsetData);\n                        this._detectVisibleInsets.schedule();\n                    }\n                }, errors_1.onUnexpectedError);\n            }, 250);\n            this._localToDispose.push(scheduler);\n            this._localToDispose.push(this._detectVisibleInsets);\n            this._localToDispose.push(this._editor.onDidChangeModelContent(() => {\n                this._editor.changeDecorations(changeAccessor => {\n                    this._editor.changeViewZones(viewAccessor => {\n                        let toDispose = [];\n                        let lastInsetLineNumber = -1;\n                        this._insetWidgets.forEach(inset => {\n                            if (!inset.isValid() || lastInsetLineNumber === inset.getLineNumber()) {\n                                // invalid -> Inset collapsed, attach range doesn't exist anymore\n                                // line_number -> insets should never be on the same line\n                                toDispose.push(inset);\n                            }\n                            else {\n                                inset.reposition(viewAccessor);\n                                lastInsetLineNumber = inset.getLineNumber();\n                            }\n                        });\n                        let helper = new codeInsetWidget_1.CodeInsetHelper();\n                        toDispose.forEach((l) => {\n                            l.dispose(helper, viewAccessor);\n                            this._insetWidgets.splice(this._insetWidgets.indexOf(l), 1);\n                        });\n                        helper.commit(changeAccessor);\n                    });\n                });\n                // Compute new `visible` code insets\n                this._detectVisibleInsets.schedule();\n                // Ask for all references again\n                scheduler.schedule();\n            }));\n            this._localToDispose.push(this._editor.onDidScrollChange(e => {\n                if (e.scrollTopChanged && this._insetWidgets.length > 0) {\n                    this._detectVisibleInsets.schedule();\n                }\n            }));\n            this._localToDispose.push(this._editor.onDidLayoutChange(() => {\n                this._detectVisibleInsets.schedule();\n            }));\n            this._localToDispose.push(lifecycle_1.toDisposable(() => {\n                if (this._editor.getModel()) {\n                    const scrollState = editorState_1.StableEditorScrollState.capture(this._editor);\n                    this._editor.changeDecorations((changeAccessor) => {\n                        this._editor.changeViewZones((accessor) => {\n                            this._disposeAllInsets(changeAccessor, accessor);\n                        });\n                    });\n                    scrollState.restore(this._editor);\n                }\n                else {\n                    // No accessors available\n                    this._disposeAllInsets(null, null);\n                }\n            }));\n            scheduler.schedule();\n        }\n        _disposeAllInsets(decChangeAccessor, viewZoneChangeAccessor) {\n            let helper = new codeInsetWidget_1.CodeInsetHelper();\n            this._insetWidgets.forEach((Inset) => Inset.dispose(helper, viewZoneChangeAccessor));\n            if (decChangeAccessor) {\n                helper.commit(decChangeAccessor);\n            }\n            this._insetWidgets = [];\n        }\n        _renderCodeInsetSymbols(symbols) {\n            if (!this._editor.hasModel()) {\n                return;\n            }\n            let maxLineNumber = this._editor.getModel().getLineCount();\n            let groups = [];\n            let lastGroup;\n            for (let symbol of symbols) {\n                let line = symbol.symbol.range.startLineNumber;\n                if (line < 1 || line > maxLineNumber) {\n                    // invalid code Inset\n                    continue;\n                }\n                else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {\n                    // on same line as previous\n                    lastGroup.push(symbol);\n                }\n                else {\n                    // on later line as previous\n                    lastGroup = [symbol];\n                    groups.push(lastGroup);\n                }\n            }\n            const scrollState = editorState_1.StableEditorScrollState.capture(this._editor);\n            this._editor.changeDecorations(changeAccessor => {\n                this._editor.changeViewZones(accessor => {\n                    let codeInsetIndex = 0, groupsIndex = 0, helper = new codeInsetWidget_1.CodeInsetHelper();\n                    while (groupsIndex < groups.length && codeInsetIndex < this._insetWidgets.length) {\n                        let symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;\n                        let codeInsetLineNumber = this._insetWidgets[codeInsetIndex].getLineNumber();\n                        if (codeInsetLineNumber < symbolsLineNumber) {\n                            this._insetWidgets[codeInsetIndex].dispose(helper, accessor);\n                            this._insetWidgets.splice(codeInsetIndex, 1);\n                        }\n                        else if (codeInsetLineNumber === symbolsLineNumber) {\n                            this._insetWidgets[codeInsetIndex].updateCodeInsetSymbols(groups[groupsIndex], helper);\n                            groupsIndex++;\n                            codeInsetIndex++;\n                        }\n                        else {\n                            this._insetWidgets.splice(codeInsetIndex, 0, new codeInsetWidget_1.CodeInsetWidget(groups[groupsIndex], this._editor, helper));\n                            codeInsetIndex++;\n                            groupsIndex++;\n                        }\n                    }\n                    // Delete extra code insets\n                    while (codeInsetIndex < this._insetWidgets.length) {\n                        this._insetWidgets[codeInsetIndex].dispose(helper, accessor);\n                        this._insetWidgets.splice(codeInsetIndex, 1);\n                    }\n                    // Create extra symbols\n                    while (groupsIndex < groups.length) {\n                        this._insetWidgets.push(new codeInsetWidget_1.CodeInsetWidget(groups[groupsIndex], this._editor, helper));\n                        groupsIndex++;\n                    }\n                    helper.commit(changeAccessor);\n                });\n            });\n            scrollState.restore(this._editor);\n        }\n        _onViewportChanged() {\n            if (this._currentResolveCodeInsetSymbolsPromise) {\n                this._currentResolveCodeInsetSymbolsPromise.cancel();\n                this._currentResolveCodeInsetSymbolsPromise = null;\n            }\n            const model = this._editor.getModel();\n            if (!model) {\n                return;\n            }\n            const allWidgetRequests = [];\n            const insetWidgets = [];\n            this._insetWidgets.forEach(inset => {\n                const widgetRequests = inset.computeIfNecessary(model);\n                if (widgetRequests) {\n                    allWidgetRequests.push(widgetRequests);\n                    insetWidgets.push(inset);\n                }\n            });\n            if (allWidgetRequests.length === 0) {\n                return;\n            }\n            this._currentResolveCodeInsetSymbolsPromise = async_1.createCancelablePromise(token => {\n                const allPromises = allWidgetRequests.map((widgetRequests, r) => {\n                    const widgetPromises = widgetRequests.map(request => {\n                        if (request.resolved) {\n                            return Promise.resolve(undefined);\n                        }\n                        let a = new Promise(resolve => {\n                            this._pendingWebviews.set(request.symbol.id, element => {\n                                request.resolved = true;\n                                insetWidgets[r].adoptWebview(element);\n                                resolve();\n                            });\n                        });\n                        let b = request.provider.resolveCodeInset(model, request.symbol, token);\n                        return Promise.all([a, b]);\n                    });\n                    return Promise.all(widgetPromises);\n                });\n                return Promise.all(allPromises);\n            });\n            this._currentResolveCodeInsetSymbolsPromise.then(() => {\n                this._currentResolveCodeInsetSymbolsPromise = null;\n            }).catch(err => {\n                this._currentResolveCodeInsetSymbolsPromise = null;\n                errors_1.onUnexpectedError(err);\n            });\n        }\n    };\n    CodeInsetController.ID = 'css.editor.codeInset';\n    CodeInsetController = __decorate([\n        __param(1, configuration_1.IConfigurationService)\n    ], CodeInsetController);\n    exports.CodeInsetController = CodeInsetController;\n    editorExtensions_1.registerEditorContribution(CodeInsetController);\n    platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).registerConfiguration({\n        id: 'editor',\n        properties: {\n        // ['editor.codeInsets']: {\n        // \tdescription: localize('editor.codeInsets', \"Enable/disable editor code insets\"),\n        // \ttype: 'boolean',\n        // \tdefault: false\n        // }\n        }\n    });\n});\n",null]}