{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/quickopen/quickOpenController.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/quickopen/quickOpenController.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nrequire(\"vs/css!./media/quickopen\");\nvar nls = require(\"vs/nls\");\nvar browser = require(\"vs/base/browser/browser\");\nvar strings = require(\"vs/base/common/strings\");\nvar resources = require(\"vs/base/common/resources\");\nvar types = require(\"vs/base/common/types\");\nvar actions_1 = require(\"vs/base/common/actions\");\nvar quickOpen_1 = require(\"vs/base/parts/quickopen/common/quickOpen\");\nvar quickOpenModel_1 = require(\"vs/base/parts/quickopen/browser/quickOpenModel\");\nvar quickOpenWidget_1 = require(\"vs/base/parts/quickopen/browser/quickOpenWidget\");\nvar actions_2 = require(\"vs/workbench/browser/actions\");\nvar textfiles_1 = require(\"vs/workbench/services/textfile/common/textfiles\");\nvar platform_1 = require(\"vs/platform/registry/common/platform\");\nvar modeService_1 = require(\"vs/editor/common/services/modeService\");\nvar getIconClasses_1 = require(\"vs/editor/common/services/getIconClasses\");\nvar modelService_1 = require(\"vs/editor/common/services/modelService\");\nvar editor_1 = require(\"vs/workbench/common/editor\");\nvar component_1 = require(\"vs/workbench/common/component\");\nvar event_1 = require(\"vs/base/common/event\");\nvar layoutService_1 = require(\"vs/workbench/services/layout/browser/layoutService\");\nvar quickopen_1 = require(\"vs/workbench/browser/quickopen\");\nvar errors = require(\"vs/base/common/errors\");\nvar quickOpen_2 = require(\"vs/platform/quickOpen/common/quickOpen\");\nvar configuration_1 = require(\"vs/platform/configuration/common/configuration\");\nvar instantiation_1 = require(\"vs/platform/instantiation/common/instantiation\");\nvar contextkey_1 = require(\"vs/platform/contextkey/common/contextkey\");\nvar history_1 = require(\"vs/workbench/services/history/common/history\");\nvar themeService_1 = require(\"vs/platform/theme/common/themeService\");\nvar theme_1 = require(\"vs/workbench/common/theme\");\nvar styler_1 = require(\"vs/platform/theme/common/styler\");\nvar environment_1 = require(\"vs/platform/environment/common/environment\");\nvar files_1 = require(\"vs/platform/files/common/files\");\nvar quickOpenScorer_1 = require(\"vs/base/parts/quickopen/common/quickOpenScorer\");\nvar listService_1 = require(\"vs/platform/list/browser/listService\");\nvar network_1 = require(\"vs/base/common/network\");\nvar notification_1 = require(\"vs/platform/notification/common/notification\");\nvar dom_1 = require(\"vs/base/browser/dom\");\nvar editorService_1 = require(\"vs/workbench/services/editor/common/editorService\");\nvar editorGroupsService_1 = require(\"vs/workbench/services/editor/common/editorGroupsService\");\nvar label_1 = require(\"vs/platform/label/common/label\");\nvar async_1 = require(\"vs/base/common/async\");\nvar quickInput_1 = require(\"vs/platform/quickinput/common/quickInput\");\nvar cancellation_1 = require(\"vs/base/common/cancellation\");\nvar storage_1 = require(\"vs/platform/storage/common/storage\");\nvar extensions_1 = require(\"vs/platform/instantiation/common/extensions\");\nvar HELP_PREFIX = '?';\nvar QuickOpenController = /** @class */ (function (_super) {\n    tslib_1.__extends(QuickOpenController, _super);\n    function QuickOpenController(editorGroupService, notificationService, contextKeyService, configurationService, instantiationService, layoutService, environmentService, themeService, storageService) {\n        var _this = _super.call(this, QuickOpenController.ID, themeService, storageService) || this;\n        _this.editorGroupService = editorGroupService;\n        _this.notificationService = notificationService;\n        _this.contextKeyService = contextKeyService;\n        _this.configurationService = configurationService;\n        _this.instantiationService = instantiationService;\n        _this.layoutService = layoutService;\n        _this.environmentService = environmentService;\n        _this._onShow = _this._register(new event_1.Emitter());\n        _this._onHide = _this._register(new event_1.Emitter());\n        _this.mapResolvedHandlersToPrefix = Object.create(null);\n        _this.mapContextKeyToContext = Object.create(null);\n        _this.handlerOnOpenCalled = Object.create(null);\n        _this.promisesToCompleteOnHide = [];\n        _this.actionProvider = new actions_2.ContributableActionProvider();\n        _this.editorHistoryHandler = _this.instantiationService.createInstance(EditorHistoryHandler);\n        _this.updateConfiguration();\n        _this.registerListeners();\n        return _this;\n    }\n    Object.defineProperty(QuickOpenController.prototype, \"onShow\", {\n        get: function () { return this._onShow.event; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuickOpenController.prototype, \"onHide\", {\n        get: function () { return this._onHide.event; },\n        enumerable: true,\n        configurable: true\n    });\n    QuickOpenController.prototype.registerListeners = function () {\n        var _this = this;\n        this._register(this.configurationService.onDidChangeConfiguration(function () { return _this.updateConfiguration(); }));\n        this._register(this.layoutService.onTitleBarVisibilityChange(function () { return _this.positionQuickOpenWidget(); }));\n        this._register(browser.onDidChangeZoomLevel(function () { return _this.positionQuickOpenWidget(); }));\n        this._register(this.layoutService.onLayout(function (dimension) { return _this.layout(dimension); }));\n    };\n    QuickOpenController.prototype.updateConfiguration = function () {\n        if (this.environmentService.args['sticky-quickopen']) {\n            this.closeOnFocusLost = false;\n        }\n        else {\n            this.closeOnFocusLost = this.configurationService.getValue(quickopen_1.CLOSE_ON_FOCUS_LOST_CONFIG);\n        }\n        this.preserveInput = this.configurationService.getValue(quickopen_1.PRESERVE_INPUT_CONFIG);\n        this.searchInEditorHistory = this.configurationService.getValue(quickopen_1.SEARCH_EDITOR_HISTORY);\n    };\n    QuickOpenController.prototype.navigate = function (next, quickNavigate) {\n        if (this.quickOpenWidget) {\n            this.quickOpenWidget.navigate(next, quickNavigate);\n        }\n    };\n    QuickOpenController.prototype.accept = function () {\n        if (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {\n            this.quickOpenWidget.accept();\n        }\n    };\n    QuickOpenController.prototype.focus = function () {\n        if (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {\n            this.quickOpenWidget.focus();\n        }\n    };\n    QuickOpenController.prototype.close = function () {\n        if (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {\n            this.quickOpenWidget.hide(quickOpenWidget_1.HideReason.CANCELED);\n        }\n    };\n    QuickOpenController.prototype.emitQuickOpenVisibilityChange = function (isVisible) {\n        if (isVisible) {\n            this._onShow.fire();\n        }\n        else {\n            this._onHide.fire();\n        }\n    };\n    QuickOpenController.prototype.show = function (prefix, options) {\n        var _this = this;\n        var quickNavigateConfiguration = options ? options.quickNavigateConfiguration : undefined;\n        var inputSelection = options ? options.inputSelection : undefined;\n        var autoFocus = options ? options.autoFocus : undefined;\n        var promiseCompletedOnHide = new Promise(function (c) {\n            _this.promisesToCompleteOnHide.push(c);\n        });\n        // Telemetry: log that quick open is shown and log the mode\n        var registry = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);\n        var handlerDescriptor = (prefix ? registry.getQuickOpenHandler(prefix) : undefined) || registry.getDefaultQuickOpenHandler();\n        // Trigger onOpen\n        this.resolveHandler(handlerDescriptor);\n        // Create upon first open\n        if (!this.quickOpenWidget) {\n            this.quickOpenWidget = this._register(new quickOpenWidget_1.QuickOpenWidget(this.layoutService.getWorkbenchElement(), {\n                onOk: function () { return _this.onOk(); },\n                onCancel: function () { },\n                onType: function (value) { return _this.onType(value || ''); },\n                onShow: function () { return _this.handleOnShow(); },\n                onHide: function (reason) { return _this.handleOnHide(reason); },\n                onFocusLost: function () { return !_this.closeOnFocusLost; }\n            }, {\n                inputPlaceHolder: this.hasHandler(HELP_PREFIX) ? nls.localize('quickOpenInput', \"Type '?' to get help on the actions you can take from here\") : '',\n                keyboardSupport: false,\n                treeCreator: function (container, config, opts) { return _this.instantiationService.createInstance(listService_1.WorkbenchTree, container, config, opts); }\n            }));\n            this._register(styler_1.attachQuickOpenStyler(this.quickOpenWidget, this.themeService, { background: theme_1.SIDE_BAR_BACKGROUND, foreground: theme_1.SIDE_BAR_FOREGROUND }));\n            var quickOpenContainer = this.quickOpenWidget.create();\n            dom_1.addClass(quickOpenContainer, 'show-file-icons');\n            this.positionQuickOpenWidget();\n        }\n        // Layout\n        this.quickOpenWidget.layout(this.layoutService.dimension);\n        // Show quick open with prefix or editor history\n        if (!this.quickOpenWidget.isVisible() || quickNavigateConfiguration) {\n            if (prefix) {\n                this.quickOpenWidget.show(prefix, { quickNavigateConfiguration: quickNavigateConfiguration, inputSelection: inputSelection, autoFocus: autoFocus });\n            }\n            else {\n                var editorHistory = this.getEditorHistoryWithGroupLabel();\n                if (editorHistory.getEntries().length < 2) {\n                    quickNavigateConfiguration = undefined; // If no entries can be shown, default to normal quick open mode\n                }\n                // Compute auto focus\n                if (!autoFocus) {\n                    if (!quickNavigateConfiguration) {\n                        autoFocus = { autoFocusFirstEntry: true };\n                    }\n                    else {\n                        var autoFocusFirstEntry = this.editorGroupService.activeGroup.count === 0;\n                        autoFocus = { autoFocusFirstEntry: autoFocusFirstEntry, autoFocusSecondEntry: !autoFocusFirstEntry };\n                    }\n                }\n                // Update context\n                var registry_1 = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);\n                this.setQuickOpenContextKey(registry_1.getDefaultQuickOpenHandler().contextKey);\n                if (this.preserveInput) {\n                    this.quickOpenWidget.show(editorHistory, { value: this.lastSubmittedInputValue, quickNavigateConfiguration: quickNavigateConfiguration, autoFocus: autoFocus, inputSelection: inputSelection });\n                }\n                else {\n                    this.quickOpenWidget.show(editorHistory, { quickNavigateConfiguration: quickNavigateConfiguration, autoFocus: autoFocus, inputSelection: inputSelection });\n                }\n            }\n        }\n        // Otherwise reset the widget to the prefix that is passed in\n        else {\n            this.quickOpenWidget.show(prefix || '', { inputSelection: inputSelection });\n        }\n        return promiseCompletedOnHide;\n    };\n    QuickOpenController.prototype.positionQuickOpenWidget = function () {\n        var titlebarOffset = this.layoutService.getTitleBarOffset();\n        if (this.quickOpenWidget) {\n            this.quickOpenWidget.getElement().style.top = titlebarOffset + \"px\";\n        }\n    };\n    QuickOpenController.prototype.handleOnShow = function () {\n        this.emitQuickOpenVisibilityChange(true);\n    };\n    QuickOpenController.prototype.handleOnHide = function (reason) {\n        var _this = this;\n        // Clear state\n        this.previousActiveHandlerDescriptor = null;\n        // Cancel pending results calls\n        this.cancelPendingGetResultsInvocation();\n        var _loop_1 = function (prefix) {\n            var promise = this_1.mapResolvedHandlersToPrefix[prefix];\n            promise.then(function (handler) {\n                _this.handlerOnOpenCalled[prefix] = false;\n                handler.onClose(reason === quickOpenWidget_1.HideReason.CANCELED); // Don't check if onOpen was called to preserve old behaviour for now\n            });\n        };\n        var this_1 = this;\n        // Pass to handlers\n        for (var prefix in this.mapResolvedHandlersToPrefix) {\n            _loop_1(prefix);\n        }\n        // Complete promises that are waiting\n        while (this.promisesToCompleteOnHide.length) {\n            var callback = this.promisesToCompleteOnHide.pop();\n            if (callback) {\n                callback(true);\n            }\n        }\n        if (reason !== quickOpenWidget_1.HideReason.FOCUS_LOST) {\n            this.editorGroupService.activeGroup.focus(); // focus back to editor group unless user clicked somewhere else\n        }\n        // Reset context keys\n        this.resetQuickOpenContextKeys();\n        // Events\n        this.emitQuickOpenVisibilityChange(false);\n    };\n    QuickOpenController.prototype.cancelPendingGetResultsInvocation = function () {\n        if (this.pendingGetResultsInvocation) {\n            this.pendingGetResultsInvocation.cancel();\n            this.pendingGetResultsInvocation.dispose();\n            this.pendingGetResultsInvocation = null;\n        }\n    };\n    QuickOpenController.prototype.resetQuickOpenContextKeys = function () {\n        var _this = this;\n        Object.keys(this.mapContextKeyToContext).forEach(function (k) { return _this.mapContextKeyToContext[k].reset(); });\n    };\n    QuickOpenController.prototype.setQuickOpenContextKey = function (id) {\n        var key;\n        if (id) {\n            key = this.mapContextKeyToContext[id];\n            if (!key) {\n                key = new contextkey_1.RawContextKey(id, false).bindTo(this.contextKeyService);\n                this.mapContextKeyToContext[id] = key;\n            }\n        }\n        if (key && key.get()) {\n            return; // already active context\n        }\n        this.resetQuickOpenContextKeys();\n        if (key) {\n            key.set(true);\n        }\n    };\n    QuickOpenController.prototype.hasHandler = function (prefix) {\n        return !!platform_1.Registry.as(quickopen_1.Extensions.Quickopen).getQuickOpenHandler(prefix);\n    };\n    QuickOpenController.prototype.getEditorHistoryWithGroupLabel = function () {\n        var entries = this.editorHistoryHandler.getResults();\n        // Apply label to first entry\n        if (entries.length > 0) {\n            entries[0] = new EditorHistoryEntryGroup(entries[0], nls.localize('historyMatches', \"recently opened\"), false);\n        }\n        return new quickOpenModel_1.QuickOpenModel(entries, this.actionProvider);\n    };\n    QuickOpenController.prototype.onOk = function () {\n        if (this.isQuickOpen) {\n            this.lastSubmittedInputValue = this.lastInputValue;\n        }\n    };\n    QuickOpenController.prototype.onType = function (value) {\n        var _this = this;\n        // cancel any pending get results invocation and create new\n        this.cancelPendingGetResultsInvocation();\n        var pendingResultsInvocationTokenSource = new cancellation_1.CancellationTokenSource();\n        var pendingResultsInvocationToken = pendingResultsInvocationTokenSource.token;\n        this.pendingGetResultsInvocation = pendingResultsInvocationTokenSource;\n        // look for a handler\n        var registry = platform_1.Registry.as(quickopen_1.Extensions.Quickopen);\n        var handlerDescriptor = registry.getQuickOpenHandler(value);\n        var defaultHandlerDescriptor = registry.getDefaultQuickOpenHandler();\n        var instantProgress = handlerDescriptor && handlerDescriptor.instantProgress;\n        var contextKey = handlerDescriptor ? handlerDescriptor.contextKey : defaultHandlerDescriptor.contextKey;\n        // Reset Progress\n        if (!instantProgress) {\n            this.quickOpenWidget.getProgressBar().stop().hide();\n        }\n        // Reset Extra Class\n        this.quickOpenWidget.setExtraClass(null);\n        // Update context\n        this.setQuickOpenContextKey(contextKey);\n        // Remove leading and trailing whitespace\n        var trimmedValue = strings.trim(value);\n        // If no value provided, default to editor history\n        if (!trimmedValue) {\n            // Trigger onOpen\n            this.resolveHandler(handlerDescriptor || defaultHandlerDescriptor);\n            this.quickOpenWidget.setInput(this.getEditorHistoryWithGroupLabel(), { autoFocusFirstEntry: true });\n            // If quickOpen entered empty we have to clear the prefill-cache\n            this.lastInputValue = '';\n            this.isQuickOpen = true;\n            return;\n        }\n        var resultPromise;\n        var resultPromiseDone = false;\n        if (handlerDescriptor) {\n            this.isQuickOpen = false;\n            resultPromise = this.handleSpecificHandler(handlerDescriptor, value, pendingResultsInvocationToken);\n        }\n        // Otherwise handle default handlers if no specific handler present\n        else {\n            this.isQuickOpen = true;\n            // Cache the value for prefilling the quickOpen next time is opened\n            this.lastInputValue = trimmedValue;\n            resultPromise = this.handleDefaultHandler(defaultHandlerDescriptor, value, pendingResultsInvocationToken);\n        }\n        // Remember as the active one\n        this.previousActiveHandlerDescriptor = handlerDescriptor;\n        // Progress if task takes a long time\n        setTimeout(function () {\n            if (!resultPromiseDone && !pendingResultsInvocationToken.isCancellationRequested) {\n                _this.quickOpenWidget.getProgressBar().infinite().show();\n            }\n        }, instantProgress ? 0 : 800);\n        // Promise done handling\n        resultPromise.then(function () {\n            resultPromiseDone = true;\n            if (!pendingResultsInvocationToken.isCancellationRequested) {\n                _this.quickOpenWidget.getProgressBar().hide();\n            }\n            pendingResultsInvocationTokenSource.dispose();\n        }, function (error) {\n            resultPromiseDone = true;\n            pendingResultsInvocationTokenSource.dispose();\n            errors.onUnexpectedError(error);\n            _this.notificationService.error(types.isString(error) ? new Error(error) : error);\n        });\n    };\n    QuickOpenController.prototype.handleDefaultHandler = function (handler, value, token) {\n        var _this = this;\n        // Fill in history results if matching and we are configured to search in history\n        var matchingHistoryEntries;\n        if (value && !this.searchInEditorHistory) {\n            matchingHistoryEntries = [];\n        }\n        else {\n            matchingHistoryEntries = this.editorHistoryHandler.getResults(value, token);\n        }\n        if (matchingHistoryEntries.length > 0) {\n            matchingHistoryEntries[0] = new EditorHistoryEntryGroup(matchingHistoryEntries[0], nls.localize('historyMatches', \"recently opened\"), false);\n        }\n        // Resolve\n        return this.resolveHandler(handler).then(function (resolvedHandler) {\n            var quickOpenModel = new quickOpenModel_1.QuickOpenModel(matchingHistoryEntries, _this.actionProvider);\n            var inputSet = false;\n            // If we have matching entries from history we want to show them directly and not wait for the other results to come in\n            // This also applies when we used to have entries from a previous run and now there are no more history results matching\n            var previousInput = _this.quickOpenWidget.getInput();\n            var wasShowingHistory = previousInput && previousInput.entries && previousInput.entries.some(function (e) { return e instanceof EditorHistoryEntry || e instanceof EditorHistoryEntryGroup; });\n            if (wasShowingHistory || matchingHistoryEntries.length > 0) {\n                var responseDelay = void 0;\n                if (resolvedHandler.hasShortResponseTime()) {\n                    responseDelay = async_1.timeout(QuickOpenController.MAX_SHORT_RESPONSE_TIME);\n                }\n                else {\n                    responseDelay = Promise.resolve();\n                }\n                responseDelay.then(function () {\n                    if (!token.isCancellationRequested && !inputSet) {\n                        _this.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });\n                        inputSet = true;\n                    }\n                });\n            }\n            // Get results\n            return resolvedHandler.getResults(value, token).then(function (result) {\n                if (!token.isCancellationRequested) {\n                    // now is the time to show the input if we did not have set it before\n                    if (!inputSet) {\n                        _this.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });\n                        inputSet = true;\n                    }\n                    // merge history and default handler results\n                    var handlerResults = (result && result.entries) || [];\n                    _this.mergeResults(quickOpenModel, handlerResults, types.withNullAsUndefined(resolvedHandler.getGroupLabel()));\n                }\n            });\n        });\n    };\n    QuickOpenController.prototype.mergeResults = function (quickOpenModel, handlerResults, groupLabel) {\n        // Remove results already showing by checking for a \"resource\" property\n        var mapEntryToResource = this.mapEntriesToResource(quickOpenModel);\n        var additionalHandlerResults = [];\n        for (var _i = 0, handlerResults_1 = handlerResults; _i < handlerResults_1.length; _i++) {\n            var result = handlerResults_1[_i];\n            var resource = result.getResource();\n            if (!result.mergeWithEditorHistory() || !resource || !mapEntryToResource[resource.toString()]) {\n                additionalHandlerResults.push(result);\n            }\n        }\n        // Show additional handler results below any existing results\n        if (additionalHandlerResults.length > 0) {\n            var autoFocusFirstEntry = (quickOpenModel.getEntries().length === 0); // the user might have selected another entry meanwhile in local history (see https://github.com/Microsoft/vscode/issues/20828)\n            var useTopBorder = quickOpenModel.getEntries().length > 0;\n            additionalHandlerResults[0] = new quickOpenModel_1.QuickOpenEntryGroup(additionalHandlerResults[0], groupLabel, useTopBorder);\n            quickOpenModel.addEntries(additionalHandlerResults);\n            this.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: autoFocusFirstEntry });\n        }\n        // Otherwise if no results are present (even from histoy) indicate this to the user\n        else if (quickOpenModel.getEntries().length === 0) {\n            quickOpenModel.addEntries([new PlaceholderQuickOpenEntry(nls.localize('noResultsFound1', \"No results found\"))]);\n            this.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: true });\n        }\n    };\n    QuickOpenController.prototype.handleSpecificHandler = function (handlerDescriptor, value, token) {\n        var _this = this;\n        return this.resolveHandler(handlerDescriptor).then(function (resolvedHandler) {\n            // Remove handler prefix from search value\n            value = value.substr(handlerDescriptor.prefix.length);\n            // Return early if the handler can not run in the current environment and inform the user\n            var canRun = resolvedHandler.canRun();\n            if (types.isUndefinedOrNull(canRun) || (typeof canRun === 'boolean' && !canRun) || typeof canRun === 'string') {\n                var placeHolderLabel = (typeof canRun === 'string') ? canRun : nls.localize('canNotRunPlaceholder', \"This quick open handler can not be used in the current context\");\n                var model = new quickOpenModel_1.QuickOpenModel([new PlaceholderQuickOpenEntry(placeHolderLabel)], _this.actionProvider);\n                _this.showModel(model, resolvedHandler.getAutoFocus(value, { model: model, quickNavigateConfiguration: _this.quickOpenWidget.getQuickNavigateConfiguration() }), types.withNullAsUndefined(resolvedHandler.getAriaLabel()));\n                return Promise.resolve(undefined);\n            }\n            // Support extra class from handler\n            var extraClass = resolvedHandler.getClass();\n            if (extraClass) {\n                _this.quickOpenWidget.setExtraClass(extraClass);\n            }\n            // When handlers change, clear the result list first before loading the new results\n            if (_this.previousActiveHandlerDescriptor !== handlerDescriptor) {\n                _this.clearModel();\n            }\n            // Receive Results from Handler and apply\n            return resolvedHandler.getResults(value, token).then(function (result) {\n                if (!token.isCancellationRequested) {\n                    if (!result || !result.entries.length) {\n                        var model = new quickOpenModel_1.QuickOpenModel([new PlaceholderQuickOpenEntry(resolvedHandler.getEmptyLabel(value))]);\n                        _this.showModel(model, resolvedHandler.getAutoFocus(value, { model: model, quickNavigateConfiguration: _this.quickOpenWidget.getQuickNavigateConfiguration() }), types.withNullAsUndefined(resolvedHandler.getAriaLabel()));\n                    }\n                    else {\n                        _this.showModel(result, resolvedHandler.getAutoFocus(value, { model: result, quickNavigateConfiguration: _this.quickOpenWidget.getQuickNavigateConfiguration() }), types.withNullAsUndefined(resolvedHandler.getAriaLabel()));\n                    }\n                }\n            });\n        });\n    };\n    QuickOpenController.prototype.showModel = function (model, autoFocus, ariaLabel) {\n        // If the given model is already set in the widget, refresh and return early\n        if (this.quickOpenWidget.getInput() === model) {\n            this.quickOpenWidget.refresh(model, autoFocus);\n            return;\n        }\n        // Otherwise just set it\n        this.quickOpenWidget.setInput(model, autoFocus, ariaLabel);\n    };\n    QuickOpenController.prototype.clearModel = function () {\n        this.showModel(new quickOpenModel_1.QuickOpenModel(), undefined);\n    };\n    QuickOpenController.prototype.mapEntriesToResource = function (model) {\n        var entries = model.getEntries();\n        var mapEntryToPath = {};\n        entries.forEach(function (entry) {\n            var resource = entry.getResource();\n            if (resource) {\n                mapEntryToPath[resource.toString()] = entry;\n            }\n        });\n        return mapEntryToPath;\n    };\n    QuickOpenController.prototype.resolveHandler = function (handler) {\n        var _this = this;\n        var result = this._resolveHandler(handler);\n        var id = handler.getId();\n        if (!this.handlerOnOpenCalled[id]) {\n            var original_1 = result;\n            this.handlerOnOpenCalled[id] = true;\n            result = this.mapResolvedHandlersToPrefix[id] = original_1.then(function (resolved) {\n                _this.mapResolvedHandlersToPrefix[id] = original_1;\n                resolved.onOpen();\n                return resolved;\n            });\n        }\n        return result.then(null, function (error) {\n            delete _this.mapResolvedHandlersToPrefix[id];\n            return Promise.reject(new Error(\"Unable to instantiate quick open handler \" + handler.getId() + \": \" + JSON.stringify(error)));\n        });\n    };\n    QuickOpenController.prototype._resolveHandler = function (handler) {\n        var id = handler.getId();\n        // Return Cached\n        if (this.mapResolvedHandlersToPrefix[id]) {\n            return this.mapResolvedHandlersToPrefix[id];\n        }\n        // Otherwise load and create\n        return this.mapResolvedHandlersToPrefix[id] = Promise.resolve(handler.instantiate(this.instantiationService));\n    };\n    QuickOpenController.prototype.layout = function (dimension) {\n        if (this.quickOpenWidget) {\n            this.quickOpenWidget.layout(dimension);\n        }\n    };\n    QuickOpenController.MAX_SHORT_RESPONSE_TIME = 500;\n    QuickOpenController.ID = 'workbench.component.quickopen';\n    QuickOpenController = tslib_1.__decorate([\n        tslib_1.__param(0, editorGroupsService_1.IEditorGroupsService),\n        tslib_1.__param(1, notification_1.INotificationService),\n        tslib_1.__param(2, contextkey_1.IContextKeyService),\n        tslib_1.__param(3, configuration_1.IConfigurationService),\n        tslib_1.__param(4, instantiation_1.IInstantiationService),\n        tslib_1.__param(5, layoutService_1.IWorkbenchLayoutService),\n        tslib_1.__param(6, environment_1.IEnvironmentService),\n        tslib_1.__param(7, themeService_1.IThemeService),\n        tslib_1.__param(8, storage_1.IStorageService)\n    ], QuickOpenController);\n    return QuickOpenController;\n}(component_1.Component));\nexports.QuickOpenController = QuickOpenController;\nvar PlaceholderQuickOpenEntry = /** @class */ (function (_super) {\n    tslib_1.__extends(PlaceholderQuickOpenEntry, _super);\n    function PlaceholderQuickOpenEntry(placeHolderLabel) {\n        var _this = _super.call(this) || this;\n        _this.placeHolderLabel = placeHolderLabel;\n        return _this;\n    }\n    PlaceholderQuickOpenEntry.prototype.getLabel = function () {\n        return this.placeHolderLabel;\n    };\n    return PlaceholderQuickOpenEntry;\n}(quickOpenModel_1.QuickOpenEntryGroup));\nvar EditorHistoryHandler = /** @class */ (function () {\n    function EditorHistoryHandler(historyService, instantiationService, fileService) {\n        this.historyService = historyService;\n        this.instantiationService = instantiationService;\n        this.fileService = fileService;\n        this.scorerCache = Object.create(null);\n    }\n    EditorHistoryHandler.prototype.getResults = function (searchValue, token) {\n        var _this = this;\n        // Massage search for scoring\n        var query = quickOpenScorer_1.prepareQuery(searchValue || '');\n        // Just return all if we are not searching\n        var history = this.historyService.getHistory();\n        if (!query.value) {\n            return history.map(function (input) { return _this.instantiationService.createInstance(EditorHistoryEntry, input); });\n        }\n        // Otherwise filter by search value and sort by score. Include matches on description\n        // in case the user is explicitly including path separators.\n        var accessor = query.containsPathSeparator ? MatchOnDescription : DoNotMatchOnDescription;\n        return history\n            // For now, only support to match on inputs that provide resource information\n            .filter(function (input) {\n            var resource;\n            if (input instanceof editor_1.EditorInput) {\n                resource = resourceForEditorHistory(input, _this.fileService);\n            }\n            else {\n                resource = input.resource;\n            }\n            return !!resource;\n        })\n            // Conver to quick open entries\n            .map(function (input) { return _this.instantiationService.createInstance(EditorHistoryEntry, input); })\n            // Make sure the search value is matching\n            .filter(function (e) {\n            var itemScore = quickOpenScorer_1.scoreItem(e, query, false, accessor, _this.scorerCache);\n            if (!itemScore.score) {\n                return false;\n            }\n            e.setHighlights(itemScore.labelMatch || [], itemScore.descriptionMatch);\n            return true;\n        })\n            // Sort by score and provide a fallback sorter that keeps the\n            // recency of items in case the score for items is the same\n            .sort(function (e1, e2) { return quickOpenScorer_1.compareItemsByScore(e1, e2, query, false, accessor, _this.scorerCache, function () { return -1; }); });\n    };\n    EditorHistoryHandler = tslib_1.__decorate([\n        tslib_1.__param(0, history_1.IHistoryService),\n        tslib_1.__param(1, instantiation_1.IInstantiationService),\n        tslib_1.__param(2, files_1.IFileService)\n    ], EditorHistoryHandler);\n    return EditorHistoryHandler;\n}());\nvar EditorHistoryItemAccessorClass = /** @class */ (function (_super) {\n    tslib_1.__extends(EditorHistoryItemAccessorClass, _super);\n    function EditorHistoryItemAccessorClass(allowMatchOnDescription) {\n        var _this = _super.call(this) || this;\n        _this.allowMatchOnDescription = allowMatchOnDescription;\n        return _this;\n    }\n    EditorHistoryItemAccessorClass.prototype.getItemDescription = function (entry) {\n        return this.allowMatchOnDescription ? entry.getDescription() : null;\n    };\n    return EditorHistoryItemAccessorClass;\n}(quickOpenModel_1.QuickOpenItemAccessorClass));\nvar MatchOnDescription = new EditorHistoryItemAccessorClass(true);\nvar DoNotMatchOnDescription = new EditorHistoryItemAccessorClass(false);\nvar EditorHistoryEntryGroup = /** @class */ (function (_super) {\n    tslib_1.__extends(EditorHistoryEntryGroup, _super);\n    function EditorHistoryEntryGroup() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return EditorHistoryEntryGroup;\n}(quickOpenModel_1.QuickOpenEntryGroup));\nexports.EditorHistoryEntryGroup = EditorHistoryEntryGroup;\nvar EditorHistoryEntry = /** @class */ (function (_super) {\n    tslib_1.__extends(EditorHistoryEntry, _super);\n    function EditorHistoryEntry(input, editorService, modeService, modelService, textFileService, configurationService, labelService, fileService) {\n        var _this = _super.call(this, editorService) || this;\n        _this.modeService = modeService;\n        _this.modelService = modelService;\n        _this.textFileService = textFileService;\n        _this.configurationService = configurationService;\n        _this.input = input;\n        if (input instanceof editor_1.EditorInput) {\n            _this.resource = resourceForEditorHistory(input, fileService);\n            _this.label = input.getName();\n            _this.description = input.getDescription();\n            _this.dirty = input.isDirty();\n        }\n        else {\n            var resourceInput = input;\n            _this.resource = resourceInput.resource;\n            _this.label = resources.basenameOrAuthority(resourceInput.resource);\n            _this.description = labelService.getUriLabel(resources.dirname(_this.resource), { relative: true });\n            _this.dirty = _this.resource && _this.textFileService.isDirty(_this.resource);\n            if (_this.dirty && _this.textFileService.getAutoSaveMode() === textfiles_1.AutoSaveMode.AFTER_SHORT_DELAY) {\n                _this.dirty = false; // no dirty decoration if auto save is on with a short timeout\n            }\n        }\n        return _this;\n    }\n    EditorHistoryEntry.prototype.getIcon = function () {\n        return this.dirty ? 'dirty' : '';\n    };\n    EditorHistoryEntry.prototype.getLabel = function () {\n        return this.label;\n    };\n    EditorHistoryEntry.prototype.getLabelOptions = function () {\n        return {\n            extraClasses: getIconClasses_1.getIconClasses(this.modelService, this.modeService, this.resource)\n        };\n    };\n    EditorHistoryEntry.prototype.getAriaLabel = function () {\n        return nls.localize('entryAriaLabel', \"{0}, recently opened\", this.getLabel());\n    };\n    EditorHistoryEntry.prototype.getDescription = function () {\n        return this.description;\n    };\n    EditorHistoryEntry.prototype.getResource = function () {\n        return types.withUndefinedAsNull(this.resource);\n    };\n    EditorHistoryEntry.prototype.getInput = function () {\n        return this.input;\n    };\n    EditorHistoryEntry.prototype.run = function (mode, context) {\n        if (mode === quickOpen_1.Mode.OPEN) {\n            var sideBySide = !context.quickNavigateConfiguration && (context.keymods.alt || context.keymods.ctrlCmd);\n            var pinned = !this.configurationService.getValue().workbench.editor.enablePreviewFromQuickOpen || context.keymods.alt;\n            if (this.input instanceof editor_1.EditorInput) {\n                this.editorService.openEditor(this.input, { pinned: pinned }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);\n            }\n            else {\n                this.editorService.openEditor({ resource: this.input.resource, options: { pinned: pinned } }, sideBySide ? editorService_1.SIDE_GROUP : editorService_1.ACTIVE_GROUP);\n            }\n            return true;\n        }\n        return _super.prototype.run.call(this, mode, context);\n    };\n    EditorHistoryEntry = tslib_1.__decorate([\n        tslib_1.__param(1, editorService_1.IEditorService),\n        tslib_1.__param(2, modeService_1.IModeService),\n        tslib_1.__param(3, modelService_1.IModelService),\n        tslib_1.__param(4, textfiles_1.ITextFileService),\n        tslib_1.__param(5, configuration_1.IConfigurationService),\n        tslib_1.__param(6, label_1.ILabelService),\n        tslib_1.__param(7, files_1.IFileService)\n    ], EditorHistoryEntry);\n    return EditorHistoryEntry;\n}(quickopen_1.EditorQuickOpenEntry));\nexports.EditorHistoryEntry = EditorHistoryEntry;\nfunction resourceForEditorHistory(input, fileService) {\n    var resource = input ? input.getResource() : undefined;\n    // For the editor history we only prefer resources that are either untitled or\n    // can be handled by the file service which indicates they are editable resources.\n    if (resource && (fileService.canHandleResource(resource) || resource.scheme === network_1.Schemas.untitled)) {\n        return resource;\n    }\n    return undefined;\n}\nvar RemoveFromEditorHistoryAction = /** @class */ (function (_super) {\n    tslib_1.__extends(RemoveFromEditorHistoryAction, _super);\n    function RemoveFromEditorHistoryAction(id, label, quickInputService, modelService, modeService, instantiationService, historyService) {\n        var _this = _super.call(this, id, label) || this;\n        _this.quickInputService = quickInputService;\n        _this.modelService = modelService;\n        _this.modeService = modeService;\n        _this.instantiationService = instantiationService;\n        _this.historyService = historyService;\n        return _this;\n    }\n    RemoveFromEditorHistoryAction.prototype.run = function () {\n        var _this = this;\n        var history = this.historyService.getHistory();\n        var picks = history.map(function (h) {\n            var entry = _this.instantiationService.createInstance(EditorHistoryEntry, h);\n            return {\n                input: h,\n                iconClasses: getIconClasses_1.getIconClasses(_this.modelService, _this.modeService, types.withNullAsUndefined(entry.getResource())),\n                label: entry.getLabel(),\n                description: entry.getDescription()\n            };\n        });\n        return this.quickInputService.pick(picks, { placeHolder: nls.localize('pickHistory', \"Select an editor entry to remove from history\"), matchOnDescription: true }).then(function (pick) {\n            if (pick) {\n                _this.historyService.remove(pick.input);\n            }\n        });\n    };\n    RemoveFromEditorHistoryAction.ID = 'workbench.action.removeFromEditorHistory';\n    RemoveFromEditorHistoryAction.LABEL = nls.localize('removeFromEditorHistory', \"Remove From History\");\n    RemoveFromEditorHistoryAction = tslib_1.__decorate([\n        tslib_1.__param(2, quickInput_1.IQuickInputService),\n        tslib_1.__param(3, modelService_1.IModelService),\n        tslib_1.__param(4, modeService_1.IModeService),\n        tslib_1.__param(5, instantiation_1.IInstantiationService),\n        tslib_1.__param(6, history_1.IHistoryService)\n    ], RemoveFromEditorHistoryAction);\n    return RemoveFromEditorHistoryAction;\n}(actions_1.Action));\nexports.RemoveFromEditorHistoryAction = RemoveFromEditorHistoryAction;\nextensions_1.registerSingleton(quickOpen_2.IQuickOpenService, QuickOpenController, true);\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/quickopen/quickOpenController.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/browser/parts/quickopen/quickOpenController.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./media/quickopen';\nimport * as nls from 'vs/nls';\nimport * as browser from 'vs/base/browser/browser';\nimport * as strings from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport * as resources from 'vs/base/common/resources';\nimport * as types from 'vs/base/common/types';\nimport { Action } from 'vs/base/common/actions';\nimport { IIconLabelValueOptions } from 'vs/base/browser/ui/iconLabel/iconLabel';\nimport { Mode, IEntryRunContext, IAutoFocus, IQuickNavigateConfiguration, IModel } from 'vs/base/parts/quickopen/common/quickOpen';\nimport { QuickOpenEntry, QuickOpenModel, QuickOpenEntryGroup, QuickOpenItemAccessorClass } from 'vs/base/parts/quickopen/browser/quickOpenModel';\nimport { QuickOpenWidget, HideReason } from 'vs/base/parts/quickopen/browser/quickOpenWidget';\nimport { ContributableActionProvider } from 'vs/workbench/browser/actions';\nimport { ITextFileService, AutoSaveMode } from 'vs/workbench/services/textfile/common/textfiles';\nimport { Registry } from 'vs/platform/registry/common/platform';\nimport { IResourceInput } from 'vs/platform/editor/common/editor';\nimport { IModeService } from 'vs/editor/common/services/modeService';\nimport { getIconClasses } from 'vs/editor/common/services/getIconClasses';\nimport { IModelService } from 'vs/editor/common/services/modelService';\nimport { EditorInput, IWorkbenchEditorConfiguration, IEditorInput } from 'vs/workbench/common/editor';\nimport { Component } from 'vs/workbench/common/component';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IWorkbenchLayoutService } from 'vs/workbench/services/layout/browser/layoutService';\nimport { QuickOpenHandler, QuickOpenHandlerDescriptor, IQuickOpenRegistry, Extensions, EditorQuickOpenEntry, CLOSE_ON_FOCUS_LOST_CONFIG, SEARCH_EDITOR_HISTORY, PRESERVE_INPUT_CONFIG } from 'vs/workbench/browser/quickopen';\nimport * as errors from 'vs/base/common/errors';\nimport { IQuickOpenService, IShowOptions } from 'vs/platform/quickOpen/common/quickOpen';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IInstantiationService, ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\nimport { IContextKeyService, RawContextKey, IContextKey } from 'vs/platform/contextkey/common/contextkey';\nimport { IHistoryService } from 'vs/workbench/services/history/common/history';\nimport { IThemeService } from 'vs/platform/theme/common/themeService';\nimport { SIDE_BAR_BACKGROUND, SIDE_BAR_FOREGROUND } from 'vs/workbench/common/theme';\nimport { attachQuickOpenStyler } from 'vs/platform/theme/common/styler';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IFileService } from 'vs/platform/files/common/files';\nimport { scoreItem, ScorerCache, compareItemsByScore, prepareQuery } from 'vs/base/parts/quickopen/common/quickOpenScorer';\nimport { WorkbenchTree } from 'vs/platform/list/browser/listService';\nimport { Schemas } from 'vs/base/common/network';\nimport { INotificationService } from 'vs/platform/notification/common/notification';\nimport { Dimension, addClass } from 'vs/base/browser/dom';\nimport { IEditorService, ACTIVE_GROUP, SIDE_GROUP } from 'vs/workbench/services/editor/common/editorService';\nimport { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';\nimport { ILabelService } from 'vs/platform/label/common/label';\nimport { timeout } from 'vs/base/common/async';\nimport { IQuickInputService, IQuickPickItem } from 'vs/platform/quickinput/common/quickInput';\nimport { CancellationTokenSource, CancellationToken } from 'vs/base/common/cancellation';\nimport { IStorageService } from 'vs/platform/storage/common/storage';\nimport { registerSingleton } from 'vs/platform/instantiation/common/extensions';\n\nconst HELP_PREFIX = '?';\n\ntype ValueCallback<T = any> = (value: T | Promise<T>) => void;\n\nexport class QuickOpenController extends Component implements IQuickOpenService {\n\n\tprivate static readonly MAX_SHORT_RESPONSE_TIME = 500;\n\tprivate static readonly ID = 'workbench.component.quickopen';\n\n\t_serviceBrand: ServiceIdentifier<any>;\n\n\tprivate readonly _onShow: Emitter<void> = this._register(new Emitter<void>());\n\tget onShow(): Event<void> { return this._onShow.event; }\n\n\tprivate readonly _onHide: Emitter<void> = this._register(new Emitter<void>());\n\tget onHide(): Event<void> { return this._onHide.event; }\n\n\tprivate preserveInput: boolean;\n\tprivate isQuickOpen: boolean;\n\tprivate lastInputValue: string;\n\tprivate lastSubmittedInputValue: string;\n\tprivate quickOpenWidget: QuickOpenWidget;\n\tprivate mapResolvedHandlersToPrefix: { [prefix: string]: Promise<QuickOpenHandler>; } = Object.create(null);\n\tprivate mapContextKeyToContext: { [id: string]: IContextKey<boolean>; } = Object.create(null);\n\tprivate handlerOnOpenCalled: { [prefix: string]: boolean; } = Object.create(null);\n\tprivate promisesToCompleteOnHide: ValueCallback[] = [];\n\tprivate previousActiveHandlerDescriptor: QuickOpenHandlerDescriptor | null;\n\tprivate actionProvider = new ContributableActionProvider();\n\tprivate closeOnFocusLost: boolean;\n\tprivate searchInEditorHistory: boolean;\n\tprivate editorHistoryHandler: EditorHistoryHandler;\n\tprivate pendingGetResultsInvocation: CancellationTokenSource | null;\n\n\tconstructor(\n\t\t@IEditorGroupsService private readonly editorGroupService: IEditorGroupsService,\n\t\t@INotificationService private readonly notificationService: INotificationService,\n\t\t@IContextKeyService private readonly contextKeyService: IContextKeyService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IWorkbenchLayoutService private readonly layoutService: IWorkbenchLayoutService,\n\t\t@IEnvironmentService private readonly environmentService: IEnvironmentService,\n\t\t@IThemeService themeService: IThemeService,\n\t\t@IStorageService storageService: IStorageService\n\t) {\n\t\tsuper(QuickOpenController.ID, themeService, storageService);\n\n\t\tthis.editorHistoryHandler = this.instantiationService.createInstance(EditorHistoryHandler);\n\n\t\tthis.updateConfiguration();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tthis._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));\n\t\tthis._register(this.layoutService.onTitleBarVisibilityChange(() => this.positionQuickOpenWidget()));\n\t\tthis._register(browser.onDidChangeZoomLevel(() => this.positionQuickOpenWidget()));\n\t\tthis._register(this.layoutService.onLayout(dimension => this.layout(dimension)));\n\t}\n\n\tprivate updateConfiguration(): void {\n\t\tif (this.environmentService.args['sticky-quickopen']) {\n\t\t\tthis.closeOnFocusLost = false;\n\t\t} else {\n\t\t\tthis.closeOnFocusLost = this.configurationService.getValue(CLOSE_ON_FOCUS_LOST_CONFIG);\n\t\t}\n\t\tthis.preserveInput = this.configurationService.getValue(PRESERVE_INPUT_CONFIG);\n\n\t\tthis.searchInEditorHistory = this.configurationService.getValue(SEARCH_EDITOR_HISTORY);\n\t}\n\n\tnavigate(next: boolean, quickNavigate?: IQuickNavigateConfiguration): void {\n\t\tif (this.quickOpenWidget) {\n\t\t\tthis.quickOpenWidget.navigate(next, quickNavigate);\n\t\t}\n\t}\n\n\taccept(): void {\n\t\tif (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {\n\t\t\tthis.quickOpenWidget.accept();\n\t\t}\n\t}\n\n\tfocus(): void {\n\t\tif (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {\n\t\t\tthis.quickOpenWidget.focus();\n\t\t}\n\t}\n\n\tclose(): void {\n\t\tif (this.quickOpenWidget && this.quickOpenWidget.isVisible()) {\n\t\t\tthis.quickOpenWidget.hide(HideReason.CANCELED);\n\t\t}\n\t}\n\n\tprivate emitQuickOpenVisibilityChange(isVisible: boolean): void {\n\t\tif (isVisible) {\n\t\t\tthis._onShow.fire();\n\t\t} else {\n\t\t\tthis._onHide.fire();\n\t\t}\n\t}\n\n\tshow(prefix?: string, options?: IShowOptions): Promise<void> {\n\t\tlet quickNavigateConfiguration = options ? options.quickNavigateConfiguration : undefined;\n\t\tlet inputSelection = options ? options.inputSelection : undefined;\n\t\tlet autoFocus = options ? options.autoFocus : undefined;\n\n\t\tconst promiseCompletedOnHide = new Promise<void>(c => {\n\t\t\tthis.promisesToCompleteOnHide.push(c);\n\t\t});\n\n\t\t// Telemetry: log that quick open is shown and log the mode\n\t\tconst registry = Registry.as<IQuickOpenRegistry>(Extensions.Quickopen);\n\t\tconst handlerDescriptor = (prefix ? registry.getQuickOpenHandler(prefix) : undefined) || registry.getDefaultQuickOpenHandler();\n\n\t\t// Trigger onOpen\n\t\tthis.resolveHandler(handlerDescriptor);\n\n\t\t// Create upon first open\n\t\tif (!this.quickOpenWidget) {\n\t\t\tthis.quickOpenWidget = this._register(new QuickOpenWidget(\n\t\t\t\tthis.layoutService.getWorkbenchElement(),\n\t\t\t\t{\n\t\t\t\t\tonOk: () => this.onOk(),\n\t\t\t\t\tonCancel: () => { /* ignore */ },\n\t\t\t\t\tonType: (value: string) => this.onType(value || ''),\n\t\t\t\t\tonShow: () => this.handleOnShow(),\n\t\t\t\t\tonHide: (reason) => this.handleOnHide(reason),\n\t\t\t\t\tonFocusLost: () => !this.closeOnFocusLost\n\t\t\t\t}, {\n\t\t\t\t\tinputPlaceHolder: this.hasHandler(HELP_PREFIX) ? nls.localize('quickOpenInput', \"Type '?' to get help on the actions you can take from here\") : '',\n\t\t\t\t\tkeyboardSupport: false,\n\t\t\t\t\ttreeCreator: (container, config, opts) => this.instantiationService.createInstance(WorkbenchTree, container, config, opts)\n\t\t\t\t}\n\t\t\t));\n\t\t\tthis._register(attachQuickOpenStyler(this.quickOpenWidget, this.themeService, { background: SIDE_BAR_BACKGROUND, foreground: SIDE_BAR_FOREGROUND }));\n\n\t\t\tconst quickOpenContainer = this.quickOpenWidget.create();\n\t\t\taddClass(quickOpenContainer, 'show-file-icons');\n\t\t\tthis.positionQuickOpenWidget();\n\t\t}\n\n\t\t// Layout\n\t\tthis.quickOpenWidget.layout(this.layoutService.dimension);\n\n\t\t// Show quick open with prefix or editor history\n\t\tif (!this.quickOpenWidget.isVisible() || quickNavigateConfiguration) {\n\t\t\tif (prefix) {\n\t\t\t\tthis.quickOpenWidget.show(prefix, { quickNavigateConfiguration, inputSelection, autoFocus });\n\t\t\t} else {\n\t\t\t\tconst editorHistory = this.getEditorHistoryWithGroupLabel();\n\t\t\t\tif (editorHistory.getEntries().length < 2) {\n\t\t\t\t\tquickNavigateConfiguration = undefined; // If no entries can be shown, default to normal quick open mode\n\t\t\t\t}\n\n\t\t\t\t// Compute auto focus\n\t\t\t\tif (!autoFocus) {\n\t\t\t\t\tif (!quickNavigateConfiguration) {\n\t\t\t\t\t\tautoFocus = { autoFocusFirstEntry: true };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst autoFocusFirstEntry = this.editorGroupService.activeGroup.count === 0;\n\t\t\t\t\t\tautoFocus = { autoFocusFirstEntry, autoFocusSecondEntry: !autoFocusFirstEntry };\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update context\n\t\t\t\tconst registry = Registry.as<IQuickOpenRegistry>(Extensions.Quickopen);\n\t\t\t\tthis.setQuickOpenContextKey(registry.getDefaultQuickOpenHandler().contextKey);\n\t\t\t\tif (this.preserveInput) {\n\t\t\t\t\tthis.quickOpenWidget.show(editorHistory, { value: this.lastSubmittedInputValue, quickNavigateConfiguration, autoFocus, inputSelection });\n\t\t\t\t} else {\n\t\t\t\t\tthis.quickOpenWidget.show(editorHistory, { quickNavigateConfiguration, autoFocus, inputSelection });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise reset the widget to the prefix that is passed in\n\t\telse {\n\t\t\tthis.quickOpenWidget.show(prefix || '', { inputSelection });\n\t\t}\n\n\t\treturn promiseCompletedOnHide;\n\t}\n\n\tprivate positionQuickOpenWidget(): void {\n\t\tconst titlebarOffset = this.layoutService.getTitleBarOffset();\n\n\t\tif (this.quickOpenWidget) {\n\t\t\tthis.quickOpenWidget.getElement().style.top = `${titlebarOffset}px`;\n\t\t}\n\t}\n\n\tprivate handleOnShow(): void {\n\t\tthis.emitQuickOpenVisibilityChange(true);\n\t}\n\n\tprivate handleOnHide(reason: HideReason): void {\n\n\t\t// Clear state\n\t\tthis.previousActiveHandlerDescriptor = null;\n\n\t\t// Cancel pending results calls\n\t\tthis.cancelPendingGetResultsInvocation();\n\n\t\t// Pass to handlers\n\t\tfor (let prefix in this.mapResolvedHandlersToPrefix) {\n\t\t\tconst promise = this.mapResolvedHandlersToPrefix[prefix];\n\t\t\tpromise.then(handler => {\n\t\t\t\tthis.handlerOnOpenCalled[prefix] = false;\n\n\t\t\t\thandler.onClose(reason === HideReason.CANCELED); // Don't check if onOpen was called to preserve old behaviour for now\n\t\t\t});\n\t\t}\n\n\t\t// Complete promises that are waiting\n\t\twhile (this.promisesToCompleteOnHide.length) {\n\t\t\tconst callback = this.promisesToCompleteOnHide.pop();\n\t\t\tif (callback) {\n\t\t\t\tcallback(true);\n\t\t\t}\n\t\t}\n\n\t\tif (reason !== HideReason.FOCUS_LOST) {\n\t\t\tthis.editorGroupService.activeGroup.focus(); // focus back to editor group unless user clicked somewhere else\n\t\t}\n\n\t\t// Reset context keys\n\t\tthis.resetQuickOpenContextKeys();\n\n\t\t// Events\n\t\tthis.emitQuickOpenVisibilityChange(false);\n\t}\n\n\tprivate cancelPendingGetResultsInvocation(): void {\n\t\tif (this.pendingGetResultsInvocation) {\n\t\t\tthis.pendingGetResultsInvocation.cancel();\n\t\t\tthis.pendingGetResultsInvocation.dispose();\n\t\t\tthis.pendingGetResultsInvocation = null;\n\t\t}\n\t}\n\n\tprivate resetQuickOpenContextKeys(): void {\n\t\tObject.keys(this.mapContextKeyToContext).forEach(k => this.mapContextKeyToContext[k].reset());\n\t}\n\n\tprivate setQuickOpenContextKey(id?: string): void {\n\t\tlet key: IContextKey<boolean> | undefined;\n\t\tif (id) {\n\t\t\tkey = this.mapContextKeyToContext[id];\n\t\t\tif (!key) {\n\t\t\t\tkey = new RawContextKey<boolean>(id, false).bindTo(this.contextKeyService);\n\t\t\t\tthis.mapContextKeyToContext[id] = key;\n\t\t\t}\n\t\t}\n\n\t\tif (key && key.get()) {\n\t\t\treturn; // already active context\n\t\t}\n\n\t\tthis.resetQuickOpenContextKeys();\n\n\t\tif (key) {\n\t\t\tkey.set(true);\n\t\t}\n\t}\n\n\tprivate hasHandler(prefix: string): boolean {\n\t\treturn !!Registry.as<IQuickOpenRegistry>(Extensions.Quickopen).getQuickOpenHandler(prefix);\n\t}\n\n\tprivate getEditorHistoryWithGroupLabel(): QuickOpenModel {\n\t\tconst entries: QuickOpenEntry[] = this.editorHistoryHandler.getResults();\n\n\t\t// Apply label to first entry\n\t\tif (entries.length > 0) {\n\t\t\tentries[0] = new EditorHistoryEntryGroup(entries[0], nls.localize('historyMatches', \"recently opened\"), false);\n\t\t}\n\n\t\treturn new QuickOpenModel(entries, this.actionProvider);\n\t}\n\n\tprivate onOk(): void {\n\t\tif (this.isQuickOpen) {\n\t\t\tthis.lastSubmittedInputValue = this.lastInputValue;\n\t\t}\n\t}\n\n\tprivate onType(value: string): void {\n\n\t\t// cancel any pending get results invocation and create new\n\t\tthis.cancelPendingGetResultsInvocation();\n\t\tconst pendingResultsInvocationTokenSource = new CancellationTokenSource();\n\t\tconst pendingResultsInvocationToken = pendingResultsInvocationTokenSource.token;\n\t\tthis.pendingGetResultsInvocation = pendingResultsInvocationTokenSource;\n\n\t\t// look for a handler\n\t\tconst registry = Registry.as<IQuickOpenRegistry>(Extensions.Quickopen);\n\t\tconst handlerDescriptor = registry.getQuickOpenHandler(value);\n\t\tconst defaultHandlerDescriptor = registry.getDefaultQuickOpenHandler();\n\t\tconst instantProgress = handlerDescriptor && handlerDescriptor.instantProgress;\n\t\tconst contextKey = handlerDescriptor ? handlerDescriptor.contextKey : defaultHandlerDescriptor.contextKey;\n\n\t\t// Reset Progress\n\t\tif (!instantProgress) {\n\t\t\tthis.quickOpenWidget.getProgressBar().stop().hide();\n\t\t}\n\n\t\t// Reset Extra Class\n\t\tthis.quickOpenWidget.setExtraClass(null);\n\n\t\t// Update context\n\t\tthis.setQuickOpenContextKey(contextKey);\n\n\t\t// Remove leading and trailing whitespace\n\t\tconst trimmedValue = strings.trim(value);\n\n\t\t// If no value provided, default to editor history\n\t\tif (!trimmedValue) {\n\n\t\t\t// Trigger onOpen\n\t\t\tthis.resolveHandler(handlerDescriptor || defaultHandlerDescriptor);\n\n\t\t\tthis.quickOpenWidget.setInput(this.getEditorHistoryWithGroupLabel(), { autoFocusFirstEntry: true });\n\n\t\t\t// If quickOpen entered empty we have to clear the prefill-cache\n\t\t\tthis.lastInputValue = '';\n\t\t\tthis.isQuickOpen = true;\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet resultPromise: Promise<void>;\n\t\tlet resultPromiseDone = false;\n\n\t\tif (handlerDescriptor) {\n\t\t\tthis.isQuickOpen = false;\n\t\t\tresultPromise = this.handleSpecificHandler(handlerDescriptor, value, pendingResultsInvocationToken);\n\t\t}\n\n\t\t// Otherwise handle default handlers if no specific handler present\n\t\telse {\n\t\t\tthis.isQuickOpen = true;\n\t\t\t// Cache the value for prefilling the quickOpen next time is opened\n\t\t\tthis.lastInputValue = trimmedValue;\n\t\t\tresultPromise = this.handleDefaultHandler(defaultHandlerDescriptor, value, pendingResultsInvocationToken);\n\t\t}\n\n\t\t// Remember as the active one\n\t\tthis.previousActiveHandlerDescriptor = handlerDescriptor;\n\n\t\t// Progress if task takes a long time\n\t\tsetTimeout(() => {\n\t\t\tif (!resultPromiseDone && !pendingResultsInvocationToken.isCancellationRequested) {\n\t\t\t\tthis.quickOpenWidget.getProgressBar().infinite().show();\n\t\t\t}\n\t\t}, instantProgress ? 0 : 800);\n\n\t\t// Promise done handling\n\t\tresultPromise.then(() => {\n\t\t\tresultPromiseDone = true;\n\n\t\t\tif (!pendingResultsInvocationToken.isCancellationRequested) {\n\t\t\t\tthis.quickOpenWidget.getProgressBar().hide();\n\t\t\t}\n\n\t\t\tpendingResultsInvocationTokenSource.dispose();\n\t\t}, (error: any) => {\n\t\t\tresultPromiseDone = true;\n\n\t\t\tpendingResultsInvocationTokenSource.dispose();\n\n\t\t\terrors.onUnexpectedError(error);\n\t\t\tthis.notificationService.error(types.isString(error) ? new Error(error) : error);\n\t\t});\n\t}\n\n\tprivate handleDefaultHandler(handler: QuickOpenHandlerDescriptor, value: string, token: CancellationToken): Promise<void> {\n\n\t\t// Fill in history results if matching and we are configured to search in history\n\t\tlet matchingHistoryEntries: QuickOpenEntry[];\n\t\tif (value && !this.searchInEditorHistory) {\n\t\t\tmatchingHistoryEntries = [];\n\t\t} else {\n\t\t\tmatchingHistoryEntries = this.editorHistoryHandler.getResults(value, token);\n\t\t}\n\n\t\tif (matchingHistoryEntries.length > 0) {\n\t\t\tmatchingHistoryEntries[0] = new EditorHistoryEntryGroup(matchingHistoryEntries[0], nls.localize('historyMatches', \"recently opened\"), false);\n\t\t}\n\n\t\t// Resolve\n\t\treturn this.resolveHandler(handler).then(resolvedHandler => {\n\t\t\tconst quickOpenModel = new QuickOpenModel(matchingHistoryEntries, this.actionProvider);\n\n\t\t\tlet inputSet = false;\n\n\t\t\t// If we have matching entries from history we want to show them directly and not wait for the other results to come in\n\t\t\t// This also applies when we used to have entries from a previous run and now there are no more history results matching\n\t\t\tconst previousInput = this.quickOpenWidget.getInput();\n\t\t\tconst wasShowingHistory = previousInput && previousInput.entries && previousInput.entries.some(e => e instanceof EditorHistoryEntry || e instanceof EditorHistoryEntryGroup);\n\t\t\tif (wasShowingHistory || matchingHistoryEntries.length > 0) {\n\t\t\t\tlet responseDelay: Promise<void>;\n\t\t\t\tif (resolvedHandler.hasShortResponseTime()) {\n\t\t\t\t\tresponseDelay = timeout(QuickOpenController.MAX_SHORT_RESPONSE_TIME);\n\t\t\t\t} else {\n\t\t\t\t\tresponseDelay = Promise.resolve();\n\t\t\t\t}\n\n\t\t\t\tresponseDelay.then(() => {\n\t\t\t\t\tif (!token.isCancellationRequested && !inputSet) {\n\t\t\t\t\t\tthis.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });\n\t\t\t\t\t\tinputSet = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Get results\n\t\t\treturn resolvedHandler.getResults(value, token).then(result => {\n\t\t\t\tif (!token.isCancellationRequested) {\n\n\t\t\t\t\t// now is the time to show the input if we did not have set it before\n\t\t\t\t\tif (!inputSet) {\n\t\t\t\t\t\tthis.quickOpenWidget.setInput(quickOpenModel, { autoFocusFirstEntry: true });\n\t\t\t\t\t\tinputSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// merge history and default handler results\n\t\t\t\t\tconst handlerResults = (result && result.entries) || [];\n\t\t\t\t\tthis.mergeResults(quickOpenModel, handlerResults, types.withNullAsUndefined(resolvedHandler.getGroupLabel()));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate mergeResults(quickOpenModel: QuickOpenModel, handlerResults: QuickOpenEntry[], groupLabel: string | undefined): void {\n\n\t\t// Remove results already showing by checking for a \"resource\" property\n\t\tconst mapEntryToResource = this.mapEntriesToResource(quickOpenModel);\n\t\tconst additionalHandlerResults: QuickOpenEntry[] = [];\n\t\tfor (const result of handlerResults) {\n\t\t\tconst resource = result.getResource();\n\n\t\t\tif (!result.mergeWithEditorHistory() || !resource || !mapEntryToResource[resource.toString()]) {\n\t\t\t\tadditionalHandlerResults.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// Show additional handler results below any existing results\n\t\tif (additionalHandlerResults.length > 0) {\n\t\t\tconst autoFocusFirstEntry = (quickOpenModel.getEntries().length === 0); // the user might have selected another entry meanwhile in local history (see https://github.com/Microsoft/vscode/issues/20828)\n\t\t\tconst useTopBorder = quickOpenModel.getEntries().length > 0;\n\t\t\tadditionalHandlerResults[0] = new QuickOpenEntryGroup(additionalHandlerResults[0], groupLabel, useTopBorder);\n\t\t\tquickOpenModel.addEntries(additionalHandlerResults);\n\t\t\tthis.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry });\n\t\t}\n\n\t\t// Otherwise if no results are present (even from histoy) indicate this to the user\n\t\telse if (quickOpenModel.getEntries().length === 0) {\n\t\t\tquickOpenModel.addEntries([new PlaceholderQuickOpenEntry(nls.localize('noResultsFound1', \"No results found\"))]);\n\t\t\tthis.quickOpenWidget.refresh(quickOpenModel, { autoFocusFirstEntry: true });\n\t\t}\n\t}\n\n\tprivate handleSpecificHandler(handlerDescriptor: QuickOpenHandlerDescriptor, value: string, token: CancellationToken): Promise<void> {\n\t\treturn this.resolveHandler(handlerDescriptor).then((resolvedHandler: QuickOpenHandler) => {\n\n\t\t\t// Remove handler prefix from search value\n\t\t\tvalue = value.substr(handlerDescriptor.prefix.length);\n\n\t\t\t// Return early if the handler can not run in the current environment and inform the user\n\t\t\tconst canRun = resolvedHandler.canRun();\n\t\t\tif (types.isUndefinedOrNull(canRun) || (typeof canRun === 'boolean' && !canRun) || typeof canRun === 'string') {\n\t\t\t\tconst placeHolderLabel = (typeof canRun === 'string') ? canRun : nls.localize('canNotRunPlaceholder', \"This quick open handler can not be used in the current context\");\n\n\t\t\t\tconst model = new QuickOpenModel([new PlaceholderQuickOpenEntry(placeHolderLabel)], this.actionProvider);\n\t\t\t\tthis.showModel(model, resolvedHandler.getAutoFocus(value, { model, quickNavigateConfiguration: this.quickOpenWidget.getQuickNavigateConfiguration() }), types.withNullAsUndefined(resolvedHandler.getAriaLabel()));\n\n\t\t\t\treturn Promise.resolve(undefined);\n\t\t\t}\n\n\t\t\t// Support extra class from handler\n\t\t\tconst extraClass = resolvedHandler.getClass();\n\t\t\tif (extraClass) {\n\t\t\t\tthis.quickOpenWidget.setExtraClass(extraClass);\n\t\t\t}\n\n\t\t\t// When handlers change, clear the result list first before loading the new results\n\t\t\tif (this.previousActiveHandlerDescriptor !== handlerDescriptor) {\n\t\t\t\tthis.clearModel();\n\t\t\t}\n\n\t\t\t// Receive Results from Handler and apply\n\t\t\treturn resolvedHandler.getResults(value, token).then(result => {\n\t\t\t\tif (!token.isCancellationRequested) {\n\t\t\t\t\tif (!result || !result.entries.length) {\n\t\t\t\t\t\tconst model = new QuickOpenModel([new PlaceholderQuickOpenEntry(resolvedHandler.getEmptyLabel(value))]);\n\t\t\t\t\t\tthis.showModel(model, resolvedHandler.getAutoFocus(value, { model, quickNavigateConfiguration: this.quickOpenWidget.getQuickNavigateConfiguration() }), types.withNullAsUndefined(resolvedHandler.getAriaLabel()));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.showModel(result, resolvedHandler.getAutoFocus(value, { model: result, quickNavigateConfiguration: this.quickOpenWidget.getQuickNavigateConfiguration() }), types.withNullAsUndefined(resolvedHandler.getAriaLabel()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate showModel(model: IModel<any>, autoFocus?: IAutoFocus, ariaLabel?: string): void {\n\n\t\t// If the given model is already set in the widget, refresh and return early\n\t\tif (this.quickOpenWidget.getInput() === model) {\n\t\t\tthis.quickOpenWidget.refresh(model, autoFocus);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise just set it\n\t\tthis.quickOpenWidget.setInput(model, autoFocus, ariaLabel);\n\t}\n\n\tprivate clearModel(): void {\n\t\tthis.showModel(new QuickOpenModel(), undefined);\n\t}\n\n\tprivate mapEntriesToResource(model: QuickOpenModel): { [resource: string]: QuickOpenEntry; } {\n\t\tconst entries = model.getEntries();\n\t\tconst mapEntryToPath: { [path: string]: QuickOpenEntry; } = {};\n\t\tentries.forEach((entry: QuickOpenEntry) => {\n\t\t\tconst resource = entry.getResource();\n\t\t\tif (resource) {\n\t\t\t\tmapEntryToPath[resource.toString()] = entry;\n\t\t\t}\n\t\t});\n\n\t\treturn mapEntryToPath;\n\t}\n\n\tprivate resolveHandler(handler: QuickOpenHandlerDescriptor): Promise<QuickOpenHandler> {\n\t\tlet result = this._resolveHandler(handler);\n\n\t\tconst id = handler.getId();\n\t\tif (!this.handlerOnOpenCalled[id]) {\n\t\t\tconst original = result;\n\t\t\tthis.handlerOnOpenCalled[id] = true;\n\t\t\tresult = this.mapResolvedHandlersToPrefix[id] = original.then(resolved => {\n\t\t\t\tthis.mapResolvedHandlersToPrefix[id] = original;\n\t\t\t\tresolved.onOpen();\n\n\t\t\t\treturn resolved;\n\t\t\t});\n\t\t}\n\n\t\treturn result.then<QuickOpenHandler>(null, (error) => {\n\t\t\tdelete this.mapResolvedHandlersToPrefix[id];\n\n\t\t\treturn Promise.reject(new Error(`Unable to instantiate quick open handler ${handler.getId()}: ${JSON.stringify(error)}`));\n\t\t});\n\t}\n\n\tprivate _resolveHandler(handler: QuickOpenHandlerDescriptor): Promise<QuickOpenHandler> {\n\t\tconst id = handler.getId();\n\n\t\t// Return Cached\n\t\tif (this.mapResolvedHandlersToPrefix[id]) {\n\t\t\treturn this.mapResolvedHandlersToPrefix[id];\n\t\t}\n\n\t\t// Otherwise load and create\n\t\treturn this.mapResolvedHandlersToPrefix[id] = Promise.resolve(handler.instantiate(this.instantiationService));\n\t}\n\n\tlayout(dimension: Dimension): void {\n\t\tif (this.quickOpenWidget) {\n\t\t\tthis.quickOpenWidget.layout(dimension);\n\t\t}\n\t}\n}\n\nclass PlaceholderQuickOpenEntry extends QuickOpenEntryGroup {\n\tprivate placeHolderLabel: string;\n\n\tconstructor(placeHolderLabel: string) {\n\t\tsuper();\n\n\t\tthis.placeHolderLabel = placeHolderLabel;\n\t}\n\n\tgetLabel(): string {\n\t\treturn this.placeHolderLabel;\n\t}\n}\n\nclass EditorHistoryHandler {\n\tprivate scorerCache: ScorerCache;\n\n\tconstructor(\n\t\t@IHistoryService private readonly historyService: IHistoryService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IFileService private readonly fileService: IFileService\n\t) {\n\t\tthis.scorerCache = Object.create(null);\n\t}\n\n\tgetResults(searchValue?: string, token?: CancellationToken): QuickOpenEntry[] {\n\n\t\t// Massage search for scoring\n\t\tconst query = prepareQuery(searchValue || '');\n\n\t\t// Just return all if we are not searching\n\t\tconst history = this.historyService.getHistory();\n\t\tif (!query.value) {\n\t\t\treturn history.map(input => this.instantiationService.createInstance(EditorHistoryEntry, input));\n\t\t}\n\n\t\t// Otherwise filter by search value and sort by score. Include matches on description\n\t\t// in case the user is explicitly including path separators.\n\t\tconst accessor = query.containsPathSeparator ? MatchOnDescription : DoNotMatchOnDescription;\n\t\treturn history\n\n\t\t\t// For now, only support to match on inputs that provide resource information\n\t\t\t.filter(input => {\n\t\t\t\tlet resource: URI | undefined;\n\t\t\t\tif (input instanceof EditorInput) {\n\t\t\t\t\tresource = resourceForEditorHistory(input, this.fileService);\n\t\t\t\t} else {\n\t\t\t\t\tresource = (input as IResourceInput).resource;\n\t\t\t\t}\n\n\t\t\t\treturn !!resource;\n\t\t\t})\n\n\t\t\t// Conver to quick open entries\n\t\t\t.map(input => this.instantiationService.createInstance(EditorHistoryEntry, input))\n\n\t\t\t// Make sure the search value is matching\n\t\t\t.filter(e => {\n\t\t\t\tconst itemScore = scoreItem(e, query, false, accessor, this.scorerCache);\n\t\t\t\tif (!itemScore.score) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\te.setHighlights(itemScore.labelMatch || [], itemScore.descriptionMatch);\n\n\t\t\t\treturn true;\n\t\t\t})\n\n\t\t\t// Sort by score and provide a fallback sorter that keeps the\n\t\t\t// recency of items in case the score for items is the same\n\t\t\t.sort((e1, e2) => compareItemsByScore(e1, e2, query, false, accessor, this.scorerCache, () => -1));\n\t}\n}\n\nclass EditorHistoryItemAccessorClass extends QuickOpenItemAccessorClass {\n\n\tconstructor(private allowMatchOnDescription: boolean) {\n\t\tsuper();\n\t}\n\n\tgetItemDescription(entry: QuickOpenEntry): string | null {\n\t\treturn this.allowMatchOnDescription ? entry.getDescription() : null;\n\t}\n}\n\nconst MatchOnDescription = new EditorHistoryItemAccessorClass(true);\nconst DoNotMatchOnDescription = new EditorHistoryItemAccessorClass(false);\n\nexport class EditorHistoryEntryGroup extends QuickOpenEntryGroup {\n\t// Marker class\n}\n\nexport class EditorHistoryEntry extends EditorQuickOpenEntry {\n\tprivate input: IEditorInput | IResourceInput;\n\tprivate resource: URI | undefined;\n\tprivate label: string | null;\n\tprivate description: string | null;\n\tprivate dirty: boolean;\n\n\tconstructor(\n\t\tinput: IEditorInput | IResourceInput,\n\t\t@IEditorService editorService: IEditorService,\n\t\t@IModeService private readonly modeService: IModeService,\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@ITextFileService private readonly textFileService: ITextFileService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILabelService labelService: ILabelService,\n\t\t@IFileService fileService: IFileService\n\t) {\n\t\tsuper(editorService);\n\n\t\tthis.input = input;\n\n\t\tif (input instanceof EditorInput) {\n\t\t\tthis.resource = resourceForEditorHistory(input, fileService);\n\t\t\tthis.label = input.getName();\n\t\t\tthis.description = input.getDescription();\n\t\t\tthis.dirty = input.isDirty();\n\t\t} else {\n\t\t\tconst resourceInput = input as IResourceInput;\n\t\t\tthis.resource = resourceInput.resource;\n\t\t\tthis.label = resources.basenameOrAuthority(resourceInput.resource);\n\t\t\tthis.description = labelService.getUriLabel(resources.dirname(this.resource), { relative: true });\n\t\t\tthis.dirty = this.resource && this.textFileService.isDirty(this.resource);\n\n\t\t\tif (this.dirty && this.textFileService.getAutoSaveMode() === AutoSaveMode.AFTER_SHORT_DELAY) {\n\t\t\t\tthis.dirty = false; // no dirty decoration if auto save is on with a short timeout\n\t\t\t}\n\t\t}\n\t}\n\n\tgetIcon(): string {\n\t\treturn this.dirty ? 'dirty' : '';\n\t}\n\n\tgetLabel(): string | null {\n\t\treturn this.label;\n\t}\n\n\tgetLabelOptions(): IIconLabelValueOptions {\n\t\treturn {\n\t\t\textraClasses: getIconClasses(this.modelService, this.modeService, this.resource)\n\t\t};\n\t}\n\n\tgetAriaLabel(): string {\n\t\treturn nls.localize('entryAriaLabel', \"{0}, recently opened\", this.getLabel());\n\t}\n\n\tgetDescription(): string | null {\n\t\treturn this.description;\n\t}\n\n\tgetResource(): URI | null {\n\t\treturn types.withUndefinedAsNull(this.resource);\n\t}\n\n\tgetInput(): IEditorInput | IResourceInput {\n\t\treturn this.input;\n\t}\n\n\trun(mode: Mode, context: IEntryRunContext): boolean {\n\t\tif (mode === Mode.OPEN) {\n\t\t\tconst sideBySide = !context.quickNavigateConfiguration && (context.keymods.alt || context.keymods.ctrlCmd);\n\t\t\tconst pinned = !this.configurationService.getValue<IWorkbenchEditorConfiguration>().workbench.editor.enablePreviewFromQuickOpen || context.keymods.alt;\n\n\t\t\tif (this.input instanceof EditorInput) {\n\t\t\t\tthis.editorService.openEditor(this.input, { pinned }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);\n\t\t\t} else {\n\t\t\t\tthis.editorService.openEditor({ resource: (this.input as IResourceInput).resource, options: { pinned } }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn super.run(mode, context);\n\t}\n}\n\nfunction resourceForEditorHistory(input: EditorInput, fileService: IFileService): URI | undefined {\n\tconst resource = input ? input.getResource() : undefined;\n\n\t// For the editor history we only prefer resources that are either untitled or\n\t// can be handled by the file service which indicates they are editable resources.\n\tif (resource && (fileService.canHandleResource(resource) || resource.scheme === Schemas.untitled)) {\n\t\treturn resource;\n\t}\n\n\treturn undefined;\n}\n\nexport class RemoveFromEditorHistoryAction extends Action {\n\n\tstatic readonly ID = 'workbench.action.removeFromEditorHistory';\n\tstatic readonly LABEL = nls.localize('removeFromEditorHistory', \"Remove From History\");\n\n\tconstructor(\n\t\tid: string,\n\t\tlabel: string,\n\t\t@IQuickInputService private readonly quickInputService: IQuickInputService,\n\t\t@IModelService private readonly modelService: IModelService,\n\t\t@IModeService private readonly modeService: IModeService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@IHistoryService private readonly historyService: IHistoryService\n\t) {\n\t\tsuper(id, label);\n\t}\n\n\trun(): Promise<any> {\n\t\tinterface IHistoryPickEntry extends IQuickPickItem {\n\t\t\tinput: IEditorInput | IResourceInput;\n\t\t}\n\n\t\tconst history = this.historyService.getHistory();\n\t\tconst picks: IHistoryPickEntry[] = history.map(h => {\n\t\t\tconst entry = this.instantiationService.createInstance(EditorHistoryEntry, h);\n\n\t\t\treturn <IHistoryPickEntry>{\n\t\t\t\tinput: h,\n\t\t\t\ticonClasses: getIconClasses(this.modelService, this.modeService, types.withNullAsUndefined(entry.getResource())),\n\t\t\t\tlabel: entry.getLabel(),\n\t\t\t\tdescription: entry.getDescription()\n\t\t\t};\n\t\t});\n\n\t\treturn this.quickInputService.pick(picks, { placeHolder: nls.localize('pickHistory', \"Select an editor entry to remove from history\"), matchOnDescription: true }).then(pick => {\n\t\t\tif (pick) {\n\t\t\t\tthis.historyService.remove(pick.input);\n\t\t\t}\n\t\t});\n\t}\n}\n\nregisterSingleton(IQuickOpenService, QuickOpenController, true);"]}]}