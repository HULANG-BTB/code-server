{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/rename/renameInputField.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/rename/renameInputField.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorBrowser\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\", \"vs/editor/common/editorCommon\", \"vs/nls\", \"vs/platform/contextkey/common/contextkey\", \"vs/platform/theme/common/colorRegistry\", \"vs/css!./renameInputField\"], function (require, exports, lifecycle_1, editorBrowser_1, position_1, range_1, editorCommon_1, nls_1, contextkey_1, colorRegistry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.CONTEXT_RENAME_INPUT_VISIBLE = new contextkey_1.RawContextKey('renameInputVisible', false);\n    class RenameInputField {\n        constructor(editor, themeService, contextKeyService) {\n            this.themeService = themeService;\n            this._disposables = [];\n            // Editor.IContentWidget.allowEditorOverflow\n            this.allowEditorOverflow = true;\n            this._currentAcceptInput = null;\n            this._currentCancelInput = null;\n            this._visibleContextKey = exports.CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);\n            this._editor = editor;\n            this._editor.addContentWidget(this);\n            this._disposables.push(editor.onDidChangeConfiguration(e => {\n                if (e.fontInfo) {\n                    this.updateFont();\n                }\n            }));\n            this._disposables.push(themeService.onThemeChange(theme => this.onThemeChange(theme)));\n        }\n        onThemeChange(theme) {\n            this.updateStyles(theme);\n        }\n        dispose() {\n            this._disposables = lifecycle_1.dispose(this._disposables);\n            this._editor.removeContentWidget(this);\n        }\n        getId() {\n            return '__renameInputWidget';\n        }\n        getDomNode() {\n            if (!this._domNode) {\n                this._inputField = document.createElement('input');\n                this._inputField.className = 'rename-input';\n                this._inputField.type = 'text';\n                this._inputField.setAttribute('aria-label', nls_1.localize('renameAriaLabel', \"Rename input. Type new name and press Enter to commit.\"));\n                this._domNode = document.createElement('div');\n                this._domNode.style.height = `${this._editor.getConfiguration().lineHeight}px`;\n                this._domNode.className = 'monaco-editor rename-box';\n                this._domNode.appendChild(this._inputField);\n                this.updateFont();\n                this.updateStyles(this.themeService.getTheme());\n            }\n            return this._domNode;\n        }\n        updateStyles(theme) {\n            if (!this._inputField) {\n                return;\n            }\n            const background = theme.getColor(colorRegistry_1.inputBackground);\n            const foreground = theme.getColor(colorRegistry_1.inputForeground);\n            const widgetShadowColor = theme.getColor(colorRegistry_1.widgetShadow);\n            const border = theme.getColor(colorRegistry_1.inputBorder);\n            this._inputField.style.backgroundColor = background ? background.toString() : null;\n            this._inputField.style.color = foreground ? foreground.toString() : null;\n            this._inputField.style.borderWidth = border ? '1px' : '0px';\n            this._inputField.style.borderStyle = border ? 'solid' : 'none';\n            this._inputField.style.borderColor = border ? border.toString() : 'none';\n            this._domNode.style.boxShadow = widgetShadowColor ? ` 0 2px 8px ${widgetShadowColor}` : null;\n        }\n        updateFont() {\n            if (!this._inputField) {\n                return;\n            }\n            const fontInfo = this._editor.getConfiguration().fontInfo;\n            this._inputField.style.fontFamily = fontInfo.fontFamily;\n            this._inputField.style.fontWeight = fontInfo.fontWeight;\n            this._inputField.style.fontSize = `${fontInfo.fontSize}px`;\n        }\n        getPosition() {\n            return this._visible\n                ? { position: this._position, preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE] }\n                : null;\n        }\n        acceptInput() {\n            if (this._currentAcceptInput) {\n                this._currentAcceptInput();\n            }\n        }\n        cancelInput(focusEditor) {\n            if (this._currentCancelInput) {\n                this._currentCancelInput(focusEditor);\n            }\n        }\n        getInput(where, value, selectionStart, selectionEnd) {\n            this._position = new position_1.Position(where.startLineNumber, where.startColumn);\n            this._inputField.value = value;\n            this._inputField.setAttribute('selectionStart', selectionStart.toString());\n            this._inputField.setAttribute('selectionEnd', selectionEnd.toString());\n            this._inputField.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);\n            const disposeOnDone = [];\n            const always = () => {\n                lifecycle_1.dispose(disposeOnDone);\n                this._hide();\n            };\n            return new Promise(resolve => {\n                this._currentCancelInput = (focusEditor) => {\n                    this._currentAcceptInput = null;\n                    this._currentCancelInput = null;\n                    resolve(focusEditor);\n                    return true;\n                };\n                this._currentAcceptInput = () => {\n                    if (this._inputField.value.trim().length === 0 || this._inputField.value === value) {\n                        // empty or whitespace only or not changed\n                        this.cancelInput(true);\n                        return;\n                    }\n                    this._currentAcceptInput = null;\n                    this._currentCancelInput = null;\n                    resolve(this._inputField.value);\n                };\n                let onCursorChanged = () => {\n                    const editorPosition = this._editor.getPosition();\n                    if (!editorPosition || !range_1.Range.containsPosition(where, editorPosition)) {\n                        this.cancelInput(true);\n                    }\n                };\n                disposeOnDone.push(this._editor.onDidChangeCursorSelection(onCursorChanged));\n                disposeOnDone.push(this._editor.onDidBlurEditorWidget(() => this.cancelInput(false)));\n                this._show();\n            }).then(newValue => {\n                always();\n                return newValue;\n            }, err => {\n                always();\n                return Promise.reject(err);\n            });\n        }\n        _show() {\n            this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, editorCommon_1.ScrollType.Smooth);\n            this._visible = true;\n            this._visibleContextKey.set(true);\n            this._editor.layoutContentWidget(this);\n            setTimeout(() => {\n                this._inputField.focus();\n                this._inputField.setSelectionRange(parseInt(this._inputField.getAttribute('selectionStart')), parseInt(this._inputField.getAttribute('selectionEnd')));\n            }, 100);\n        }\n        _hide() {\n            this._visible = false;\n            this._visibleContextKey.reset();\n            this._editor.layoutContentWidget(this);\n        }\n    }\n    exports.RenameInputField = RenameInputField;\n});\n",null]}