{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/node/ports.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/ports.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar net = require(\"net\");\n/**\n * @returns Returns a random port between 1025 and 65535.\n */\nfunction randomPort() {\n    var min = 1025;\n    var max = 65535;\n    return min + Math.floor((max - min) * Math.random());\n}\nexports.randomPort = randomPort;\n/**\n * Given a start point and a max number of retries, will find a port that\n * is openable. Will return 0 in case no free port can be found.\n */\nfunction findFreePort(startPort, giveUpAfter, timeout) {\n    var done = false;\n    return new Promise(function (resolve) {\n        var timeoutHandle = setTimeout(function () {\n            if (!done) {\n                done = true;\n                return resolve(0);\n            }\n        }, timeout);\n        doFindFreePort(startPort, giveUpAfter, function (port) {\n            if (!done) {\n                done = true;\n                clearTimeout(timeoutHandle);\n                return resolve(port);\n            }\n        });\n    });\n}\nexports.findFreePort = findFreePort;\nfunction doFindFreePort(startPort, giveUpAfter, clb) {\n    if (giveUpAfter === 0) {\n        return clb(0);\n    }\n    var client = new net.Socket();\n    // If we can connect to the port it means the port is already taken so we continue searching\n    client.once('connect', function () {\n        dispose(client);\n        return doFindFreePort(startPort + 1, giveUpAfter - 1, clb);\n    });\n    client.once('data', function () {\n        // this listener is required since node.js 8.x\n    });\n    client.once('error', function (err) {\n        dispose(client);\n        // If we receive any non ECONNREFUSED error, it means the port is used but we cannot connect\n        if (err.code !== 'ECONNREFUSED') {\n            return doFindFreePort(startPort + 1, giveUpAfter - 1, clb);\n        }\n        // Otherwise it means the port is free to use!\n        return clb(startPort);\n    });\n    client.connect(startPort, '127.0.0.1');\n}\nfunction dispose(socket) {\n    try {\n        socket.removeAllListeners('connect');\n        socket.removeAllListeners('error');\n        socket.end();\n        socket.destroy();\n        socket.unref();\n    }\n    catch (error) {\n        console.error(error); // otherwise this error would get lost in the callback chain\n    }\n}\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/node/ports.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/node/ports.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,yBAA2B;AAE3B;;GAEG;AACH,SAAgB,UAAU;IACzB,IAAM,GAAG,GAAG,IAAI,CAAC;IACjB,IAAM,GAAG,GAAG,KAAK,CAAC;IAClB,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;AACtD,CAAC;AAJD,gCAIC;AAED;;;GAGG;AACH,SAAgB,YAAY,CAAC,SAAiB,EAAE,WAAmB,EAAE,OAAe;IACnF,IAAI,IAAI,GAAG,KAAK,CAAC;IAEjB,OAAO,IAAI,OAAO,CAAC,UAAA,OAAO;QACzB,IAAM,aAAa,GAAG,UAAU,CAAC;YAChC,IAAI,CAAC,IAAI,EAAE;gBACV,IAAI,GAAG,IAAI,CAAC;gBACZ,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;aAClB;QACF,CAAC,EAAE,OAAO,CAAC,CAAC;QAEZ,cAAc,CAAC,SAAS,EAAE,WAAW,EAAE,UAAC,IAAI;YAC3C,IAAI,CAAC,IAAI,EAAE;gBACV,IAAI,GAAG,IAAI,CAAC;gBACZ,YAAY,CAAC,aAAa,CAAC,CAAC;gBAC5B,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;aACrB;QACF,CAAC,CAAC,CAAC;IACJ,CAAC,CAAC,CAAC;AACJ,CAAC;AAnBD,oCAmBC;AAED,SAAS,cAAc,CAAC,SAAiB,EAAE,WAAmB,EAAE,GAA2B;IAC1F,IAAI,WAAW,KAAK,CAAC,EAAE;QACtB,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;KACd;IAED,IAAM,MAAM,GAAG,IAAI,GAAG,CAAC,MAAM,EAAE,CAAC;IAEhC,4FAA4F;IAC5F,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE;QACtB,OAAO,CAAC,MAAM,CAAC,CAAC;QAEhB,OAAO,cAAc,CAAC,SAAS,GAAG,CAAC,EAAE,WAAW,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;IAC5D,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE;QACnB,8CAA8C;IAC/C,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,UAAC,GAA8B;QACnD,OAAO,CAAC,MAAM,CAAC,CAAC;QAEhB,4FAA4F;QAC5F,IAAI,GAAG,CAAC,IAAI,KAAK,cAAc,EAAE;YAChC,OAAO,cAAc,CAAC,SAAS,GAAG,CAAC,EAAE,WAAW,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;SAC3D;QAED,8CAA8C;QAC9C,OAAO,GAAG,CAAC,SAAS,CAAC,CAAC;IACvB,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;AACxC,CAAC;AAED,SAAS,OAAO,CAAC,MAAkB;IAClC,IAAI;QACH,MAAM,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;QACrC,MAAM,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QACnC,MAAM,CAAC,GAAG,EAAE,CAAC;QACb,MAAM,CAAC,OAAO,EAAE,CAAC;QACjB,MAAM,CAAC,KAAK,EAAE,CAAC;KACf;IAAC,OAAO,KAAK,EAAE;QACf,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,4DAA4D;KAClF;AACF,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as net from 'net';\n\n/**\n * @returns Returns a random port between 1025 and 65535.\n */\nexport function randomPort(): number {\n\tconst min = 1025;\n\tconst max = 65535;\n\treturn min + Math.floor((max - min) * Math.random());\n}\n\n/**\n * Given a start point and a max number of retries, will find a port that\n * is openable. Will return 0 in case no free port can be found.\n */\nexport function findFreePort(startPort: number, giveUpAfter: number, timeout: number): Promise<number> {\n\tlet done = false;\n\n\treturn new Promise(resolve => {\n\t\tconst timeoutHandle = setTimeout(() => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\treturn resolve(0);\n\t\t\t}\n\t\t}, timeout);\n\n\t\tdoFindFreePort(startPort, giveUpAfter, (port) => {\n\t\t\tif (!done) {\n\t\t\t\tdone = true;\n\t\t\t\tclearTimeout(timeoutHandle);\n\t\t\t\treturn resolve(port);\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction doFindFreePort(startPort: number, giveUpAfter: number, clb: (port: number) => void): void {\n\tif (giveUpAfter === 0) {\n\t\treturn clb(0);\n\t}\n\n\tconst client = new net.Socket();\n\n\t// If we can connect to the port it means the port is already taken so we continue searching\n\tclient.once('connect', () => {\n\t\tdispose(client);\n\n\t\treturn doFindFreePort(startPort + 1, giveUpAfter - 1, clb);\n\t});\n\n\tclient.once('data', () => {\n\t\t// this listener is required since node.js 8.x\n\t});\n\n\tclient.once('error', (err: Error & { code?: string }) => {\n\t\tdispose(client);\n\n\t\t// If we receive any non ECONNREFUSED error, it means the port is used but we cannot connect\n\t\tif (err.code !== 'ECONNREFUSED') {\n\t\t\treturn doFindFreePort(startPort + 1, giveUpAfter - 1, clb);\n\t\t}\n\n\t\t// Otherwise it means the port is free to use!\n\t\treturn clb(startPort);\n\t});\n\n\tclient.connect(startPort, '127.0.0.1');\n}\n\nfunction dispose(socket: net.Socket): void {\n\ttry {\n\t\tsocket.removeAllListeners('connect');\n\t\tsocket.removeAllListeners('error');\n\t\tsocket.end();\n\t\tsocket.destroy();\n\t\tsocket.unref();\n\t} catch (error) {\n\t\tconsole.error(error); // otherwise this error would get lost in the callback chain\n\t}\n}\n"]}]}