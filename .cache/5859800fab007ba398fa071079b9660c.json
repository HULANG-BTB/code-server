{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingModel.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/folding/foldingModel.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/event\", \"./foldingRanges\"], function (require, exports, event_1, foldingRanges_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class FoldingModel {\n        constructor(textModel, decorationProvider) {\n            this._updateEventEmitter = new event_1.Emitter();\n            this._textModel = textModel;\n            this._decorationProvider = decorationProvider;\n            this._regions = new foldingRanges_1.FoldingRegions(new Uint32Array(0), new Uint32Array(0));\n            this._editorDecorationIds = [];\n            this._isInitialized = false;\n        }\n        get regions() { return this._regions; }\n        get onDidChange() { return this._updateEventEmitter.event; }\n        get textModel() { return this._textModel; }\n        get isInitialized() { return this._isInitialized; }\n        toggleCollapseState(regions) {\n            if (!regions.length) {\n                return;\n            }\n            let processed = {};\n            this._decorationProvider.changeDecorations(accessor => {\n                for (let region of regions) {\n                    let index = region.regionIndex;\n                    let editorDecorationId = this._editorDecorationIds[index];\n                    if (editorDecorationId && !processed[editorDecorationId]) {\n                        processed[editorDecorationId] = true;\n                        let newCollapseState = !this._regions.isCollapsed(index);\n                        this._regions.setCollapsed(index, newCollapseState);\n                        accessor.changeDecorationOptions(editorDecorationId, this._decorationProvider.getDecorationOption(newCollapseState));\n                    }\n                }\n            });\n            this._updateEventEmitter.fire({ model: this, collapseStateChanged: regions });\n        }\n        update(newRegions, blockedLineNumers = []) {\n            let newEditorDecorations = [];\n            let isBlocked = (startLineNumber, endLineNumber) => {\n                for (let blockedLineNumber of blockedLineNumers) {\n                    if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) { // first line is visible\n                        return true;\n                    }\n                }\n                return false;\n            };\n            let initRange = (index, isCollapsed) => {\n                let startLineNumber = newRegions.getStartLineNumber(index);\n                if (isCollapsed && isBlocked(startLineNumber, newRegions.getEndLineNumber(index))) {\n                    isCollapsed = false;\n                }\n                newRegions.setCollapsed(index, isCollapsed);\n                let maxColumn = this._textModel.getLineMaxColumn(startLineNumber);\n                let decorationRange = {\n                    startLineNumber: startLineNumber,\n                    startColumn: maxColumn,\n                    endLineNumber: startLineNumber,\n                    endColumn: maxColumn\n                };\n                newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed) });\n            };\n            let i = 0;\n            let nextCollapsed = () => {\n                while (i < this._regions.length) {\n                    let isCollapsed = this._regions.isCollapsed(i);\n                    i++;\n                    if (isCollapsed) {\n                        return i - 1;\n                    }\n                }\n                return -1;\n            };\n            let k = 0;\n            let collapsedIndex = nextCollapsed();\n            while (collapsedIndex !== -1 && k < newRegions.length) {\n                // get the latest range\n                let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);\n                if (decRange) {\n                    let collapsedStartLineNumber = decRange.startLineNumber;\n                    if (this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.startColumn) { // test that the decoration is still at the end otherwise it got deleted\n                        while (k < newRegions.length) {\n                            let startLineNumber = newRegions.getStartLineNumber(k);\n                            if (collapsedStartLineNumber >= startLineNumber) {\n                                initRange(k, collapsedStartLineNumber === startLineNumber);\n                                k++;\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                    }\n                }\n                collapsedIndex = nextCollapsed();\n            }\n            while (k < newRegions.length) {\n                initRange(k, false);\n                k++;\n            }\n            this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);\n            this._regions = newRegions;\n            this._isInitialized = true;\n            this._updateEventEmitter.fire({ model: this });\n        }\n        /**\n         * Collapse state memento, for persistence only\n         */\n        getMemento() {\n            let collapsedRanges = [];\n            for (let i = 0; i < this._regions.length; i++) {\n                if (this._regions.isCollapsed(i)) {\n                    let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);\n                    if (range) {\n                        let startLineNumber = range.startLineNumber;\n                        let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);\n                        collapsedRanges.push({ startLineNumber, endLineNumber });\n                    }\n                }\n            }\n            if (collapsedRanges.length > 0) {\n                return collapsedRanges;\n            }\n            return undefined;\n        }\n        /**\n         * Apply persisted state, for persistence only\n         */\n        applyMemento(state) {\n            if (!Array.isArray(state)) {\n                return;\n            }\n            let toToogle = [];\n            for (let range of state) {\n                let region = this.getRegionAtLine(range.startLineNumber);\n                if (region && !region.isCollapsed) {\n                    toToogle.push(region);\n                }\n            }\n            this.toggleCollapseState(toToogle);\n        }\n        dispose() {\n            this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);\n        }\n        getAllRegionsAtLine(lineNumber, filter) {\n            let result = [];\n            if (this._regions) {\n                let index = this._regions.findRange(lineNumber);\n                let level = 1;\n                while (index >= 0) {\n                    let current = this._regions.toRegion(index);\n                    if (!filter || filter(current, level)) {\n                        result.push(current);\n                    }\n                    level++;\n                    index = current.parentIndex;\n                }\n            }\n            return result;\n        }\n        getRegionAtLine(lineNumber) {\n            if (this._regions) {\n                let index = this._regions.findRange(lineNumber);\n                if (index >= 0) {\n                    return this._regions.toRegion(index);\n                }\n            }\n            return null;\n        }\n        getRegionsInside(region, filter) {\n            let result = [];\n            let index = region ? region.regionIndex + 1 : 0;\n            let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;\n            if (filter && filter.length === 2) {\n                const levelStack = [];\n                for (let i = index, len = this._regions.length; i < len; i++) {\n                    let current = this._regions.toRegion(i);\n                    if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                        while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {\n                            levelStack.pop();\n                        }\n                        levelStack.push(current);\n                        if (filter(current, levelStack.length)) {\n                            result.push(current);\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            else {\n                for (let i = index, len = this._regions.length; i < len; i++) {\n                    let current = this._regions.toRegion(i);\n                    if (this._regions.getStartLineNumber(i) < endLineNumber) {\n                        if (!filter || filter(current)) {\n                            result.push(current);\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    exports.FoldingModel = FoldingModel;\n    /**\n     * Collapse or expand the regions at the given locations including all children.\n     * @param doCollapse Wheter to collase or expand\n     * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n     * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n     */\n    function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {\n        let toToggle = [];\n        if (lineNumbers && lineNumbers.length > 0) {\n            for (let lineNumber of lineNumbers) {\n                let region = foldingModel.getRegionAtLine(lineNumber);\n                if (region) {\n                    if (region.isCollapsed !== doCollapse) {\n                        toToggle.push(region);\n                    }\n                    if (levels > 1) {\n                        let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n                        toToggle.push(...regionsInside);\n                    }\n                }\n            }\n        }\n        else {\n            let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);\n            toToggle.push(...regionsInside);\n        }\n        foldingModel.toggleCollapseState(toToggle);\n    }\n    exports.setCollapseStateLevelsDown = setCollapseStateLevelsDown;\n    /**\n     * Collapse or expand the regions at the given locations including all parents.\n     * @param doCollapse Wheter to collase or expand\n     * @param levels The number of levels. Use 1 to only impact the regions at the location, use Number.MAX_VALUE for all levels.\n     * @param lineNumbers the location of the regions to collapse or expand, or if not set, all regions in the model.\n     */\n    function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {\n        let toToggle = [];\n        for (let lineNumber of lineNumbers) {\n            let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);\n            toToggle.push(...regions);\n        }\n        foldingModel.toggleCollapseState(toToggle);\n    }\n    exports.setCollapseStateLevelsUp = setCollapseStateLevelsUp;\n    /**\n     * Folds or unfolds all regions that have a given level, except if they contain one of the blocked lines.\n     * @param foldLevel level. Level == 1 is the top level\n     * @param doCollapse Wheter to collase or expand\n    */\n    function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {\n        let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some(line => region.containsLine(line));\n        let toToggle = foldingModel.getRegionsInside(null, filter);\n        foldingModel.toggleCollapseState(toToggle);\n    }\n    exports.setCollapseStateAtLevel = setCollapseStateAtLevel;\n    /**\n     * Folds all regions for which the lines start with a given regex\n     * @param foldingModel the folding model\n     */\n    function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {\n        let editorModel = foldingModel.textModel;\n        let regions = foldingModel.regions;\n        let toToggle = [];\n        for (let i = regions.length - 1; i >= 0; i--) {\n            if (doCollapse !== regions.isCollapsed(i)) {\n                let startLineNumber = regions.getStartLineNumber(i);\n                if (regExp.test(editorModel.getLineContent(startLineNumber))) {\n                    toToggle.push(regions.toRegion(i));\n                }\n            }\n        }\n        foldingModel.toggleCollapseState(toToggle);\n    }\n    exports.setCollapseStateForMatchingLines = setCollapseStateForMatchingLines;\n    /**\n     * Folds all regions of the given type\n     * @param foldingModel the folding model\n     */\n    function setCollapseStateForType(foldingModel, type, doCollapse) {\n        let regions = foldingModel.regions;\n        let toToggle = [];\n        for (let i = regions.length - 1; i >= 0; i--) {\n            if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {\n                toToggle.push(regions.toRegion(i));\n            }\n        }\n        foldingModel.toggleCollapseState(toToggle);\n    }\n    exports.setCollapseStateForType = setCollapseStateForType;\n});\n",null]}