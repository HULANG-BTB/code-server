{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/cli/node/cli.contribution.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/cli/node/cli.contribution.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/path\", \"child_process\", \"vs/base/node/pfs\", \"vs/base/common/platform\", \"vs/base/common/async\", \"vs/base/common/actions\", \"vs/workbench/common/actions\", \"vs/platform/registry/common/platform\", \"vs/platform/actions/common/actions\", \"vs/platform/product/node/product\", \"vs/platform/notification/common/notification\", \"vs/platform/dialogs/common/dialogs\", \"vs/base/common/severity\", \"vs/platform/log/common/log\", \"vs/base/common/amd\"], function (require, exports, nls, path, cp, pfs, platform, async_1, actions_1, actions_2, platform_1, actions_3, product_1, notification_1, dialogs_1, severity_1, log_1, amd_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function ignore(code, value) {\n        return err => err.code === code ? Promise.resolve(value) : Promise.reject(err);\n    }\n    let _source = null;\n    function getSource() {\n        if (!_source) {\n            const root = amd_1.getPathFromAmdModule(require, '');\n            _source = path.resolve(root, '..', 'bin', 'code');\n        }\n        return _source;\n    }\n    function isAvailable() {\n        return Promise.resolve(pfs.exists(getSource()));\n    }\n    let InstallAction = class InstallAction extends actions_1.Action {\n        constructor(id, label, notificationService, dialogService, logService) {\n            super(id, label);\n            this.notificationService = notificationService;\n            this.dialogService = dialogService;\n            this.logService = logService;\n        }\n        get target() {\n            return `/usr/local/bin/${product_1.default.applicationName}`;\n        }\n        run() {\n            return isAvailable().then(isAvailable => {\n                if (!isAvailable) {\n                    const message = nls.localize('not available', \"This command is not available\");\n                    this.notificationService.info(message);\n                    return undefined;\n                }\n                return this.isInstalled()\n                    .then(isInstalled => {\n                    if (!isAvailable || isInstalled) {\n                        return Promise.resolve(null);\n                    }\n                    else {\n                        return pfs.unlink(this.target)\n                            .then(undefined, ignore('ENOENT', null))\n                            .then(() => pfs.symlink(getSource(), this.target))\n                            .then(undefined, err => {\n                            if (err.code === 'EACCES' || err.code === 'ENOENT') {\n                                return this.createBinFolderAndSymlinkAsAdmin();\n                            }\n                            return Promise.reject(err);\n                        });\n                    }\n                })\n                    .then(() => {\n                    this.logService.trace('cli#install', this.target);\n                    this.notificationService.info(nls.localize('successIn', \"Shell command '{0}' successfully installed in PATH.\", product_1.default.applicationName));\n                });\n            });\n        }\n        isInstalled() {\n            return pfs.lstat(this.target)\n                .then(stat => stat.isSymbolicLink())\n                .then(() => pfs.readlink(this.target))\n                .then(link => link === getSource())\n                .then(undefined, ignore('ENOENT', false));\n        }\n        createBinFolderAndSymlinkAsAdmin() {\n            return new Promise((resolve, reject) => {\n                const buttons = [nls.localize('ok', \"OK\"), nls.localize('cancel2', \"Cancel\")];\n                this.dialogService.show(severity_1.default.Info, nls.localize('warnEscalation', \"Code will now prompt with 'osascript' for Administrator privileges to install the shell command.\"), buttons, { cancelId: 1 }).then(choice => {\n                    switch (choice) {\n                        case 0 /* OK */:\n                            const command = 'osascript -e \"do shell script \\\\\"mkdir -p /usr/local/bin && ln -sf \\'' + getSource() + '\\' \\'' + this.target + '\\'\\\\\" with administrator privileges\"';\n                            async_1.nfcall(cp.exec, command, {})\n                                .then(undefined, _ => Promise.reject(new Error(nls.localize('cantCreateBinFolder', \"Unable to create '/usr/local/bin'.\"))))\n                                .then(resolve, reject);\n                            break;\n                        case 1 /* Cancel */:\n                            reject(new Error(nls.localize('aborted', \"Aborted\")));\n                            break;\n                    }\n                });\n            });\n        }\n    };\n    InstallAction.ID = 'workbench.action.installCommandLine';\n    InstallAction.LABEL = nls.localize('install', \"Install '{0}' command in PATH\", product_1.default.applicationName);\n    InstallAction = __decorate([\n        __param(2, notification_1.INotificationService),\n        __param(3, dialogs_1.IDialogService),\n        __param(4, log_1.ILogService)\n    ], InstallAction);\n    let UninstallAction = class UninstallAction extends actions_1.Action {\n        constructor(id, label, notificationService, logService, dialogService) {\n            super(id, label);\n            this.notificationService = notificationService;\n            this.logService = logService;\n            this.dialogService = dialogService;\n        }\n        get target() {\n            return `/usr/local/bin/${product_1.default.applicationName}`;\n        }\n        run() {\n            return isAvailable().then(isAvailable => {\n                if (!isAvailable) {\n                    const message = nls.localize('not available', \"This command is not available\");\n                    this.notificationService.info(message);\n                    return undefined;\n                }\n                const uninstall = () => {\n                    return pfs.unlink(this.target)\n                        .then(undefined, ignore('ENOENT', null));\n                };\n                return uninstall().then(undefined, err => {\n                    if (err.code === 'EACCES') {\n                        return this.deleteSymlinkAsAdmin();\n                    }\n                    return Promise.reject(err);\n                }).then(() => {\n                    this.logService.trace('cli#uninstall', this.target);\n                    this.notificationService.info(nls.localize('successFrom', \"Shell command '{0}' successfully uninstalled from PATH.\", product_1.default.applicationName));\n                });\n            });\n        }\n        deleteSymlinkAsAdmin() {\n            return new Promise((resolve, reject) => {\n                const buttons = [nls.localize('ok', \"OK\"), nls.localize('cancel2', \"Cancel\")];\n                this.dialogService.show(severity_1.default.Info, nls.localize('warnEscalationUninstall', \"Code will now prompt with 'osascript' for Administrator privileges to uninstall the shell command.\"), buttons, { cancelId: 1 }).then(choice => {\n                    switch (choice) {\n                        case 0 /* OK */:\n                            const command = 'osascript -e \"do shell script \\\\\"rm \\'' + this.target + '\\'\\\\\" with administrator privileges\"';\n                            async_1.nfcall(cp.exec, command, {})\n                                .then(undefined, _ => Promise.reject(new Error(nls.localize('cantUninstall', \"Unable to uninstall the shell command '{0}'.\", this.target))))\n                                .then(resolve, reject);\n                            break;\n                        case 1 /* Cancel */:\n                            reject(new Error(nls.localize('aborted', \"Aborted\")));\n                            break;\n                    }\n                });\n            });\n        }\n    };\n    UninstallAction.ID = 'workbench.action.uninstallCommandLine';\n    UninstallAction.LABEL = nls.localize('uninstall', \"Uninstall '{0}' command from PATH\", product_1.default.applicationName);\n    UninstallAction = __decorate([\n        __param(2, notification_1.INotificationService),\n        __param(3, log_1.ILogService),\n        __param(4, dialogs_1.IDialogService)\n    ], UninstallAction);\n    if (platform.isMacintosh) {\n        const category = nls.localize('shellCommand', \"Shell Command\");\n        const workbenchActionsRegistry = platform_1.Registry.as(actions_2.Extensions.WorkbenchActions);\n        workbenchActionsRegistry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(InstallAction, InstallAction.ID, InstallAction.LABEL), 'Shell Command: Install \\'code\\' command in PATH', category);\n        workbenchActionsRegistry.registerWorkbenchAction(new actions_3.SyncActionDescriptor(UninstallAction, UninstallAction.ID, UninstallAction.LABEL), 'Shell Command: Uninstall \\'code\\' command from PATH', category);\n    }\n});\n",null]}