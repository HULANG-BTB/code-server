{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/node/diskFileSystemProvider.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files2/node/diskFileSystemProvider.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"fs\", \"os\", \"util\", \"vs/base/common/lifecycle\", \"vs/platform/files/common/files\", \"vs/base/common/event\", \"vs/base/common/platform\", \"vs/base/node/pfs\", \"vs/base/common/path\", \"vs/base/common/resources\", \"vs/base/common/extpath\", \"vs/base/common/async\", \"vs/nls\"], function (require, exports, fs_1, os_1, util_1, lifecycle_1, files_1, event_1, platform_1, pfs_1, path_1, resources_1, extpath_1, async_1, nls_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class DiskFileSystemProvider extends lifecycle_1.Disposable {\n        constructor(logService) {\n            super();\n            this.logService = logService;\n            //#region File Capabilities\n            this.onDidChangeCapabilities = event_1.Event.None;\n            //#endregion\n            //#region File Watching\n            this._onDidChangeFile = this._register(new event_1.Emitter());\n        }\n        get capabilities() {\n            if (!this._capabilities) {\n                this._capabilities =\n                    files_1.FileSystemProviderCapabilities.FileReadWrite |\n                        files_1.FileSystemProviderCapabilities.FileOpenReadWriteClose |\n                        files_1.FileSystemProviderCapabilities.FileFolderCopy;\n                if (platform_1.isLinux) {\n                    this._capabilities |= files_1.FileSystemProviderCapabilities.PathCaseSensitive;\n                }\n            }\n            return this._capabilities;\n        }\n        //#endregion\n        //#region File Metadata Resolving\n        stat(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const { stat, isSymbolicLink } = yield pfs_1.statLink(this.toFilePath(resource)); // cannot use fs.stat() here to support links properly\n                    let type;\n                    if (isSymbolicLink) {\n                        type = files_1.FileType.SymbolicLink | (stat.isDirectory() ? files_1.FileType.Directory : files_1.FileType.File);\n                    }\n                    else {\n                        type = stat.isFile() ? files_1.FileType.File : stat.isDirectory() ? files_1.FileType.Directory : files_1.FileType.Unknown;\n                    }\n                    return {\n                        type,\n                        ctime: stat.ctime.getTime(),\n                        mtime: stat.mtime.getTime(),\n                        size: stat.size\n                    };\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        readdir(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const children = yield pfs_1.readdir(this.toFilePath(resource));\n                    const result = [];\n                    yield Promise.all(children.map((child) => __awaiter(this, void 0, void 0, function* () {\n                        // const child = children[i];\n                        try {\n                            const stat = yield this.stat(resources_1.joinPath(resource, child));\n                            result.push([child, stat.type]);\n                        }\n                        catch (error) {\n                            this.logService.trace(error); // ignore errors for individual entries that can arise from permission denied\n                        }\n                    }))); // }\n                    return result;\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        //#endregion\n        //#region File Reading/Writing\n        readFile(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const filePath = this.toFilePath(resource);\n                    return yield pfs_1.readFile(filePath);\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        writeFile(resource, content, opts) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const filePath = this.toFilePath(resource);\n                    // Validate target\n                    const exists = yield pfs_1.fileExists(filePath);\n                    if (exists && !opts.overwrite) {\n                        throw files_1.createFileSystemProviderError(new Error(nls_1.localize('fileExists', \"File already exists\")), files_1.FileSystemProviderErrorCode.FileExists);\n                    }\n                    else if (!exists && !opts.create) {\n                        throw files_1.createFileSystemProviderError(new Error(nls_1.localize('fileNotExists', \"File does not exist\")), files_1.FileSystemProviderErrorCode.FileNotFound);\n                    }\n                    if (exists && platform_1.isWindows) {\n                        try {\n                            // On Windows and if the file exists, we use a different strategy of saving the file\n                            // by first truncating the file and then writing with r+ flag. This helps to save hidden files on Windows\n                            // (see https://github.com/Microsoft/vscode/issues/931) and prevent removing alternate data streams\n                            // (see https://github.com/Microsoft/vscode/issues/6363)\n                            yield pfs_1.truncate(filePath, 0);\n                            // We heard from one user that fs.truncate() succeeds, but the save fails (https://github.com/Microsoft/vscode/issues/61310)\n                            // In that case, the file is now entirely empty and the contents are gone. This can happen if an external file watcher is\n                            // installed that reacts on the truncate and keeps the file busy right after. Our workaround is to retry to save after a\n                            // short timeout, assuming that the file is free to write then.\n                            yield async_1.retry(() => pfs_1.writeFile(filePath, content, { flag: 'r+' }), 100 /* ms delay */, 3 /* retries */);\n                        }\n                        catch (error) {\n                            this.logService.trace(error);\n                            // we heard from users that fs.truncate() fails (https://github.com/Microsoft/vscode/issues/59561)\n                            // in that case we simply save the file without truncating first (same as macOS and Linux)\n                            yield pfs_1.writeFile(filePath, content);\n                        }\n                    }\n                    // macOS/Linux: just write directly\n                    else {\n                        yield pfs_1.writeFile(filePath, content);\n                    }\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        open(resource, opts) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const filePath = this.toFilePath(resource);\n                    let flags;\n                    if (opts.create) {\n                        // we take this as a hint that the file is opened for writing\n                        // as such we use 'w' to truncate an existing or create the\n                        // file otherwise. we do not allow reading.\n                        flags = 'w';\n                    }\n                    else {\n                        // otherwise we assume the file is opened for reading\n                        // as such we use 'r' to neither truncate, nor create\n                        // the file.\n                        flags = 'r';\n                    }\n                    return yield util_1.promisify(fs_1.open)(filePath, flags);\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        close(fd) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    return yield util_1.promisify(fs_1.close)(fd);\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        read(fd, pos, data, offset, length) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const result = yield util_1.promisify(fs_1.read)(fd, data, offset, length, pos);\n                    if (typeof result === 'number') {\n                        return result; // node.d.ts fail\n                    }\n                    return result.bytesRead;\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        write(fd, pos, data, offset, length) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const result = yield util_1.promisify(fs_1.write)(fd, data, offset, length, pos);\n                    if (typeof result === 'number') {\n                        return result; // node.d.ts fail\n                    }\n                    return result.bytesWritten;\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        //#endregion\n        //#region Move/Copy/Delete/Create Folder\n        mkdir(resource) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    yield util_1.promisify(fs_1.mkdir)(this.toFilePath(resource));\n                }\n                catch (error) {\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        delete(resource, opts) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const filePath = this.toFilePath(resource);\n                    yield this.doDelete(filePath, opts);\n                }\n                catch (error) {\n                    if (error.code === 'ENOENT') {\n                        return Promise.resolve(); // tolerate that the file might not exist\n                    }\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        doDelete(filePath, opts) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (opts.recursive) {\n                    yield pfs_1.del(filePath, os_1.tmpdir());\n                }\n                else {\n                    yield pfs_1.unlink(filePath);\n                }\n            });\n        }\n        rename(from, to, opts) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const fromFilePath = this.toFilePath(from);\n                const toFilePath = this.toFilePath(to);\n                try {\n                    // Ensure target does not exist\n                    yield this.validateTargetDeleted(from, to, opts && opts.overwrite);\n                    // Move\n                    yield pfs_1.move(fromFilePath, toFilePath);\n                }\n                catch (error) {\n                    // rewrite some typical errors that can happen especially around symlinks\n                    // to something the user can better understand\n                    if (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n                        error = new Error(nls_1.localize('moveError', \"Unable to move '{0}' into '{1}' ({2}).\", path_1.basename(fromFilePath), path_1.basename(path_1.dirname(toFilePath)), error.toString()));\n                    }\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        copy(from, to, opts) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const fromFilePath = this.toFilePath(from);\n                const toFilePath = this.toFilePath(to);\n                try {\n                    // Ensure target does not exist\n                    yield this.validateTargetDeleted(from, to, opts && opts.overwrite);\n                    // Copy\n                    yield pfs_1.copy(fromFilePath, toFilePath);\n                }\n                catch (error) {\n                    // rewrite some typical errors that can happen especially around symlinks\n                    // to something the user can better understand\n                    if (error.code === 'EINVAL' || error.code === 'EBUSY' || error.code === 'ENAMETOOLONG') {\n                        error = new Error(nls_1.localize('copyError', \"Unable to copy '{0}' into '{1}' ({2}).\", path_1.basename(fromFilePath), path_1.basename(path_1.dirname(toFilePath)), error.toString()));\n                    }\n                    throw this.toFileSystemProviderError(error);\n                }\n            });\n        }\n        validateTargetDeleted(from, to, overwrite) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const fromFilePath = this.toFilePath(from);\n                const toFilePath = this.toFilePath(to);\n                const isPathCaseSensitive = !!(this.capabilities & files_1.FileSystemProviderCapabilities.PathCaseSensitive);\n                const isCaseChange = isPathCaseSensitive ? false : extpath_1.isEqual(fromFilePath, toFilePath, true /* ignore case */);\n                // handle existing target (unless this is a case change)\n                if (!isCaseChange && (yield pfs_1.fileExists(toFilePath))) {\n                    if (!overwrite) {\n                        throw files_1.createFileSystemProviderError(new Error('File at target already exists'), files_1.FileSystemProviderErrorCode.FileExists);\n                    }\n                    yield this.delete(to, { recursive: true, useTrash: false });\n                }\n            });\n        }\n        get onDidChangeFile() { return this._onDidChangeFile.event; }\n        watch(resource, opts) {\n            throw new Error('Method not implemented.');\n        }\n        //#endregion\n        //#region Helpers\n        toFilePath(resource) {\n            return path_1.normalize(resource.fsPath);\n        }\n        toFileSystemProviderError(error) {\n            if (error instanceof files_1.FileSystemProviderError) {\n                return error; // avoid double conversion\n            }\n            let code;\n            switch (error.code) {\n                case 'ENOENT':\n                    code = files_1.FileSystemProviderErrorCode.FileNotFound;\n                    break;\n                case 'EISDIR':\n                    code = files_1.FileSystemProviderErrorCode.FileIsADirectory;\n                    break;\n                case 'EEXIST':\n                    code = files_1.FileSystemProviderErrorCode.FileExists;\n                    break;\n                case 'EPERM':\n                case 'EACCESS':\n                    code = files_1.FileSystemProviderErrorCode.NoPermissions;\n                    break;\n                default:\n                    code = files_1.FileSystemProviderErrorCode.Unknown;\n            }\n            return files_1.createFileSystemProviderError(error, code);\n        }\n    }\n    exports.DiskFileSystemProvider = DiskFileSystemProvider;\n});\n",null]}