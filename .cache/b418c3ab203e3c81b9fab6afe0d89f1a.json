{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/keybindingResolver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/keybinding/common/keybindingResolver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/platform/actions/common/actions\", \"vs/platform/commands/common/commands\", \"vs/platform/contextkey/common/contextkey\"], function (require, exports, arrays_1, actions_1, commands_1, contextkey_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class KeybindingResolver {\n        constructor(defaultKeybindings, overrides) {\n            this._defaultKeybindings = defaultKeybindings;\n            this._defaultBoundCommands = new Map();\n            for (let i = 0, len = defaultKeybindings.length; i < len; i++) {\n                const command = defaultKeybindings[i].command;\n                if (command) {\n                    this._defaultBoundCommands.set(command, true);\n                }\n            }\n            this._map = new Map();\n            this._lookupMap = new Map();\n            this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n            for (let i = 0, len = this._keybindings.length; i < len; i++) {\n                let k = this._keybindings[i];\n                if (k.keypressParts.length === 0) {\n                    // unbound\n                    continue;\n                }\n                // TODO@chords\n                this._addKeyPress(k.keypressParts[0], k);\n            }\n        }\n        static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n            if (defaultKb.command !== command) {\n                return false;\n            }\n            // TODO@chords\n            if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n                return false;\n            }\n            // TODO@chords\n            if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n                return false;\n            }\n            if (when) {\n                if (!defaultKb.when) {\n                    return false;\n                }\n                if (!when.equals(defaultKb.when)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\n         */\n        static combine(defaults, rawOverrides) {\n            defaults = defaults.slice(0);\n            let overrides = [];\n            for (const override of rawOverrides) {\n                if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n                    overrides.push(override);\n                    continue;\n                }\n                const command = override.command.substr(1);\n                // TODO@chords\n                const keypressFirstPart = override.keypressParts[0];\n                const keypressChordPart = override.keypressParts[1];\n                const when = override.when;\n                for (let j = defaults.length - 1; j >= 0; j--) {\n                    if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n                        defaults.splice(j, 1);\n                    }\n                }\n            }\n            return defaults.concat(overrides);\n        }\n        _addKeyPress(keypress, item) {\n            const conflicts = this._map.get(keypress);\n            if (typeof conflicts === 'undefined') {\n                // There is no conflict so far\n                this._map.set(keypress, [item]);\n                this._addToLookupMap(item);\n                return;\n            }\n            for (let i = conflicts.length - 1; i >= 0; i--) {\n                let conflict = conflicts[i];\n                if (conflict.command === item.command) {\n                    continue;\n                }\n                const conflictIsChord = (conflict.keypressParts.length > 1);\n                const itemIsChord = (item.keypressParts.length > 1);\n                // TODO@chords\n                if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n                    // The conflict only shares the chord start with this command\n                    continue;\n                }\n                if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n                    // `item` completely overwrites `conflict`\n                    // Remove conflict from the lookupMap\n                    this._removeFromLookupMap(conflict);\n                }\n            }\n            conflicts.push(item);\n            this._addToLookupMap(item);\n        }\n        _addToLookupMap(item) {\n            if (!item.command) {\n                return;\n            }\n            let arr = this._lookupMap.get(item.command);\n            if (typeof arr === 'undefined') {\n                arr = [item];\n                this._lookupMap.set(item.command, arr);\n            }\n            else {\n                arr.push(item);\n            }\n        }\n        _removeFromLookupMap(item) {\n            if (!item.command) {\n                return;\n            }\n            let arr = this._lookupMap.get(item.command);\n            if (typeof arr === 'undefined') {\n                return;\n            }\n            for (let i = 0, len = arr.length; i < len; i++) {\n                if (arr[i] === item) {\n                    arr.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        /**\n         * Returns true if it is provable `a` implies `b`.\n         * **Precondition**: Assumes `a` and `b` are normalized!\n         */\n        static whenIsEntirelyIncluded(a, b) {\n            if (!b) {\n                return true;\n            }\n            if (!a) {\n                return false;\n            }\n            const aExpressions = ((a instanceof contextkey_1.ContextKeyAndExpr) ? a.expr : [a]);\n            const bExpressions = ((b instanceof contextkey_1.ContextKeyAndExpr) ? b.expr : [b]);\n            let aIndex = 0;\n            for (const bExpr of bExpressions) {\n                let bExprMatched = false;\n                while (!bExprMatched && aIndex < aExpressions.length) {\n                    let aExpr = aExpressions[aIndex];\n                    if (aExpr.equals(bExpr)) {\n                        bExprMatched = true;\n                    }\n                    aIndex++;\n                }\n                if (!bExprMatched) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        getDefaultBoundCommands() {\n            return this._defaultBoundCommands;\n        }\n        getDefaultKeybindings() {\n            return this._defaultKeybindings;\n        }\n        getKeybindings() {\n            return this._keybindings;\n        }\n        lookupKeybindings(commandId) {\n            let items = this._lookupMap.get(commandId);\n            if (typeof items === 'undefined' || items.length === 0) {\n                return [];\n            }\n            // Reverse to get the most specific item first\n            let result = [], resultLen = 0;\n            for (let i = items.length - 1; i >= 0; i--) {\n                result[resultLen++] = items[i];\n            }\n            return result;\n        }\n        lookupPrimaryKeybinding(commandId) {\n            let items = this._lookupMap.get(commandId);\n            if (typeof items === 'undefined' || items.length === 0) {\n                return null;\n            }\n            return items[items.length - 1];\n        }\n        resolve(context, currentChord, keypress) {\n            let lookupMap = null;\n            if (currentChord !== null) {\n                // Fetch all chord bindings for `currentChord`\n                const candidates = this._map.get(currentChord);\n                if (typeof candidates === 'undefined') {\n                    // No chords starting with `currentChord`\n                    return null;\n                }\n                lookupMap = [];\n                for (let i = 0, len = candidates.length; i < len; i++) {\n                    let candidate = candidates[i];\n                    // TODO@chords\n                    if (candidate.keypressParts[1] === keypress) {\n                        lookupMap.push(candidate);\n                    }\n                }\n            }\n            else {\n                const candidates = this._map.get(keypress);\n                if (typeof candidates === 'undefined') {\n                    // No bindings with `keypress`\n                    return null;\n                }\n                lookupMap = candidates;\n            }\n            let result = this._findCommand(context, lookupMap);\n            if (!result) {\n                return null;\n            }\n            // TODO@chords\n            if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n                return {\n                    enterChord: true,\n                    commandId: null,\n                    commandArgs: null,\n                    bubble: false\n                };\n            }\n            return {\n                enterChord: false,\n                commandId: result.command,\n                commandArgs: result.commandArgs,\n                bubble: result.bubble\n            };\n        }\n        _findCommand(context, matches) {\n            for (let i = matches.length - 1; i >= 0; i--) {\n                let k = matches[i];\n                if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n                    continue;\n                }\n                return k;\n            }\n            return null;\n        }\n        static contextMatchesRules(context, rules) {\n            if (!rules) {\n                return true;\n            }\n            return rules.evaluate(context);\n        }\n        static getAllUnboundCommands(boundCommands) {\n            const unboundCommands = [];\n            const seenMap = new Map();\n            const addCommand = (id, includeCommandWithArgs) => {\n                if (seenMap.has(id)) {\n                    return;\n                }\n                seenMap.set(id, true);\n                if (id[0] === '_' || id.indexOf('vscode.') === 0) { // private command\n                    return;\n                }\n                if (boundCommands.get(id) === true) {\n                    return;\n                }\n                if (!includeCommandWithArgs) {\n                    const command = commands_1.CommandsRegistry.getCommand(id);\n                    if (command && typeof command.description === 'object'\n                        && arrays_1.isNonEmptyArray(command.description.args)) { // command with args\n                        return;\n                    }\n                }\n                unboundCommands.push(id);\n            };\n            for (const id in actions_1.MenuRegistry.getCommands()) {\n                addCommand(id, true);\n            }\n            for (const id in commands_1.CommandsRegistry.getCommands()) {\n                addCommand(id, false);\n            }\n            return unboundCommands;\n        }\n    }\n    exports.KeybindingResolver = KeybindingResolver;\n});\n",null]}