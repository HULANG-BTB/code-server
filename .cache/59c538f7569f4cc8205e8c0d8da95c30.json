{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/storage.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/storage.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/lifecycle\", \"vs/base/common/event\", \"vs/base/common/async\", \"vs/base/common/types\", \"vs/base/common/map\", \"vs/base/common/path\", \"vs/base/node/pfs\", \"vs/base/common/arrays\"], function (require, exports, lifecycle_1, event_1, async_1, types_1, map_1, path_1, pfs_1, arrays_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var StorageHint;\n    (function (StorageHint) {\n        // A hint to the storage that the storage\n        // does not exist on disk yet. This allows\n        // the storage library to improve startup\n        // time by not checking the storage for data.\n        StorageHint[StorageHint[\"STORAGE_DOES_NOT_EXIST\"] = 0] = \"STORAGE_DOES_NOT_EXIST\";\n    })(StorageHint = exports.StorageHint || (exports.StorageHint = {}));\n    var StorageState;\n    (function (StorageState) {\n        StorageState[StorageState[\"None\"] = 0] = \"None\";\n        StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n        StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n    })(StorageState || (StorageState = {}));\n    class Storage extends lifecycle_1.Disposable {\n        constructor(database, options = Object.create(null)) {\n            super();\n            this.database = database;\n            this.options = options;\n            this._onDidChangeStorage = this._register(new event_1.Emitter());\n            this.state = StorageState.None;\n            this.cache = new Map();\n            this.pendingDeletes = new Set();\n            this.pendingInserts = new Map();\n            this.flushDelayer = this._register(new async_1.ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n            this.registerListeners();\n        }\n        get onDidChangeStorage() { return this._onDidChangeStorage.event; }\n        registerListeners() {\n            this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n        }\n        onDidChangeItemsExternal(e) {\n            // items that change external require us to update our\n            // caches with the values. we just accept the value and\n            // emit an event if there is a change.\n            e.items.forEach((value, key) => this.accept(key, value));\n        }\n        accept(key, value) {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            let changed = false;\n            // Item got removed, check for deletion\n            if (types_1.isUndefinedOrNull(value)) {\n                changed = this.cache.delete(key);\n            }\n            // Item got updated, check for change\n            else {\n                const currentValue = this.cache.get(key);\n                if (currentValue !== value) {\n                    this.cache.set(key, value);\n                    changed = true;\n                }\n            }\n            // Signal to outside listeners\n            if (changed) {\n                this._onDidChangeStorage.fire(key);\n            }\n        }\n        get items() {\n            return this.cache;\n        }\n        get size() {\n            return this.cache.size;\n        }\n        init() {\n            if (this.state !== StorageState.None) {\n                return Promise.resolve(); // either closed or already initialized\n            }\n            this.state = StorageState.Initialized;\n            if (this.options.hint === StorageHint.STORAGE_DOES_NOT_EXIST) {\n                // return early if we know the storage file does not exist. this is a performance\n                // optimization to not load all items of the underlying storage if we know that\n                // there can be no items because the storage does not exist.\n                return Promise.resolve();\n            }\n            return this.database.getItems().then(items => {\n                this.cache = items;\n            });\n        }\n        get(key, fallbackValue) {\n            const value = this.cache.get(key);\n            if (types_1.isUndefinedOrNull(value)) {\n                return fallbackValue;\n            }\n            return value;\n        }\n        getBoolean(key, fallbackValue) {\n            const value = this.get(key);\n            if (types_1.isUndefinedOrNull(value)) {\n                return fallbackValue;\n            }\n            return value === 'true';\n        }\n        getNumber(key, fallbackValue) {\n            const value = this.get(key);\n            if (types_1.isUndefinedOrNull(value)) {\n                return fallbackValue;\n            }\n            return parseInt(value, 10);\n        }\n        set(key, value) {\n            if (this.state === StorageState.Closed) {\n                return Promise.resolve(); // Return early if we are already closed\n            }\n            // We remove the key for undefined/null values\n            if (types_1.isUndefinedOrNull(value)) {\n                return this.delete(key);\n            }\n            // Otherwise, convert to String and store\n            const valueStr = String(value);\n            // Return early if value already set\n            const currentValue = this.cache.get(key);\n            if (currentValue === valueStr) {\n                return Promise.resolve();\n            }\n            // Update in cache and pending\n            this.cache.set(key, valueStr);\n            this.pendingInserts.set(key, valueStr);\n            this.pendingDeletes.delete(key);\n            // Event\n            this._onDidChangeStorage.fire(key);\n            // Accumulate work by scheduling after timeout\n            return this.flushDelayer.trigger(() => this.flushPending());\n        }\n        delete(key) {\n            if (this.state === StorageState.Closed) {\n                return Promise.resolve(); // Return early if we are already closed\n            }\n            // Remove from cache and add to pending\n            const wasDeleted = this.cache.delete(key);\n            if (!wasDeleted) {\n                return Promise.resolve(); // Return early if value already deleted\n            }\n            if (!this.pendingDeletes.has(key)) {\n                this.pendingDeletes.add(key);\n            }\n            this.pendingInserts.delete(key);\n            // Event\n            this._onDidChangeStorage.fire(key);\n            // Accumulate work by scheduling after timeout\n            return this.flushDelayer.trigger(() => this.flushPending());\n        }\n        close() {\n            if (this.state === StorageState.Closed) {\n                return Promise.resolve(); // return if already closed\n            }\n            // Update state\n            this.state = StorageState.Closed;\n            // Trigger new flush to ensure data is persisted and then close\n            // even if there is an error flushing. We must always ensure\n            // the DB is closed to avoid corruption.\n            //\n            // Recovery: we pass our cache over as recovery option in case\n            // the DB is not healthy.\n            const onDone = () => this.database.close(() => this.cache);\n            return this.flushDelayer.trigger(() => this.flushPending(), 0 /* as soon as possible */).then(onDone, onDone);\n        }\n        flushPending() {\n            if (this.pendingInserts.size === 0 && this.pendingDeletes.size === 0) {\n                return Promise.resolve(); // return early if nothing to do\n            }\n            // Get pending data\n            const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n            // Reset pending data for next run\n            this.pendingDeletes = new Set();\n            this.pendingInserts = new Map();\n            // Update in storage\n            return this.database.updateItems(updateRequest);\n        }\n        checkIntegrity(full) {\n            return this.database.checkIntegrity(full);\n        }\n    }\n    Storage.DEFAULT_FLUSH_DELAY = 100;\n    exports.Storage = Storage;\n    class SQLiteStorageDatabase {\n        constructor(path, options = Object.create(null)) {\n            this.path = path;\n            this.name = path_1.basename(path);\n            this.logger = new SQLiteStorageDatabaseLogger(options.logging);\n            this.whenConnected = this.connect(path);\n        }\n        get onDidChangeItemsExternal() { return event_1.Event.None; } // since we are the only client, there can be no external changes\n        getItems() {\n            return this.whenConnected.then(connection => {\n                const items = new Map();\n                return this.all(connection, 'SELECT * FROM ItemTable').then(rows => {\n                    rows.forEach(row => items.set(row.key, row.value));\n                    if (this.logger.isTracing) {\n                        this.logger.trace(`[storage ${this.name}] getItems(): ${items.size} rows`);\n                    }\n                    return items;\n                });\n            });\n        }\n        updateItems(request) {\n            return this.whenConnected.then(connection => this.doUpdateItems(connection, request));\n        }\n        doUpdateItems(connection, request) {\n            let updateCount = 0;\n            if (request.insert) {\n                updateCount += request.insert.size;\n            }\n            if (request.delete) {\n                updateCount += request.delete.size;\n            }\n            if (updateCount === 0) {\n                return Promise.resolve();\n            }\n            if (this.logger.isTracing) {\n                this.logger.trace(`[storage ${this.name}] updateItems(): insert(${request.insert ? map_1.mapToString(request.insert) : '0'}), delete(${request.delete ? map_1.setToString(request.delete) : '0'})`);\n            }\n            return this.transaction(connection, () => {\n                // INSERT\n                if (request.insert && request.insert.size > 0) {\n                    const keysValuesChunks = [];\n                    keysValuesChunks.push([]); // seed with initial empty chunk\n                    // Split key/values into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n                    // so that we can efficiently run the INSERT with as many HOST parameters as possible\n                    let currentChunkIndex = 0;\n                    request.insert.forEach((value, key) => {\n                        let keyValueChunk = keysValuesChunks[currentChunkIndex];\n                        if (keyValueChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n                            currentChunkIndex++;\n                            keyValueChunk = [];\n                            keysValuesChunks.push(keyValueChunk);\n                        }\n                        keyValueChunk.push(key, value);\n                    });\n                    keysValuesChunks.forEach(keysValuesChunk => {\n                        this.prepare(connection, `INSERT INTO ItemTable VALUES ${arrays_1.fill(keysValuesChunk.length / 2, '(?,?)').join(',')}`, stmt => stmt.run(keysValuesChunk), () => {\n                            const keys = [];\n                            let length = 0;\n                            request.insert.forEach((value, key) => {\n                                keys.push(key);\n                                length += value.length;\n                            });\n                            return `Keys: ${keys.join(', ')} Length: ${length}`;\n                        });\n                    });\n                }\n                // DELETE\n                if (request.delete && request.delete.size) {\n                    const keysChunks = [];\n                    keysChunks.push([]); // seed with initial empty chunk\n                    // Split keys into chunks of SQLiteStorageDatabase.MAX_HOST_PARAMETERS\n                    // so that we can efficiently run the DELETE with as many HOST parameters\n                    // as possible\n                    let currentChunkIndex = 0;\n                    request.delete.forEach(key => {\n                        let keyChunk = keysChunks[currentChunkIndex];\n                        if (keyChunk.length > SQLiteStorageDatabase.MAX_HOST_PARAMETERS) {\n                            currentChunkIndex++;\n                            keyChunk = [];\n                            keysChunks.push(keyChunk);\n                        }\n                        keyChunk.push(key);\n                    });\n                    keysChunks.forEach(keysChunk => {\n                        this.prepare(connection, `DELETE FROM ItemTable WHERE key IN (${arrays_1.fill(keysChunk.length, '?').join(',')})`, stmt => stmt.run(keysChunk), () => {\n                            const keys = [];\n                            request.delete.forEach(key => {\n                                keys.push(key);\n                            });\n                            return `Keys: ${keys.join(', ')}`;\n                        });\n                    });\n                }\n            });\n        }\n        close(recovery) {\n            this.logger.trace(`[storage ${this.name}] close()`);\n            return this.whenConnected.then(connection => this.doClose(connection, recovery));\n        }\n        doClose(connection, recovery) {\n            return new Promise((resolve, reject) => {\n                connection.db.close(closeError => {\n                    if (closeError) {\n                        this.handleSQLiteError(connection, closeError, `[storage ${this.name}] close(): ${closeError}`);\n                    }\n                    // Return early if this storage was created only in-memory\n                    // e.g. when running tests we do not need to backup.\n                    if (this.path === SQLiteStorageDatabase.IN_MEMORY_PATH) {\n                        return resolve();\n                    }\n                    // If the DB closed successfully and we are not running in-memory\n                    // and the DB did not get errors during runtime, make a backup\n                    // of the DB so that we can use it as fallback in case the actual\n                    // DB becomes corrupt in the future.\n                    if (!connection.isErroneous && !connection.isInMemory) {\n                        return this.backup().then(resolve, error => {\n                            this.logger.error(`[storage ${this.name}] backup(): ${error}`);\n                            return resolve(); // ignore failing backup\n                        });\n                    }\n                    // Recovery: if we detected errors while using the DB or we are using\n                    // an inmemory DB (as a fallback to not being able to open the DB initially)\n                    // and we have a recovery function provided, we recreate the DB with this\n                    // data to recover all known data without loss if possible.\n                    if (typeof recovery === 'function') {\n                        // Delete the existing DB. If the path does not exist or fails to\n                        // be deleted, we do not try to recover anymore because we assume\n                        // that the path is no longer writeable for us.\n                        return pfs_1.unlink(this.path).then(() => {\n                            // Re-open the DB fresh\n                            return this.doConnect(this.path).then(recoveryConnection => {\n                                const closeRecoveryConnection = () => {\n                                    return this.doClose(recoveryConnection, undefined /* do not attempt to recover again */);\n                                };\n                                // Store items\n                                return this.doUpdateItems(recoveryConnection, { insert: recovery() }).then(() => closeRecoveryConnection(), error => {\n                                    // In case of an error updating items, still ensure to close the connection\n                                    // to prevent SQLITE_BUSY errors when the connection is restablished\n                                    closeRecoveryConnection();\n                                    return Promise.reject(error);\n                                });\n                            });\n                        }).then(resolve, reject);\n                    }\n                    // Finally without recovery we just reject\n                    return reject(closeError || new Error('Database has errors or is in-memory without recovery option'));\n                });\n            });\n        }\n        backup() {\n            const backupPath = this.toBackupPath(this.path);\n            return pfs_1.copy(this.path, backupPath);\n        }\n        toBackupPath(path) {\n            return `${path}.backup`;\n        }\n        checkIntegrity(full) {\n            this.logger.trace(`[storage ${this.name}] checkIntegrity(full: ${full})`);\n            return this.whenConnected.then(connection => {\n                return this.get(connection, full ? 'PRAGMA integrity_check' : 'PRAGMA quick_check').then(row => {\n                    const integrity = full ? row['integrity_check'] : row['quick_check'];\n                    if (connection.isErroneous) {\n                        return `${integrity} (last error: ${connection.lastError})`;\n                    }\n                    if (connection.isInMemory) {\n                        return `${integrity} (in-memory!)`;\n                    }\n                    return integrity;\n                });\n            });\n        }\n        connect(path, retryOnBusy = true) {\n            this.logger.trace(`[storage ${this.name}] open(${path}, retryOnBusy: ${retryOnBusy})`);\n            return this.doConnect(path).then(undefined, error => {\n                this.logger.error(`[storage ${this.name}] open(): Unable to open DB due to ${error}`);\n                // SQLITE_BUSY should only arise if another process is locking the same DB we want\n                // to open at that time. This typically never happens because a DB connection is\n                // limited per window. However, in the event of a window reload, it may be possible\n                // that the previous connection was not properly closed while the new connection is\n                // already established.\n                //\n                // In this case we simply wait for some time and retry once to establish the connection.\n                //\n                if (error.code === 'SQLITE_BUSY' && retryOnBusy) {\n                    return async_1.timeout(SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT).then(() => this.connect(path, false /* not another retry */));\n                }\n                // Otherwise, best we can do is to recover from a backup if that exists, as such we\n                // move the DB to a different filename and try to load from backup. If that fails,\n                // a new empty DB is being created automatically.\n                //\n                // The final fallback is to use an in-memory DB which should only happen if the target\n                // folder is really not writeable for us.\n                //\n                return pfs_1.unlink(path)\n                    .then(() => pfs_1.renameIgnoreError(this.toBackupPath(path), path))\n                    .then(() => this.doConnect(path))\n                    .then(undefined, error => {\n                    this.logger.error(`[storage ${this.name}] open(): Unable to use backup due to ${error}`);\n                    // In case of any error to open the DB, use an in-memory\n                    // DB so that we always have a valid DB to talk to.\n                    return this.doConnect(SQLiteStorageDatabase.IN_MEMORY_PATH);\n                });\n            });\n        }\n        handleSQLiteError(connection, error, msg) {\n            connection.isErroneous = true;\n            connection.lastError = msg;\n            this.logger.error(msg);\n        }\n        doConnect(path) {\n            return new Promise((resolve, reject) => {\n                new Promise((resolve_1, reject_1) => { require(['vscode-sqlite3'], resolve_1, reject_1); }).then(sqlite3 => {\n                    const connection = {\n                        db: new (this.logger.isTracing ? sqlite3.verbose().Database : sqlite3.Database)(path, error => {\n                            if (error) {\n                                return connection.db ? connection.db.close(() => reject(error)) : reject(error);\n                            }\n                            // The following exec() statement serves two purposes:\n                            // - create the DB if it does not exist yet\n                            // - validate that the DB is not corrupt (the open() call does not throw otherwise)\n                            return this.exec(connection, [\n                                'PRAGMA user_version = 1;',\n                                'CREATE TABLE IF NOT EXISTS ItemTable (key TEXT UNIQUE ON CONFLICT REPLACE, value BLOB)'\n                            ].join('')).then(() => {\n                                return resolve(connection);\n                            }, error => {\n                                return connection.db.close(() => reject(error));\n                            });\n                        }),\n                        isInMemory: path === SQLiteStorageDatabase.IN_MEMORY_PATH\n                    };\n                    // Errors\n                    connection.db.on('error', error => this.handleSQLiteError(connection, error, `[storage ${this.name}] Error (event): ${error}`));\n                    // Tracing\n                    if (this.logger.isTracing) {\n                        connection.db.on('trace', sql => this.logger.trace(`[storage ${this.name}] Trace (event): ${sql}`));\n                    }\n                }, reject);\n            });\n        }\n        exec(connection, sql) {\n            return new Promise((resolve, reject) => {\n                connection.db.exec(sql, error => {\n                    if (error) {\n                        this.handleSQLiteError(connection, error, `[storage ${this.name}] exec(): ${error}`);\n                        return reject(error);\n                    }\n                    return resolve();\n                });\n            });\n        }\n        get(connection, sql) {\n            return new Promise((resolve, reject) => {\n                connection.db.get(sql, (error, row) => {\n                    if (error) {\n                        this.handleSQLiteError(connection, error, `[storage ${this.name}] get(): ${error}`);\n                        return reject(error);\n                    }\n                    return resolve(row);\n                });\n            });\n        }\n        all(connection, sql) {\n            return new Promise((resolve, reject) => {\n                connection.db.all(sql, (error, rows) => {\n                    if (error) {\n                        this.handleSQLiteError(connection, error, `[storage ${this.name}] all(): ${error}`);\n                        return reject(error);\n                    }\n                    return resolve(rows);\n                });\n            });\n        }\n        transaction(connection, transactions) {\n            return new Promise((resolve, reject) => {\n                connection.db.serialize(() => {\n                    connection.db.run('BEGIN TRANSACTION');\n                    transactions();\n                    connection.db.run('END TRANSACTION', error => {\n                        if (error) {\n                            this.handleSQLiteError(connection, error, `[storage ${this.name}] transaction(): ${error}`);\n                            return reject(error);\n                        }\n                        return resolve();\n                    });\n                });\n            });\n        }\n        prepare(connection, sql, runCallback, errorDetails) {\n            const stmt = connection.db.prepare(sql);\n            const statementErrorListener = (error) => {\n                this.handleSQLiteError(connection, error, `[storage ${this.name}] prepare(): ${error} (${sql}). Details: ${errorDetails()}`);\n            };\n            stmt.on('error', statementErrorListener);\n            runCallback(stmt);\n            stmt.finalize(error => {\n                if (error) {\n                    statementErrorListener(error);\n                }\n                stmt.removeListener('error', statementErrorListener);\n            });\n        }\n    }\n    SQLiteStorageDatabase.IN_MEMORY_PATH = ':memory:';\n    SQLiteStorageDatabase.BUSY_OPEN_TIMEOUT = 2000; // timeout in ms to retry when opening DB fails with SQLITE_BUSY\n    SQLiteStorageDatabase.MAX_HOST_PARAMETERS = 256; // maximum number of parameters within a statement\n    exports.SQLiteStorageDatabase = SQLiteStorageDatabase;\n    class SQLiteStorageDatabaseLogger {\n        constructor(options) {\n            if (options && typeof options.logTrace === 'function') {\n                this.logTrace = options.logTrace;\n            }\n            if (options && typeof options.logError === 'function') {\n                this.logError = options.logError;\n            }\n        }\n        get isTracing() {\n            return !!this.logTrace;\n        }\n        trace(msg) {\n            if (this.logTrace) {\n                this.logTrace(msg);\n            }\n        }\n        error(error) {\n            if (this.logError) {\n                this.logError(error);\n            }\n        }\n    }\n    class InMemoryStorageDatabase {\n        constructor() {\n            this.onDidChangeItemsExternal = event_1.Event.None;\n            this.items = new Map();\n        }\n        getItems() {\n            return Promise.resolve(this.items);\n        }\n        updateItems(request) {\n            if (request.insert) {\n                request.insert.forEach((value, key) => this.items.set(key, value));\n            }\n            if (request.delete) {\n                request.delete.forEach(key => this.items.delete(key));\n            }\n            return Promise.resolve();\n        }\n        close() {\n            return Promise.resolve();\n        }\n        checkIntegrity(full) {\n            return Promise.resolve('ok');\n        }\n    }\n    exports.InMemoryStorageDatabase = InMemoryStorageDatabase;\n});\n",null]}