{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/streams.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/files/node/streams.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"stream\", \"vs/base/node/encoding\", \"vs/platform/files/common/files\", \"vs/base/common/errors\"], function (require, exports, stream_1, encoding_1, files_1, errors_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function createWritableOfProvider(provider, resource, opts) {\n        if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileOpenReadWriteClose) {\n            return createWritable(provider, resource, opts);\n        }\n        else if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileReadWrite) {\n            return createSimpleWritable(provider, resource, opts);\n        }\n        else {\n            throw errors_1.illegalArgument();\n        }\n    }\n    exports.createWritableOfProvider = createWritableOfProvider;\n    function createSimpleWritable(provider, resource, opts) {\n        return new class extends stream_1.Writable {\n            constructor(opts) {\n                super(opts);\n                this._chunks = [];\n            }\n            _write(chunk, encoding, callback) {\n                this._chunks.push(chunk);\n                callback(null);\n            }\n            end() {\n                // todo@joh - end might have another chunk...\n                provider.writeFile(resource, Buffer.concat(this._chunks), opts).then(_ => {\n                    super.end();\n                }, err => {\n                    this.emit('error', err);\n                });\n            }\n        };\n    }\n    function createWritable(provider, resource, opts) {\n        return new class extends stream_1.Writable {\n            constructor(opts) {\n                super(opts);\n                this._pos = 0;\n            }\n            _write(chunk, encoding, callback) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    try {\n                        if (typeof this._fd !== 'number') {\n                            this._fd = yield provider.open(resource, { create: true });\n                        }\n                        let bytesWritten = yield provider.write(this._fd, this._pos, chunk, 0, chunk.length);\n                        this._pos += bytesWritten;\n                        callback();\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                });\n            }\n            _final(callback) {\n                if (typeof this._fd !== 'number') {\n                    provider.open(resource, { create: true }).then(fd => provider.close(fd)).finally(callback);\n                }\n                else {\n                    provider.close(this._fd).finally(callback);\n                }\n            }\n        };\n    }\n    function createReadableOfProvider(provider, resource, position) {\n        if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileOpenReadWriteClose) {\n            return createReadable(provider, resource, position);\n        }\n        else if (provider.capabilities & files_1.FileSystemProviderCapabilities.FileReadWrite) {\n            return createSimpleReadable(provider, resource, position);\n        }\n        else {\n            throw errors_1.illegalArgument();\n        }\n    }\n    exports.createReadableOfProvider = createReadableOfProvider;\n    function createReadable(provider, resource, position) {\n        return new class extends stream_1.Readable {\n            constructor() {\n                super(...arguments);\n                this._pos = position;\n                this._reading = false;\n            }\n            _read(size = Math.pow(2, 10)) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (this._reading) {\n                        return;\n                    }\n                    this._reading = true;\n                    try {\n                        if (typeof this._fd !== 'number') {\n                            this._fd = yield provider.open(resource, { create: false });\n                        }\n                        while (this._reading) {\n                            let buffer = Buffer.allocUnsafe(size);\n                            let bytesRead = yield provider.read(this._fd, this._pos, buffer, 0, buffer.length);\n                            if (bytesRead === 0) {\n                                yield provider.close(this._fd);\n                                this._reading = false;\n                                this.push(null);\n                            }\n                            else {\n                                this._reading = this.push(buffer.slice(0, bytesRead));\n                                this._pos += bytesRead;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        //\n                        this.emit('error', err);\n                    }\n                });\n            }\n            _destroy(_err, callback) {\n                if (typeof this._fd === 'number') {\n                    provider.close(this._fd).then(callback, callback);\n                }\n            }\n        };\n    }\n    function createSimpleReadable(provider, resource, position) {\n        return new class extends stream_1.Readable {\n            _read(size) {\n                if (this._readOperation) {\n                    return;\n                }\n                this._readOperation = provider.readFile(resource).then(data => {\n                    this.push(data.slice(position));\n                    this.push(null);\n                }, err => {\n                    this.emit('error', err);\n                    this.push(null);\n                });\n            }\n        };\n    }\n    function createReadableOfSnapshot(snapshot) {\n        return new stream_1.Readable({\n            read: function () {\n                try {\n                    let chunk = null;\n                    let canPush = true;\n                    // Push all chunks as long as we can push and as long as\n                    // the underlying snapshot returns strings to us\n                    while (canPush && typeof (chunk = snapshot.read()) === 'string') {\n                        canPush = this.push(chunk);\n                    }\n                    // Signal EOS by pushing NULL\n                    if (typeof chunk !== 'string') {\n                        this.push(null);\n                    }\n                }\n                catch (error) {\n                    this.emit('error', error);\n                }\n            },\n            encoding: encoding_1.UTF8 // very important, so that strings are passed around and not buffers!\n        });\n    }\n    exports.createReadableOfSnapshot = createReadableOfSnapshot;\n});\n",null]}