{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/characterHardWrappingLineMapper.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/viewModel/characterHardWrappingLineMapper.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/config/editorOptions\", \"vs/editor/common/core/characterClassifier\", \"vs/editor/common/core/uint\", \"vs/editor/common/viewModel/prefixSumComputer\", \"vs/editor/common/viewModel/splitLinesCollection\"], function (require, exports, charCode_1, strings, editorOptions_1, characterClassifier_1, uint_1, prefixSumComputer_1, splitLinesCollection_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var CharacterClass;\n    (function (CharacterClass) {\n        CharacterClass[CharacterClass[\"NONE\"] = 0] = \"NONE\";\n        CharacterClass[CharacterClass[\"BREAK_BEFORE\"] = 1] = \"BREAK_BEFORE\";\n        CharacterClass[CharacterClass[\"BREAK_AFTER\"] = 2] = \"BREAK_AFTER\";\n        CharacterClass[CharacterClass[\"BREAK_OBTRUSIVE\"] = 3] = \"BREAK_OBTRUSIVE\";\n        CharacterClass[CharacterClass[\"BREAK_IDEOGRAPHIC\"] = 4] = \"BREAK_IDEOGRAPHIC\"; // for Han and Kana.\n    })(CharacterClass || (CharacterClass = {}));\n    class WrappingCharacterClassifier extends characterClassifier_1.CharacterClassifier {\n        constructor(BREAK_BEFORE, BREAK_AFTER, BREAK_OBTRUSIVE) {\n            super(CharacterClass.NONE);\n            for (let i = 0; i < BREAK_BEFORE.length; i++) {\n                this.set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);\n            }\n            for (let i = 0; i < BREAK_AFTER.length; i++) {\n                this.set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);\n            }\n            for (let i = 0; i < BREAK_OBTRUSIVE.length; i++) {\n                this.set(BREAK_OBTRUSIVE.charCodeAt(i), CharacterClass.BREAK_OBTRUSIVE);\n            }\n        }\n        get(charCode) {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return CharacterClass.BREAK_IDEOGRAPHIC;\n            }\n            return super.get(charCode);\n        }\n    }\n    class CharacterHardWrappingLineMapperFactory {\n        constructor(breakBeforeChars, breakAfterChars, breakObtrusiveChars) {\n            this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);\n        }\n        // TODO@Alex -> duplicated in lineCommentCommand\n        static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {\n            currentVisibleColumn = +currentVisibleColumn; //@perf\n            tabSize = +tabSize; //@perf\n            columnSize = +columnSize; //@perf\n            if (isTab) {\n                return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n            }\n            return currentVisibleColumn + columnSize;\n        }\n        createLineMapping(lineText, tabSize, breakingColumn, columnsForFullWidthChar, hardWrappingIndent) {\n            if (breakingColumn === -1) {\n                return null;\n            }\n            tabSize = +tabSize; //@perf\n            breakingColumn = +breakingColumn; //@perf\n            columnsForFullWidthChar = +columnsForFullWidthChar; //@perf\n            hardWrappingIndent = +hardWrappingIndent; //@perf\n            let wrappedTextIndentVisibleColumn = 0;\n            let wrappedTextIndent = '';\n            let firstNonWhitespaceIndex = -1;\n            if (hardWrappingIndent !== editorOptions_1.WrappingIndent.None) {\n                firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (firstNonWhitespaceIndex !== -1) {\n                    // Track existing indent\n                    wrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);\n                    for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                        wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === charCode_1.CharCode.Tab, 1);\n                    }\n                    // Increase indent of continuation lines, if desired\n                    let numberOfAdditionalTabs = 0;\n                    if (hardWrappingIndent === editorOptions_1.WrappingIndent.Indent) {\n                        numberOfAdditionalTabs = 1;\n                    }\n                    else if (hardWrappingIndent === editorOptions_1.WrappingIndent.DeepIndent) {\n                        numberOfAdditionalTabs = 2;\n                    }\n                    for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                        wrappedTextIndent += '\\t';\n                        wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);\n                    }\n                    // Force sticking to beginning of line if no character would fit except for the indentation\n                    if (wrappedTextIndentVisibleColumn + columnsForFullWidthChar > breakingColumn) {\n                        wrappedTextIndent = '';\n                        wrappedTextIndentVisibleColumn = 0;\n                    }\n                }\n            }\n            let classifier = this.classifier;\n            let lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened\n            let breakingLengths = []; // The length of each broken-up line text\n            let breakingLengthsIndex = 0; // The count of breaks already done\n            let visibleColumn = 0; // Visible column since the beginning of the current line\n            let niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)\n            let niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`\n            let obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)\n            let obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`\n            let len = lineText.length;\n            for (let i = 0; i < len; i++) {\n                // At this point, there is a certainty that the character before `i` fits on the current line,\n                // but the character at `i` might not fit\n                let charCode = lineText.charCodeAt(i);\n                let charCodeIsTab = (charCode === charCode_1.CharCode.Tab);\n                let charCodeClass = classifier.get(charCode);\n                if (charCodeClass === CharacterClass.BREAK_BEFORE) {\n                    // This is a character that indicates that a break should happen before it\n                    // Since we are certain the character before `i` fits, there's no extra checking needed,\n                    // just mark it as a nice breaking opportunity\n                    niceBreakOffset = i;\n                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                }\n                // CJK breaking : before break\n                if (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i > 0) {\n                    let prevCode = lineText.charCodeAt(i - 1);\n                    let prevClass = classifier.get(prevCode);\n                    if (prevClass !== CharacterClass.BREAK_BEFORE) { // Kinsoku Shori: Don't break after a leading character, like an open bracket\n                        niceBreakOffset = i;\n                        niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                    }\n                }\n                let charColumnSize = 1;\n                if (strings.isFullWidthCharacter(charCode)) {\n                    charColumnSize = columnsForFullWidthChar;\n                }\n                // Advance visibleColumn with character at `i`\n                visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);\n                if (visibleColumn > breakingColumn && i !== 0) {\n                    // We need to break at least before character at `i`:\n                    //  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))\n                    //  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))\n                    //  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))\n                    let breakBeforeOffset;\n                    let restoreVisibleColumnFrom;\n                    if (niceBreakOffset !== -1 && niceBreakVisibleColumn <= breakingColumn) {\n                        // We will break before `niceBreakLastOffset`\n                        breakBeforeOffset = niceBreakOffset;\n                        restoreVisibleColumnFrom = niceBreakVisibleColumn;\n                    }\n                    else if (obtrusiveBreakOffset !== -1 && obtrusiveBreakVisibleColumn <= breakingColumn) {\n                        // We will break before `obtrusiveBreakLastOffset`\n                        breakBeforeOffset = obtrusiveBreakOffset;\n                        restoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;\n                    }\n                    else {\n                        // We will break before `i`\n                        breakBeforeOffset = i;\n                        restoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;\n                    }\n                    // Break before character at `breakBeforeOffset`\n                    breakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;\n                    lastBreakingOffset = breakBeforeOffset;\n                    // Re-establish visibleColumn by taking character at `i` into account\n                    visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);\n                    // Reset markers\n                    niceBreakOffset = -1;\n                    niceBreakVisibleColumn = 0;\n                    obtrusiveBreakOffset = -1;\n                    obtrusiveBreakVisibleColumn = 0;\n                }\n                // At this point, there is a certainty that the character at `i` fits on the current line\n                if (niceBreakOffset !== -1) {\n                    // Advance niceBreakVisibleColumn\n                    niceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n                }\n                if (obtrusiveBreakOffset !== -1) {\n                    // Advance obtrusiveBreakVisibleColumn\n                    obtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n                }\n                if (charCodeClass === CharacterClass.BREAK_AFTER && (hardWrappingIndent === editorOptions_1.WrappingIndent.None || i >= firstNonWhitespaceIndex)) {\n                    // This is a character that indicates that a break should happen after it\n                    niceBreakOffset = i + 1;\n                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                }\n                // CJK breaking : after break\n                if (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i < len - 1) {\n                    let nextCode = lineText.charCodeAt(i + 1);\n                    let nextClass = classifier.get(nextCode);\n                    if (nextClass !== CharacterClass.BREAK_AFTER) { // Kinsoku Shori: Don't break before a trailing character, like a period\n                        niceBreakOffset = i + 1;\n                        niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                    }\n                }\n                if (charCodeClass === CharacterClass.BREAK_OBTRUSIVE) {\n                    // This is an obtrusive character that indicates that a break should happen after it\n                    obtrusiveBreakOffset = i + 1;\n                    obtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;\n                }\n            }\n            if (breakingLengthsIndex === 0) {\n                return null;\n            }\n            // Add last segment\n            breakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;\n            return new CharacterHardWrappingLineMapping(new prefixSumComputer_1.PrefixSumComputer(uint_1.toUint32Array(breakingLengths)), wrappedTextIndent);\n        }\n    }\n    exports.CharacterHardWrappingLineMapperFactory = CharacterHardWrappingLineMapperFactory;\n    class CharacterHardWrappingLineMapping {\n        constructor(prefixSums, wrappedLinesIndent) {\n            this._prefixSums = prefixSums;\n            this._wrappedLinesIndent = wrappedLinesIndent;\n        }\n        getOutputLineCount() {\n            return this._prefixSums.getCount();\n        }\n        getWrappedLinesIndent() {\n            return this._wrappedLinesIndent;\n        }\n        getInputOffsetOfOutputPosition(outputLineIndex, outputOffset) {\n            if (outputLineIndex === 0) {\n                return outputOffset;\n            }\n            else {\n                return this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;\n            }\n        }\n        getOutputPositionOfInputOffset(inputOffset) {\n            let r = this._prefixSums.getIndexOf(inputOffset);\n            return new splitLinesCollection_1.OutputPosition(r.index, r.remainder);\n        }\n    }\n    exports.CharacterHardWrappingLineMapping = CharacterHardWrappingLineMapping;\n});\n",null]}