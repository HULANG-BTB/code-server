{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codeAction/lightBulbWidget.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/contrib/codeAction/lightBulbWidget.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/browser/dom\", \"vs/base/browser/globalMouseMoveMonitor\", \"vs/base/common/cancellation\", \"vs/base/common/event\", \"vs/base/common/lifecycle\", \"vs/editor/browser/editorBrowser\", \"vs/editor/common/model/textModel\", \"./codeActionModel\", \"vs/css!./lightBulbWidget\"], function (require, exports, dom, globalMouseMoveMonitor_1, cancellation_1, event_1, lifecycle_1, editorBrowser_1, textModel_1, codeActionModel_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    class LightBulbWidget extends lifecycle_1.Disposable {\n        constructor(editor) {\n            super();\n            this._onClick = this._register(new event_1.Emitter());\n            this.onClick = this._onClick.event;\n            this._state = codeActionModel_1.CodeActionsState.Empty;\n            this._futureFixes = new cancellation_1.CancellationTokenSource();\n            this._domNode = document.createElement('div');\n            this._domNode.className = 'lightbulb-glyph';\n            this._editor = editor;\n            this._editor.addContentWidget(this);\n            this._register(this._editor.onDidChangeModel(_ => this._futureFixes.cancel()));\n            this._register(this._editor.onDidChangeModelLanguage(_ => this._futureFixes.cancel()));\n            this._register(this._editor.onDidChangeModelContent(_ => {\n                // cancel when the line in question has been removed\n                const editorModel = this._editor.getModel();\n                if (this._state.type !== codeActionModel_1.CodeActionsState.Type.Triggered || !editorModel || this._state.position.lineNumber >= editorModel.getLineCount()) {\n                    this._futureFixes.cancel();\n                }\n            }));\n            this._register(dom.addStandardDisposableListener(this._domNode, 'click', e => {\n                if (this._state.type !== codeActionModel_1.CodeActionsState.Type.Triggered) {\n                    return;\n                }\n                // Make sure that focus / cursor location is not lost when clicking widget icon\n                this._editor.focus();\n                // a bit of extra work to make sure the menu\n                // doesn't cover the line-text\n                const { top, height } = dom.getDomNodePagePosition(this._domNode);\n                const { lineHeight } = this._editor.getConfiguration();\n                let pad = Math.floor(lineHeight / 3);\n                if (this._position && this._position.position !== null && this._position.position.lineNumber < this._state.position.lineNumber) {\n                    pad += lineHeight;\n                }\n                this._onClick.fire({\n                    x: e.posx,\n                    y: top + height + pad,\n                    state: this._state\n                });\n            }));\n            this._register(dom.addDisposableListener(this._domNode, 'mouseenter', (e) => {\n                if ((e.buttons & 1) !== 1) {\n                    return;\n                }\n                // mouse enters lightbulb while the primary/left button\n                // is being pressed -> hide the lightbulb and block future\n                // showings until mouse is released\n                this.hide();\n                const monitor = new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor();\n                monitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, () => { }, () => {\n                    monitor.dispose();\n                });\n            }));\n            this._register(this._editor.onDidChangeConfiguration(e => {\n                // hide when told to do so\n                if (e.contribInfo && !this._editor.getConfiguration().contribInfo.lightbulbEnabled) {\n                    this.hide();\n                }\n            }));\n        }\n        dispose() {\n            super.dispose();\n            this._editor.removeContentWidget(this);\n        }\n        getId() {\n            return 'LightBulbWidget';\n        }\n        getDomNode() {\n            return this._domNode;\n        }\n        getPosition() {\n            return this._position;\n        }\n        tryShow(newState) {\n            if (newState.type !== codeActionModel_1.CodeActionsState.Type.Triggered || this._position && (!newState.position || this._position.position && this._position.position.lineNumber !== newState.position.lineNumber)) {\n                // hide when getting a 'hide'-request or when currently\n                // showing on another line\n                this.hide();\n            }\n            else if (this._futureFixes) {\n                // cancel pending show request in any case\n                this._futureFixes.cancel();\n            }\n            this._futureFixes = new cancellation_1.CancellationTokenSource();\n            const { token } = this._futureFixes;\n            this._state = newState;\n            if (this._state.type === codeActionModel_1.CodeActionsState.Empty.type) {\n                return;\n            }\n            const selection = this._state.rangeOrSelection;\n            this._state.actions.then(fixes => {\n                if (!token.isCancellationRequested && fixes.actions.length > 0 && selection) {\n                    this._show(fixes);\n                }\n                else {\n                    this.hide();\n                }\n            }).catch(() => {\n                this.hide();\n            });\n        }\n        set title(value) {\n            this._domNode.title = value;\n        }\n        get title() {\n            return this._domNode.title;\n        }\n        _show(codeActions) {\n            const config = this._editor.getConfiguration();\n            if (!config.contribInfo.lightbulbEnabled) {\n                return;\n            }\n            if (this._state.type !== codeActionModel_1.CodeActionsState.Type.Triggered) {\n                return;\n            }\n            const { lineNumber, column } = this._state.position;\n            const model = this._editor.getModel();\n            if (!model) {\n                return;\n            }\n            const tabSize = model.getOptions().tabSize;\n            const lineContent = model.getLineContent(lineNumber);\n            const indent = textModel_1.TextModel.computeIndentLevel(lineContent, tabSize);\n            const lineHasSpace = config.fontInfo.spaceWidth * indent > 22;\n            const isFolded = (lineNumber) => {\n                return lineNumber > 2 && this._editor.getTopForLineNumber(lineNumber) === this._editor.getTopForLineNumber(lineNumber - 1);\n            };\n            let effectiveLineNumber = lineNumber;\n            if (!lineHasSpace) {\n                if (lineNumber > 1 && !isFolded(lineNumber - 1)) {\n                    effectiveLineNumber -= 1;\n                }\n                else if (!isFolded(lineNumber + 1)) {\n                    effectiveLineNumber += 1;\n                }\n                else if (column * config.fontInfo.spaceWidth < 22) {\n                    // cannot show lightbulb above/below and showing\n                    // it inline would overlay the cursor...\n                    this.hide();\n                    return;\n                }\n            }\n            this._position = {\n                position: { lineNumber: effectiveLineNumber, column: 1 },\n                preference: LightBulbWidget._posPref\n            };\n            dom.toggleClass(this._domNode, 'autofixable', codeActions.hasAutoFix);\n            this._editor.layoutContentWidget(this);\n        }\n        hide() {\n            this._position = null;\n            this._state = codeActionModel_1.CodeActionsState.Empty;\n            this._futureFixes.cancel();\n            this._editor.layoutContentWidget(this);\n        }\n    }\n    LightBulbWidget._posPref = [editorBrowser_1.ContentWidgetPositionPreference.EXACT];\n    exports.LightBulbWidget = LightBulbWidget;\n});\n",null]}