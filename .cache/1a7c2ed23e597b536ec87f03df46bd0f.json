{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/remote/common/remoteAgentConnection.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/remote/common/remoteAgentConnection.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/parts/ipc/common/ipc.net\", \"vs/base/common/uuid\", \"vs/base/common/lifecycle\"], function (require, exports, ipc_net_1, uuid_1, lifecycle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ConnectionType;\n    (function (ConnectionType) {\n        ConnectionType[ConnectionType[\"Management\"] = 1] = \"Management\";\n        ConnectionType[ConnectionType[\"ExtensionHost\"] = 2] = \"ExtensionHost\";\n        ConnectionType[ConnectionType[\"Tunnel\"] = 3] = \"Tunnel\";\n    })(ConnectionType = exports.ConnectionType || (exports.ConnectionType = {}));\n    function connectToRemoteExtensionHostAgent(options, connectionType, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error(`Not implemented`);\n        });\n    }\n    function doConnectRemoteAgentManagement(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocol = yield connectToRemoteExtensionHostAgent(options, ConnectionType.Management, undefined);\n            return new Promise((c, e) => {\n                const registration = protocol.onControlMessage(raw => {\n                    registration.dispose();\n                    const msg = JSON.parse(raw.toString());\n                    const error = getErrorFromMessage(msg);\n                    if (error) {\n                        return e(error);\n                    }\n                    if (options.reconnectionProtocol) {\n                        options.reconnectionProtocol.endAcceptReconnection();\n                    }\n                    c({ protocol });\n                });\n            });\n        });\n    }\n    function doConnectRemoteAgentExtensionHost(options, startArguments) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocol = yield connectToRemoteExtensionHostAgent(options, ConnectionType.ExtensionHost, startArguments);\n            return new Promise((c, e) => {\n                const registration = protocol.onControlMessage(raw => {\n                    registration.dispose();\n                    const msg = JSON.parse(raw.toString());\n                    const error = getErrorFromMessage(msg);\n                    if (error) {\n                        return e(error);\n                    }\n                    const debugPort = msg && msg.debugPort;\n                    if (options.reconnectionProtocol) {\n                        options.reconnectionProtocol.endAcceptReconnection();\n                    }\n                    c({ protocol, debugPort });\n                });\n            });\n        });\n    }\n    function doConnectRemoteAgentTunnel(options, startParams) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocol = yield connectToRemoteExtensionHostAgent(options, ConnectionType.Tunnel, startParams);\n            return protocol;\n        });\n    }\n    function resolveConnectionOptions(options, reconnectionToken, reconnectionProtocol) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { host, port } = yield options.addressProvider.getAddress();\n            return {\n                isBuilt: options.isBuilt,\n                commit: options.commit,\n                host: host,\n                port: port,\n                reconnectionToken: reconnectionToken,\n                reconnectionProtocol: reconnectionProtocol,\n                webSocketFactory: options.webSocketFactory,\n            };\n        });\n    }\n    function connectRemoteAgentManagement(options, remoteAuthority, clientId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const reconnectionToken = uuid_1.generateUuid();\n            const simpleOptions = yield resolveConnectionOptions(options, reconnectionToken, null);\n            const { protocol } = yield doConnectRemoteAgentManagement(simpleOptions);\n            return new ManagementPersistentConnection(options, remoteAuthority, clientId, reconnectionToken, protocol);\n        });\n    }\n    exports.connectRemoteAgentManagement = connectRemoteAgentManagement;\n    function connectRemoteAgentExtensionHost(options, startArguments) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const reconnectionToken = uuid_1.generateUuid();\n            const simpleOptions = yield resolveConnectionOptions(options, reconnectionToken, null);\n            const { protocol, debugPort } = yield doConnectRemoteAgentExtensionHost(simpleOptions, startArguments);\n            return new ExtensionHostPersistentConnection(options, startArguments, reconnectionToken, protocol, debugPort);\n        });\n    }\n    exports.connectRemoteAgentExtensionHost = connectRemoteAgentExtensionHost;\n    function connectRemoteAgentTunnel(options, tunnelRemotePort) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const simpleOptions = yield resolveConnectionOptions(options, uuid_1.generateUuid(), null);\n            const protocol = yield doConnectRemoteAgentTunnel(simpleOptions, { port: tunnelRemotePort });\n            return protocol;\n        });\n    }\n    exports.connectRemoteAgentTunnel = connectRemoteAgentTunnel;\n    class PersistentConnection extends lifecycle_1.Disposable {\n        constructor(options, reconnectionToken, protocol) {\n            super();\n            this._options = options;\n            this.reconnectionToken = reconnectionToken;\n            this.protocol = protocol;\n        }\n    }\n    class ManagementPersistentConnection extends PersistentConnection {\n        constructor(options, remoteAuthority, clientId, reconnectionToken, protocol) {\n            super(options, reconnectionToken, protocol);\n            this.client = this._register(new ipc_net_1.Client(protocol, {\n                remoteAuthority: remoteAuthority,\n                clientId: clientId\n            }));\n        }\n        _reconnect(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield doConnectRemoteAgentManagement(options);\n            });\n        }\n    }\n    exports.ManagementPersistentConnection = ManagementPersistentConnection;\n    class ExtensionHostPersistentConnection extends PersistentConnection {\n        constructor(options, startArguments, reconnectionToken, protocol, debugPort) {\n            super(options, reconnectionToken, protocol);\n            this._startArguments = startArguments;\n            this.debugPort = debugPort;\n        }\n        _reconnect(options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield doConnectRemoteAgentExtensionHost(options, this._startArguments);\n            });\n        }\n    }\n    exports.ExtensionHostPersistentConnection = ExtensionHostPersistentConnection;\n    function getErrorFromMessage(msg) {\n        if (msg && msg.type === 'error') {\n            const error = new Error(`Connection error: ${msg.reason}`);\n            error.code = 'VSCODE_CONNECTION_ERROR';\n            return error;\n        }\n        return null;\n    }\n});\n",null]}