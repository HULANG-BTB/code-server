{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/cachedExtensionScanner.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/extensions/electron-browser/cachedExtensionScanner.ts","mtime":1555846338048},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"os\", \"vs/base/common/path\", \"vs/base/common/amd\", \"vs/base/common/errors\", \"vs/base/common/network\", \"vs/base/common/objects\", \"vs/base/common/platform\", \"vs/base/common/resources\", \"vs/base/common/uri\", \"vs/base/node/pfs\", \"vs/platform/environment/common/environment\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/platform/extensions/common/extensions\", \"vs/platform/product/node/package\", \"vs/platform/product/node/product\", \"vs/platform/notification/common/notification\", \"vs/platform/windows/common/windows\", \"vs/workbench/services/extensions/node/extensionPoints\"], function (require, exports, nls, os, path, amd_1, errors, network_1, objects, platform, resources_1, uri_1, pfs, environment_1, extensionManagement_1, extensions_1, package_1, product_1, notification_1, windows_1, extensionPoints_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    let _SystemExtensionsRoot = null;\n    function getSystemExtensionsRoot() {\n        return require('vs/../../../../packages/vscode/src/fill/paths').getBuiltInExtensionsDirectory();\n        if (!_SystemExtensionsRoot) {\n            _SystemExtensionsRoot = path.normalize(path.join(amd_1.getPathFromAmdModule(require, ''), '..', 'extensions'));\n        }\n        return _SystemExtensionsRoot;\n    }\n    let _ExtraDevSystemExtensionsRoot = null;\n    function getExtraDevSystemExtensionsRoot() {\n        if (!_ExtraDevSystemExtensionsRoot) {\n            _ExtraDevSystemExtensionsRoot = path.normalize(path.join(amd_1.getPathFromAmdModule(require, ''), '..', '.build', 'builtInExtensions'));\n        }\n        return _ExtraDevSystemExtensionsRoot;\n    }\n    let CachedExtensionScanner = class CachedExtensionScanner {\n        constructor(_notificationService, _environmentService, _extensionEnablementService, _windowService) {\n            this._notificationService = _notificationService;\n            this._environmentService = _environmentService;\n            this._extensionEnablementService = _extensionEnablementService;\n            this._windowService = _windowService;\n            this.scannedExtensions = new Promise((resolve, reject) => {\n                this._scannedExtensionsResolve = resolve;\n                this._scannedExtensionsReject = reject;\n            });\n            this.translationConfig = CachedExtensionScanner._readTranslationConfig();\n        }\n        scanSingleExtension(path, isBuiltin, log) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const translations = yield this.translationConfig;\n                const version = package_1.default.version;\n                const commit = product_1.default.commit;\n                const devMode = !!process.env['VSCODE_DEV'];\n                const locale = platform.language;\n                const input = new extensionPoints_1.ExtensionScannerInput(version, commit, locale, devMode, path, isBuiltin, false, translations);\n                return extensionPoints_1.ExtensionScanner.scanSingleExtension(input, log);\n            });\n        }\n        startScanningExtensions(log) {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const translations = yield this.translationConfig;\n                    const { system, user, development } = yield CachedExtensionScanner._scanInstalledExtensions(this._windowService, this._notificationService, this._environmentService, this._extensionEnablementService, log, translations);\n                    let result = new Map();\n                    system.forEach((systemExtension) => {\n                        const extensionKey = extensions_1.ExtensionIdentifier.toKey(systemExtension.identifier);\n                        const extension = result.get(extensionKey);\n                        if (extension) {\n                            log.warn(systemExtension.extensionLocation.fsPath, nls.localize('overwritingExtension', \"Overwriting extension {0} with {1}.\", extension.extensionLocation.fsPath, systemExtension.extensionLocation.fsPath));\n                        }\n                        result.set(extensionKey, systemExtension);\n                    });\n                    user.forEach((userExtension) => {\n                        const extensionKey = extensions_1.ExtensionIdentifier.toKey(userExtension.identifier);\n                        const extension = result.get(extensionKey);\n                        if (extension) {\n                            log.warn(userExtension.extensionLocation.fsPath, nls.localize('overwritingExtension', \"Overwriting extension {0} with {1}.\", extension.extensionLocation.fsPath, userExtension.extensionLocation.fsPath));\n                        }\n                        result.set(extensionKey, userExtension);\n                    });\n                    development.forEach(developedExtension => {\n                        log.info('', nls.localize('extensionUnderDevelopment', \"Loading development extension at {0}\", developedExtension.extensionLocation.fsPath));\n                        const extensionKey = extensions_1.ExtensionIdentifier.toKey(developedExtension.identifier);\n                        const extension = result.get(extensionKey);\n                        if (extension) {\n                            log.warn(developedExtension.extensionLocation.fsPath, nls.localize('overwritingExtension', \"Overwriting extension {0} with {1}.\", extension.extensionLocation.fsPath, developedExtension.extensionLocation.fsPath));\n                        }\n                        result.set(extensionKey, developedExtension);\n                    });\n                    let r = [];\n                    result.forEach((value) => r.push(value));\n                    this._scannedExtensionsResolve(r);\n                }\n                catch (err) {\n                    this._scannedExtensionsReject(err);\n                }\n            });\n        }\n        static _validateExtensionsCache(windowService, notificationService, environmentService, cacheKey, input) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const cacheFolder = path.join(environmentService.userDataPath, extensions_1.MANIFEST_CACHE_FOLDER);\n                const cacheFile = path.join(cacheFolder, cacheKey);\n                const expected = JSON.parse(JSON.stringify(yield extensionPoints_1.ExtensionScanner.scanExtensions(input, new NullLogger())));\n                const cacheContents = yield this._readExtensionCache(environmentService, cacheKey);\n                if (!cacheContents) {\n                    // Cache has been deleted by someone else, which is perfectly fine...\n                    return;\n                }\n                const actual = cacheContents.result;\n                if (objects.equals(expected, actual)) {\n                    // Cache is valid and running with it is perfectly fine...\n                    return;\n                }\n                try {\n                    yield pfs.del(cacheFile);\n                }\n                catch (err) {\n                    errors.onUnexpectedError(err);\n                    console.error(err);\n                }\n                notificationService.prompt(notification_1.Severity.Error, nls.localize('extensionCache.invalid', \"Extensions have been modified on disk. Please reload the window.\"), [{\n                        label: nls.localize('reloadWindow', \"Reload Window\"),\n                        run: () => windowService.reloadWindow()\n                    }]);\n            });\n        }\n        static _readExtensionCache(environmentService, cacheKey) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const cacheFolder = path.join(environmentService.userDataPath, extensions_1.MANIFEST_CACHE_FOLDER);\n                const cacheFile = path.join(cacheFolder, cacheKey);\n                try {\n                    const cacheRawContents = yield pfs.readFile(cacheFile, 'utf8');\n                    return JSON.parse(cacheRawContents);\n                }\n                catch (err) {\n                    // That's ok...\n                }\n                return null;\n            });\n        }\n        static _writeExtensionCache(environmentService, cacheKey, cacheContents) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const cacheFolder = path.join(environmentService.userDataPath, extensions_1.MANIFEST_CACHE_FOLDER);\n                const cacheFile = path.join(cacheFolder, cacheKey);\n                try {\n                    yield pfs.mkdirp(cacheFolder);\n                }\n                catch (err) {\n                    // That's ok...\n                }\n                try {\n                    yield pfs.writeFile(cacheFile, JSON.stringify(cacheContents));\n                }\n                catch (err) {\n                    // That's ok...\n                }\n            });\n        }\n        static _scanExtensionsWithCache(windowService, notificationService, environmentService, cacheKey, input, log) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (input.devMode) {\n                    // Do not cache when running out of sources...\n                    return extensionPoints_1.ExtensionScanner.scanExtensions(input, log);\n                }\n                try {\n                    const folderStat = yield pfs.stat(input.absoluteFolderPath);\n                    input.mtime = folderStat.mtime.getTime();\n                }\n                catch (err) {\n                    // That's ok...\n                }\n                const cacheContents = yield this._readExtensionCache(environmentService, cacheKey);\n                if (cacheContents && cacheContents.input && extensionPoints_1.ExtensionScannerInput.equals(cacheContents.input, input)) {\n                    // Validate the cache asynchronously after 5s\n                    setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                        try {\n                            yield this._validateExtensionsCache(windowService, notificationService, environmentService, cacheKey, input);\n                        }\n                        catch (err) {\n                            errors.onUnexpectedError(err);\n                        }\n                    }), 5000);\n                    return cacheContents.result.map((extensionDescription) => {\n                        // revive URI object\n                        extensionDescription.extensionLocation = uri_1.URI.revive(extensionDescription.extensionLocation);\n                        return extensionDescription;\n                    });\n                }\n                const counterLogger = new CounterLogger(log);\n                const result = yield extensionPoints_1.ExtensionScanner.scanExtensions(input, counterLogger);\n                if (counterLogger.errorCnt === 0) {\n                    // Nothing bad happened => cache the result\n                    const cacheContents = {\n                        input: input,\n                        result: result\n                    };\n                    yield this._writeExtensionCache(environmentService, cacheKey, cacheContents);\n                }\n                return result;\n            });\n        }\n        static _readTranslationConfig() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (platform.translationsConfigFile) {\n                    try {\n                        const content = yield pfs.readFile(platform.translationsConfigFile, 'utf8');\n                        return JSON.parse(content);\n                    }\n                    catch (err) {\n                        // no problemo\n                    }\n                }\n                return Object.create(null);\n            });\n        }\n        static _scanInstalledExtensions(windowService, notificationService, environmentService, extensionEnablementService, log, translations) {\n            const version = package_1.default.version;\n            const commit = product_1.default.commit;\n            const devMode = !!process.env['VSCODE_DEV'];\n            const locale = platform.language;\n            const builtinExtensions = this._scanExtensionsWithCache(windowService, notificationService, environmentService, extensions_1.BUILTIN_MANIFEST_CACHE_FILE, new extensionPoints_1.ExtensionScannerInput(version, commit, locale, devMode, getSystemExtensionsRoot(), true, false, translations), log);\n            let finalBuiltinExtensions = builtinExtensions;\n            if (devMode) {\n                const builtInExtensionsFilePath = path.normalize(path.join(amd_1.getPathFromAmdModule(require, ''), '..', 'build', 'builtInExtensions.json'));\n                const builtInExtensions = pfs.readFile(builtInExtensionsFilePath, 'utf8')\n                    .then(raw => JSON.parse(raw));\n                const controlFilePath = path.join(os.homedir(), '.vscode-oss-dev', 'extensions', 'control.json');\n                const controlFile = pfs.readFile(controlFilePath, 'utf8')\n                    .then(raw => JSON.parse(raw), () => ({}));\n                const input = new extensionPoints_1.ExtensionScannerInput(version, commit, locale, devMode, getExtraDevSystemExtensionsRoot(), true, false, translations);\n                const extraBuiltinExtensions = Promise.all([builtInExtensions, controlFile])\n                    .then(([builtInExtensions, control]) => new ExtraBuiltInExtensionResolver(builtInExtensions, control))\n                    .then(resolver => extensionPoints_1.ExtensionScanner.scanExtensions(input, log, resolver));\n                finalBuiltinExtensions = extensionPoints_1.ExtensionScanner.mergeBuiltinExtensions(builtinExtensions, extraBuiltinExtensions);\n            }\n            const userExtensions = (extensionEnablementService.allUserExtensionsDisabled || !environmentService.extensionsPath\n                ? Promise.resolve([])\n                : this._scanExtensionsWithCache(windowService, notificationService, environmentService, extensions_1.USER_MANIFEST_CACHE_FILE, new extensionPoints_1.ExtensionScannerInput(version, commit, locale, devMode, environmentService.extensionsPath, false, false, translations), log));\n            // Always load developed extensions while extensions development\n            let developedExtensions = Promise.resolve([]);\n            if (environmentService.isExtensionDevelopment && environmentService.extensionDevelopmentLocationURI && environmentService.extensionDevelopmentLocationURI.scheme === network_1.Schemas.file) {\n                developedExtensions = extensionPoints_1.ExtensionScanner.scanOneOrMultipleExtensions(new extensionPoints_1.ExtensionScannerInput(version, commit, locale, devMode, resources_1.originalFSPath(environmentService.extensionDevelopmentLocationURI), false, true, translations), log);\n            }\n            return Promise.all([finalBuiltinExtensions, userExtensions, developedExtensions]).then((extensionDescriptions) => {\n                const system = extensionDescriptions[0];\n                const user = extensionDescriptions[1];\n                const development = extensionDescriptions[2];\n                return { system, user, development };\n            }).then(undefined, err => {\n                log.error('', err);\n                return { system: [], user: [], development: [] };\n            });\n        }\n    };\n    CachedExtensionScanner = __decorate([\n        __param(0, notification_1.INotificationService),\n        __param(1, environment_1.IEnvironmentService),\n        __param(2, extensionManagement_1.IExtensionEnablementService),\n        __param(3, windows_1.IWindowService)\n    ], CachedExtensionScanner);\n    exports.CachedExtensionScanner = CachedExtensionScanner;\n    class ExtraBuiltInExtensionResolver {\n        constructor(builtInExtensions, control) {\n            this.builtInExtensions = builtInExtensions;\n            this.control = control;\n        }\n        resolveExtensions() {\n            const result = [];\n            for (const ext of this.builtInExtensions) {\n                const controlState = this.control[ext.name] || 'marketplace';\n                switch (controlState) {\n                    case 'disabled':\n                        break;\n                    case 'marketplace':\n                        result.push({ name: ext.name, path: path.join(getExtraDevSystemExtensionsRoot(), ext.name) });\n                        break;\n                    default:\n                        result.push({ name: ext.name, path: controlState });\n                        break;\n                }\n            }\n            return Promise.resolve(result);\n        }\n    }\n    class CounterLogger {\n        constructor(_actual) {\n            this._actual = _actual;\n            this.errorCnt = 0;\n            this.warnCnt = 0;\n            this.infoCnt = 0;\n        }\n        error(source, message) {\n            this._actual.error(source, message);\n        }\n        warn(source, message) {\n            this._actual.warn(source, message);\n        }\n        info(source, message) {\n            this._actual.info(source, message);\n        }\n    }\n    class NullLogger {\n        error(source, message) {\n        }\n        warn(source, message) {\n        }\n        info(source, message) {\n        }\n    }\n    class Logger {\n        constructor(messageHandler) {\n            this._messageHandler = messageHandler;\n        }\n        error(source, message) {\n            this._messageHandler(notification_1.Severity.Error, source, message);\n        }\n        warn(source, message) {\n            this._messageHandler(notification_1.Severity.Warning, source, message);\n        }\n        info(source, message) {\n            this._messageHandler(notification_1.Severity.Info, source, message);\n        }\n    }\n    exports.Logger = Logger;\n});\n",null]}