{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/platform/localizations/node/localizations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/platform/localizations/node/localizations.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/base/node/pfs\", \"crypto\", \"vs/platform/extensionManagement/common/extensionManagement\", \"vs/base/common/lifecycle\", \"vs/platform/environment/common/environment\", \"vs/base/common/async\", \"vs/platform/extensionManagement/common/extensionManagementUtil\", \"vs/platform/log/common/log\", \"vs/platform/localizations/common/localizations\", \"vs/platform/product/node/product\", \"vs/base/common/arrays\", \"vs/base/common/event\", \"vs/base/common/network\", \"vs/base/common/path\"], function (require, exports, pfs, crypto_1, extensionManagement_1, lifecycle_1, environment_1, async_1, extensionManagementUtil_1, log_1, localizations_1, product_1, arrays_1, event_1, network_1, path_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const systemLanguages = ['de', 'en', 'en-US', 'es', 'fr', 'it', 'ja', 'ko', 'ru', 'zh-CN', 'zh-TW'];\n    if (product_1.default.quality !== 'stable') {\n        systemLanguages.push('hu');\n    }\n    let LocalizationsService = class LocalizationsService extends lifecycle_1.Disposable {\n        constructor(extensionManagementService, environmentService, logService) {\n            super();\n            this.extensionManagementService = extensionManagementService;\n            this.logService = logService;\n            this._onDidLanguagesChange = this._register(new event_1.Emitter());\n            this.onDidLanguagesChange = this._onDidLanguagesChange.event;\n            this.cache = this._register(new LanguagePacksCache(environmentService, logService));\n            this._register(extensionManagementService.onDidInstallExtension(({ local }) => this.onDidInstallExtension(local)));\n            this._register(extensionManagementService.onDidUninstallExtension(({ identifier }) => this.onDidUninstallExtension(identifier)));\n        }\n        getLanguageIds(type) {\n            if (type === localizations_1.LanguageType.Core) {\n                return Promise.resolve([...systemLanguages]);\n            }\n            return this.cache.getLanguagePacks()\n                .then(languagePacks => {\n                const languages = type === localizations_1.LanguageType.Contributed ? Object.keys(languagePacks) : [...systemLanguages, ...Object.keys(languagePacks)];\n                return arrays_1.distinct(languages);\n            });\n        }\n        onDidInstallExtension(extension) {\n            if (extension && extension.manifest && extension.manifest.contributes && extension.manifest.contributes.localizations && extension.manifest.contributes.localizations.length) {\n                this.logService.debug('Adding language packs from the extension', extension.identifier.id);\n                this.update().then(changed => { if (changed) {\n                    this._onDidLanguagesChange.fire();\n                } });\n            }\n        }\n        onDidUninstallExtension(identifier) {\n            this.cache.getLanguagePacks()\n                .then(languagePacks => {\n                if (Object.keys(languagePacks).some(language => languagePacks[language] && languagePacks[language].extensions.some(e => extensionManagementUtil_1.areSameExtensions(e.extensionIdentifier, identifier)))) {\n                    this.logService.debug('Removing language packs from the extension', identifier.id);\n                    this.update().then(changed => { if (changed) {\n                        this._onDidLanguagesChange.fire();\n                    } });\n                }\n            });\n        }\n        update() {\n            return Promise.all([this.cache.getLanguagePacks(), this.extensionManagementService.getInstalled()])\n                .then(([current, installed]) => this.cache.update(installed)\n                .then(updated => !arrays_1.equals(Object.keys(current), Object.keys(updated))));\n        }\n    };\n    LocalizationsService = __decorate([\n        __param(0, extensionManagement_1.IExtensionManagementService),\n        __param(1, environment_1.IEnvironmentService),\n        __param(2, log_1.ILogService)\n    ], LocalizationsService);\n    exports.LocalizationsService = LocalizationsService;\n    let LanguagePacksCache = class LanguagePacksCache extends lifecycle_1.Disposable {\n        constructor(environmentService, logService) {\n            super();\n            this.logService = logService;\n            this.languagePacks = {};\n            this.languagePacksFilePath = path_1.join(environmentService.userDataPath, 'languagepacks.json');\n            this.languagePacksFileLimiter = new async_1.Queue();\n        }\n        getLanguagePacks() {\n            // if queue is not empty, fetch from disk\n            if (this.languagePacksFileLimiter.size || !this.initializedCache) {\n                return this.withLanguagePacks()\n                    .then(() => this.languagePacks);\n            }\n            return Promise.resolve(this.languagePacks);\n        }\n        update(extensions) {\n            return this.withLanguagePacks(languagePacks => {\n                Object.keys(languagePacks).forEach(language => delete languagePacks[language]);\n                this.createLanguagePacksFromExtensions(languagePacks, ...extensions);\n            }).then(() => this.languagePacks);\n        }\n        createLanguagePacksFromExtensions(languagePacks, ...extensions) {\n            for (const extension of extensions) {\n                if (extension && extension.manifest && extension.manifest.contributes && extension.manifest.contributes.localizations && extension.manifest.contributes.localizations.length) {\n                    this.createLanguagePacksFromExtension(languagePacks, extension);\n                }\n            }\n            Object.keys(languagePacks).forEach(languageId => this.updateHash(languagePacks[languageId]));\n        }\n        createLanguagePacksFromExtension(languagePacks, extension) {\n            const extensionIdentifier = extension.identifier;\n            const localizations = extension.manifest.contributes && extension.manifest.contributes.localizations ? extension.manifest.contributes.localizations : [];\n            for (const localizationContribution of localizations) {\n                if (extension.location.scheme === network_1.Schemas.file && localizations_1.isValidLocalization(localizationContribution)) {\n                    let languagePack = languagePacks[localizationContribution.languageId];\n                    if (!languagePack) {\n                        languagePack = { hash: '', extensions: [], translations: {} };\n                        languagePacks[localizationContribution.languageId] = languagePack;\n                    }\n                    let extensionInLanguagePack = languagePack.extensions.filter(e => extensionManagementUtil_1.areSameExtensions(e.extensionIdentifier, extensionIdentifier))[0];\n                    if (extensionInLanguagePack) {\n                        extensionInLanguagePack.version = extension.manifest.version;\n                    }\n                    else {\n                        languagePack.extensions.push({ extensionIdentifier, version: extension.manifest.version });\n                    }\n                    for (const translation of localizationContribution.translations) {\n                        languagePack.translations[translation.id] = path_1.join(extension.location.fsPath, translation.path);\n                    }\n                }\n            }\n        }\n        updateHash(languagePack) {\n            if (languagePack) {\n                const md5 = crypto_1.createHash('md5');\n                for (const extension of languagePack.extensions) {\n                    md5.update(extension.extensionIdentifier.uuid || extension.extensionIdentifier.id).update(extension.version);\n                }\n                languagePack.hash = md5.digest('hex');\n            }\n        }\n        withLanguagePacks(fn = () => null) {\n            return this.languagePacksFileLimiter.queue(() => {\n                let result = null;\n                return pfs.readFile(this.languagePacksFilePath, 'utf8')\n                    .then(undefined, err => err.code === 'ENOENT' ? Promise.resolve('{}') : Promise.reject(err))\n                    .then(raw => { try {\n                    return JSON.parse(raw);\n                }\n                catch (e) {\n                    return {};\n                } })\n                    .then(languagePacks => { result = fn(languagePacks); return languagePacks; })\n                    .then(languagePacks => {\n                    for (const language of Object.keys(languagePacks)) {\n                        if (!languagePacks[language]) {\n                            delete languagePacks[language];\n                        }\n                    }\n                    this.languagePacks = languagePacks;\n                    this.initializedCache = true;\n                    const raw = JSON.stringify(this.languagePacks);\n                    this.logService.debug('Writing language packs', raw);\n                    return pfs.writeFile(this.languagePacksFilePath, raw);\n                })\n                    .then(() => result, error => this.logService.error(error));\n            });\n        }\n    };\n    LanguagePacksCache = __decorate([\n        __param(0, environment_1.IEnvironmentService),\n        __param(1, log_1.ILogService)\n    ], LanguagePacksCache);\n});\n",null]}