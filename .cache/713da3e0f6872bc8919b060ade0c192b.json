{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/common/resources.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/common/resources.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar extpath = require(\"vs/base/common/extpath\");\nvar paths = require(\"vs/base/common/path\");\nvar uri_1 = require(\"vs/base/common/uri\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar network_1 = require(\"vs/base/common/network\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar glob_1 = require(\"vs/base/common/glob\");\nvar map_1 = require(\"vs/base/common/map\");\nfunction getComparisonKey(resource) {\n    return hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n}\nexports.getComparisonKey = getComparisonKey;\nfunction hasToIgnoreCase(resource) {\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n    return resource && resource.scheme === network_1.Schemas.file ? !platform_1.isLinux : true;\n}\nexports.hasToIgnoreCase = hasToIgnoreCase;\nfunction basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n}\nexports.basenameOrAuthority = basenameOrAuthority;\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nfunction isEqualOrParent(base, parentCandidate, ignoreCase) {\n    if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(base); }\n    if (base.scheme === parentCandidate.scheme) {\n        if (base.scheme === network_1.Schemas.file) {\n            return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n        }\n        if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n            return extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n        }\n    }\n    return false;\n}\nexports.isEqualOrParent = isEqualOrParent;\n/**\n * Tests wheter the two authorities are the same\n */\nfunction isEqualAuthority(a1, a2) {\n    return a1 === a2 || strings_1.equalsIgnoreCase(a1, a2);\n}\nexports.isEqualAuthority = isEqualAuthority;\nfunction isEqual(first, second, ignoreCase) {\n    if (ignoreCase === void 0) { ignoreCase = hasToIgnoreCase(first); }\n    if (first === second) {\n        return true;\n    }\n    if (!first || !second) {\n        return false;\n    }\n    if (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n        return false;\n    }\n    var p1 = first.path || '/', p2 = second.path || '/';\n    return p1 === p2 || ignoreCase && strings_1.equalsIgnoreCase(p1 || '/', p2 || '/');\n}\nexports.isEqual = isEqual;\nfunction basename(resource) {\n    return paths.posix.basename(resource.path);\n}\nexports.basename = basename;\nfunction extname(resource) {\n    return paths.posix.extname(resource.path);\n}\nexports.extname = extname;\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nfunction dirname(resource) {\n    if (resource.path.length === 0) {\n        return resource;\n    }\n    if (resource.scheme === network_1.Schemas.file) {\n        return uri_1.URI.file(paths.dirname(originalFSPath(resource)));\n    }\n    var dirname = paths.posix.dirname(resource.path);\n    if (resource.authority && dirname.length && dirname.charCodeAt(0) !== charCode_1.CharCode.Slash) {\n        console.error(\"dirname(\\\"\" + resource.toString + \")) resulted in a relative path\");\n        dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n    }\n    return resource.with({\n        path: dirname\n    });\n}\nexports.dirname = dirname;\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nfunction joinPath(resource) {\n    var pathFragment = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        pathFragment[_i - 1] = arguments[_i];\n    }\n    var _a;\n    var joinedPath;\n    if (resource.scheme === network_1.Schemas.file) {\n        joinedPath = uri_1.URI.file(paths.join.apply(paths, [originalFSPath(resource)].concat(pathFragment))).path;\n    }\n    else {\n        joinedPath = (_a = paths.posix).join.apply(_a, [resource.path || '/'].concat(pathFragment));\n    }\n    return resource.with({\n        path: joinedPath\n    });\n}\nexports.joinPath = joinPath;\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nfunction normalizePath(resource) {\n    if (!resource.path.length) {\n        return resource;\n    }\n    var normalizedPath;\n    if (resource.scheme === network_1.Schemas.file) {\n        normalizedPath = uri_1.URI.file(paths.normalize(originalFSPath(resource))).path;\n    }\n    else {\n        normalizedPath = paths.posix.normalize(resource.path);\n    }\n    return resource.with({\n        path: normalizedPath\n    });\n}\nexports.normalizePath = normalizePath;\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\nfunction originalFSPath(uri) {\n    var value;\n    var uriPath = uri.path;\n    if (uri.authority && uriPath.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = \"//\" + uri.authority + uriPath;\n    }\n    else if (platform_1.isWindows\n        && uriPath.charCodeAt(0) === charCode_1.CharCode.Slash\n        && extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n        && uriPath.charCodeAt(2) === charCode_1.CharCode.Colon) {\n        value = uriPath.substr(1);\n    }\n    else {\n        // other path\n        value = uriPath;\n    }\n    if (platform_1.isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\nexports.originalFSPath = originalFSPath;\n/**\n * Returns true if the URI path is absolute.\n */\nfunction isAbsolutePath(resource) {\n    return !!resource.path && resource.path[0] === '/';\n}\nexports.isAbsolutePath = isAbsolutePath;\n/**\n * Returns true if the URI path has a trailing path separator\n */\nfunction hasTrailingPathSeparator(resource) {\n    if (resource.scheme === network_1.Schemas.file) {\n        var fsp = originalFSPath(resource);\n        return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === paths.sep;\n    }\n    else {\n        var p = resource.path;\n        return p.length > 1 && p.charCodeAt(p.length - 1) === charCode_1.CharCode.Slash; // ignore the slash at offset 0\n    }\n}\nexports.hasTrailingPathSeparator = hasTrailingPathSeparator;\n/**\n * Removes a trailing path seperator, if theres one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nfunction removeTrailingPathSeparator(resource) {\n    if (hasTrailingPathSeparator(resource)) {\n        return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n    }\n    return resource;\n}\nexports.removeTrailingPathSeparator = removeTrailingPathSeparator;\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nfunction relativePath(from, to) {\n    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n        return undefined;\n    }\n    if (from.scheme === network_1.Schemas.file) {\n        var relativePath_1 = paths.relative(from.path, to.path);\n        return platform_1.isWindows ? extpath.toSlashes(relativePath_1) : relativePath_1;\n    }\n    return paths.posix.relative(from.path || '/', to.path || '/');\n}\nexports.relativePath = relativePath;\n/**\n * Resolves a absolute or relative path against a base URI.\n */\nfunction resolvePath(base, path) {\n    if (base.scheme === network_1.Schemas.file) {\n        var newURI = uri_1.URI.file(paths.resolve(originalFSPath(base), path));\n        return base.with({\n            authority: newURI.authority,\n            path: newURI.path\n        });\n    }\n    return base.with({\n        path: paths.posix.resolve(base.path, path)\n    });\n}\nexports.resolvePath = resolvePath;\nfunction distinctParents(items, resourceAccessor) {\n    var distinctParents = [];\n    var _loop_1 = function (i) {\n        var candidateResource = resourceAccessor(items[i]);\n        if (items.some(function (otherItem, index) {\n            if (index === i) {\n                return false;\n            }\n            return isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n        })) {\n            return \"continue\";\n        }\n        distinctParents.push(items[i]);\n    };\n    for (var i = 0; i < items.length; i++) {\n        _loop_1(i);\n    }\n    return distinctParents;\n}\nexports.distinctParents = distinctParents;\n/**\n * Data URI related helpers.\n */\nvar DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        var metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(function (property) {\n            var _a = property.split(':'), key = _a[0], value = _a[1];\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri = exports.DataUri || (exports.DataUri = {}));\nvar ResourceGlobMatcher = /** @class */ (function () {\n    function ResourceGlobMatcher(globalExpression, rootExpressions) {\n        this.expressionsByRoot = map_1.TernarySearchTree.forPaths();\n        this.globalExpression = glob_1.parse(globalExpression);\n        for (var _i = 0, rootExpressions_1 = rootExpressions; _i < rootExpressions_1.length; _i++) {\n            var expression = rootExpressions_1[_i];\n            this.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: glob_1.parse(expression.expression) });\n        }\n    }\n    ResourceGlobMatcher.prototype.matches = function (resource) {\n        var rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n        if (rootExpression) {\n            var path = relativePath(rootExpression.root, resource);\n            if (path && !!rootExpression.expression(path)) {\n                return true;\n            }\n        }\n        return !!this.globalExpression(resource.path);\n    };\n    return ResourceGlobMatcher;\n}());\nexports.ResourceGlobMatcher = ResourceGlobMatcher;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/common/resources.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/common/resources.ts"],"names":[],"mappings":";AAAA;;;gGAGgG;;AAEhG,gDAAkD;AAClD,2CAA6C;AAC7C,0CAAyC;AACzC,kDAA0D;AAC1D,kDAAiD;AACjD,oDAA6D;AAC7D,oDAAmD;AACnD,4CAA2E;AAC3E,0CAAuD;AAEvD,SAAgB,gBAAgB,CAAC,QAAa;IAC7C,OAAO,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;AAC5F,CAAC;AAFD,4CAEC;AAED,SAAgB,eAAe,CAAC,QAAyB;IACxD,iGAAiG;IACjG,6GAA6G;IAC7G,OAAO,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,kBAAO,CAAC,CAAC,CAAC,IAAI,CAAC;AACvE,CAAC;AAJD,0CAIC;AAED,SAAgB,mBAAmB,CAAC,QAAa;IAChD,OAAO,QAAQ,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC;AACjD,CAAC;AAFD,kDAEC;AAED;;;;GAIG;AACH,SAAgB,eAAe,CAAC,IAAS,EAAE,eAAoB,EAAE,UAAkC;IAAlC,2BAAA,EAAA,aAAa,eAAe,CAAC,IAAI,CAAC;IAClG,IAAI,IAAI,CAAC,MAAM,KAAK,eAAe,CAAC,MAAM,EAAE;QAC3C,IAAI,IAAI,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;YACjC,OAAO,OAAO,CAAC,eAAe,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,cAAc,CAAC,eAAe,CAAC,EAAE,UAAU,CAAC,CAAC;SAClG;QACD,IAAI,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,eAAe,CAAC,SAAS,CAAC,EAAE;YAChE,OAAO,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;SACjF;KACD;IACD,OAAO,KAAK,CAAC;AACd,CAAC;AAVD,0CAUC;AAED;;GAEG;AACH,SAAgB,gBAAgB,CAAC,EAAU,EAAE,EAAU;IACtD,OAAO,EAAE,KAAK,EAAE,IAAI,0BAAgB,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;AAC9C,CAAC;AAFD,4CAEC;AAED,SAAgB,OAAO,CAAC,KAAsB,EAAE,MAAuB,EAAE,UAAmC;IAAnC,2BAAA,EAAA,aAAa,eAAe,CAAC,KAAK,CAAC;IAC3G,IAAI,KAAK,KAAK,MAAM,EAAE;QACrB,OAAO,IAAI,CAAC;KACZ;IAED,IAAI,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE;QACtB,OAAO,KAAK,CAAC;KACb;IAED,IAAI,KAAK,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,EAAE;QAC3F,OAAO,KAAK,CAAC;KACb;IAED,IAAM,EAAE,GAAG,KAAK,CAAC,IAAI,IAAI,GAAG,EAAE,EAAE,GAAG,MAAM,CAAC,IAAI,IAAI,GAAG,CAAC;IACtD,OAAO,EAAE,KAAK,EAAE,IAAI,UAAU,IAAI,0BAAgB,CAAC,EAAE,IAAI,GAAG,EAAE,EAAE,IAAI,GAAG,CAAC,CAAC;AAC1E,CAAC;AAfD,0BAeC;AAED,SAAgB,QAAQ,CAAC,QAAa;IACrC,OAAO,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC5C,CAAC;AAFD,4BAEC;AAED,SAAgB,OAAO,CAAC,QAAa;IACpC,OAAO,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC3C,CAAC;AAFD,0BAEC;AAED;;;;;GAKG;AACH,SAAgB,OAAO,CAAC,QAAa;IACpC,IAAI,QAAQ,CAAC,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QAC/B,OAAO,QAAQ,CAAC;KAChB;IACD,IAAI,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;QACrC,OAAO,SAAG,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;KACzD;IACD,IAAI,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IACjD,IAAI,QAAQ,CAAC,SAAS,IAAI,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,mBAAQ,CAAC,KAAK,EAAE;QACrF,OAAO,CAAC,KAAK,CAAC,eAAY,QAAQ,CAAC,QAAQ,mCAAgC,CAAC,CAAC;QAC7E,OAAO,GAAG,GAAG,CAAC,CAAC,wIAAwI;KACvJ;IACD,OAAO,QAAQ,CAAC,IAAI,CAAC;QACpB,IAAI,EAAE,OAAO;KACb,CAAC,CAAC;AACJ,CAAC;AAfD,0BAeC;AAED;;;;;;GAMG;AACH,SAAgB,QAAQ,CAAC,QAAa;IAAE,sBAAyB;SAAzB,UAAyB,EAAzB,qBAAyB,EAAzB,IAAyB;QAAzB,qCAAyB;;;IAChE,IAAI,UAAkB,CAAC;IACvB,IAAI,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;QACrC,UAAU,GAAG,SAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,OAAV,KAAK,GAAM,cAAc,CAAC,QAAQ,CAAC,SAAK,YAAY,GAAE,CAAC,IAAI,CAAC;KAClF;SAAM;QACN,UAAU,GAAG,CAAA,KAAA,KAAK,CAAC,KAAK,CAAA,CAAC,IAAI,YAAC,QAAQ,CAAC,IAAI,IAAI,GAAG,SAAK,YAAY,EAAC,CAAC;KACrE;IACD,OAAO,QAAQ,CAAC,IAAI,CAAC;QACpB,IAAI,EAAE,UAAU;KAChB,CAAC,CAAC;AACJ,CAAC;AAVD,4BAUC;AAED;;;;;GAKG;AACH,SAAgB,aAAa,CAAC,QAAa;IAC1C,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE;QAC1B,OAAO,QAAQ,CAAC;KAChB;IACD,IAAI,cAAsB,CAAC;IAC3B,IAAI,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;QACrC,cAAc,GAAG,SAAG,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;KAC1E;SAAM;QACN,cAAc,GAAG,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KACtD;IACD,OAAO,QAAQ,CAAC,IAAI,CAAC;QACpB,IAAI,EAAE,cAAc;KACpB,CAAC,CAAC;AACJ,CAAC;AAbD,sCAaC;AAED;;;GAGG;AACH,SAAgB,cAAc,CAAC,GAAQ;IACtC,IAAI,KAAa,CAAC;IAClB,IAAM,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC;IACzB,IAAI,GAAG,CAAC,SAAS,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,KAAK,MAAM,EAAE;QACjE,qCAAqC;QACrC,KAAK,GAAG,OAAK,GAAG,CAAC,SAAS,GAAG,OAAS,CAAC;KACvC;SAAM,IACN,oBAAS;WACN,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,mBAAQ,CAAC,KAAK;WACxC,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;WACnD,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,mBAAQ,CAAC,KAAK,EAC1C;QACD,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;KAC1B;SAAM;QACN,aAAa;QACb,KAAK,GAAG,OAAO,CAAC;KAChB;IACD,IAAI,oBAAS,EAAE;QACd,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;KACnC;IACD,OAAO,KAAK,CAAC;AACd,CAAC;AArBD,wCAqBC;AAED;;GAEG;AACH,SAAgB,cAAc,CAAC,QAAa;IAC3C,OAAO,CAAC,CAAC,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;AACpD,CAAC;AAFD,wCAEC;AAED;;GAEG;AACH,SAAgB,wBAAwB,CAAC,QAAa;IACrD,IAAI,QAAQ,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;QACrC,IAAM,GAAG,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;QACrC,OAAO,GAAG,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,KAAK,CAAC,GAAG,CAAC;KACrF;SAAM;QACN,IAAM,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC;QACxB,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,mBAAQ,CAAC,KAAK,CAAC,CAAC,+BAA+B;KACrG;AACF,CAAC;AARD,4DAQC;AAGD;;;GAGG;AACH,SAAgB,2BAA2B,CAAC,QAAa;IACxD,IAAI,wBAAwB,CAAC,QAAQ,CAAC,EAAE;QACvC,OAAO,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;KAClF;IACD,OAAO,QAAQ,CAAC;AACjB,CAAC;AALD,kEAKC;AAGD;;;GAGG;AACH,SAAgB,YAAY,CAAC,IAAS,EAAE,EAAO;IAC9C,IAAI,IAAI,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,EAAE;QACjF,OAAO,SAAS,CAAC;KACjB;IACD,IAAI,IAAI,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;QACjC,IAAM,cAAY,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC;QACxD,OAAO,oBAAS,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,cAAY,CAAC,CAAC,CAAC,CAAC,cAAY,CAAC;KAClE;IACD,OAAO,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,IAAI,GAAG,EAAE,EAAE,CAAC,IAAI,IAAI,GAAG,CAAC,CAAC;AAC/D,CAAC;AATD,oCASC;AAED;;GAEG;AACH,SAAgB,WAAW,CAAC,IAAS,EAAE,IAAY;IAClD,IAAI,IAAI,CAAC,MAAM,KAAK,iBAAO,CAAC,IAAI,EAAE;QACjC,IAAM,MAAM,GAAG,SAAG,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;QACnE,OAAO,IAAI,CAAC,IAAI,CAAC;YAChB,SAAS,EAAE,MAAM,CAAC,SAAS;YAC3B,IAAI,EAAE,MAAM,CAAC,IAAI;SACjB,CAAC,CAAC;KACH;IACD,OAAO,IAAI,CAAC,IAAI,CAAC;QAChB,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;KAC1C,CAAC,CAAC;AACJ,CAAC;AAXD,kCAWC;AAED,SAAgB,eAAe,CAAI,KAAU,EAAE,gBAAkC;IAChF,IAAM,eAAe,GAAQ,EAAE,CAAC;4BACvB,CAAC;QACT,IAAM,iBAAiB,GAAG,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACrD,IAAI,KAAK,CAAC,IAAI,CAAC,UAAC,SAAS,EAAE,KAAK;YAC/B,IAAI,KAAK,KAAK,CAAC,EAAE;gBAChB,OAAO,KAAK,CAAC;aACb;YAED,OAAO,eAAe,CAAC,iBAAiB,EAAE,gBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC;QACxE,CAAC,CAAC,EAAE;;SAEH;QAED,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;;IAZhC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE;gBAA5B,CAAC;KAaT;IAED,OAAO,eAAe,CAAC;AACxB,CAAC;AAlBD,0CAkBC;AAED;;GAEG;AACH,IAAiB,OAAO,CA6BvB;AA7BD,WAAiB,OAAO;IAEV,uBAAe,GAAG,OAAO,CAAC;IAC1B,6BAAqB,GAAG,aAAa,CAAC;IACtC,sBAAc,GAAG,MAAM,CAAC;IACxB,sBAAc,GAAG,MAAM,CAAC;IAErC,SAAgB,aAAa,CAAC,OAAY;QACzC,IAAM,QAAQ,GAAG,IAAI,GAAG,EAAkB,CAAC;QAE3C,0GAA0G;QAC1G,yEAAyE;QACzE,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;QAClG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,UAAA,QAAQ;YACzB,IAAA,wBAAkC,EAAjC,WAAG,EAAE,aAA4B,CAAC;YACzC,IAAI,GAAG,IAAI,KAAK,EAAE;gBACjB,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;aACzB;QACF,CAAC,CAAC,CAAC;QAEH,0GAA0G;QAC1G,yBAAyB;QACzB,IAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;QAClE,IAAI,IAAI,EAAE;YACT,QAAQ,CAAC,GAAG,CAAC,QAAA,cAAc,EAAE,IAAI,CAAC,CAAC;SACnC;QAED,OAAO,QAAQ,CAAC;IACjB,CAAC;IArBe,qBAAa,gBAqB5B,CAAA;AACF,CAAC,EA7BgB,OAAO,GAAP,eAAO,KAAP,eAAO,QA6BvB;AAGD;IAKC,6BACC,gBAA6B,EAC7B,eAAyD;QAJzC,sBAAiB,GAAmE,uBAAiB,CAAC,QAAQ,EAA+C,CAAC;QAM9K,IAAI,CAAC,gBAAgB,GAAG,YAAK,CAAC,gBAAgB,CAAC,CAAC;QAChD,KAAyB,UAAe,EAAf,mCAAe,EAAf,6BAAe,EAAf,IAAe,EAAE;YAArC,IAAM,UAAU,wBAAA;YACpB,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,EAAE,UAAU,EAAE,YAAK,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;SAC5H;IACF,CAAC;IAED,qCAAO,GAAP,UAAQ,QAAa;QACpB,IAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC;QAC9E,IAAI,cAAc,EAAE;YACnB,IAAM,IAAI,GAAG,YAAY,CAAC,cAAc,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;YACzD,IAAI,IAAI,IAAI,CAAC,CAAC,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;gBAC9C,OAAO,IAAI,CAAC;aACZ;SACD;QACD,OAAO,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;IAC/C,CAAC;IACF,0BAAC;AAAD,CAAC,AAzBD,IAyBC;AAzBY,kDAAmB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as extpath from 'vs/base/common/extpath';\nimport * as paths from 'vs/base/common/path';\nimport { URI } from 'vs/base/common/uri';\nimport { equalsIgnoreCase } from 'vs/base/common/strings';\nimport { Schemas } from 'vs/base/common/network';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { ParsedExpression, IExpression, parse } from 'vs/base/common/glob';\nimport { TernarySearchTree } from 'vs/base/common/map';\n\nexport function getComparisonKey(resource: URI): string {\n\treturn hasToIgnoreCase(resource) ? resource.toString().toLowerCase() : resource.toString();\n}\n\nexport function hasToIgnoreCase(resource: URI | undefined): boolean {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn resource && resource.scheme === Schemas.file ? !isLinux : true;\n}\n\nexport function basenameOrAuthority(resource: URI): string {\n\treturn basename(resource) || resource.authority;\n}\n\n/**\n * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n * @param base A uri which is \"longer\"\n * @param parentCandidate A uri which is \"shorter\" then `base`\n */\nexport function isEqualOrParent(base: URI, parentCandidate: URI, ignoreCase = hasToIgnoreCase(base)): boolean {\n\tif (base.scheme === parentCandidate.scheme) {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), ignoreCase);\n\t\t}\n\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, ignoreCase, '/');\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n * Tests wheter the two authorities are the same\n */\nexport function isEqualAuthority(a1: string, a2: string) {\n\treturn a1 === a2 || equalsIgnoreCase(a1, a2);\n}\n\nexport function isEqual(first: URI | undefined, second: URI | undefined, ignoreCase = hasToIgnoreCase(first)): boolean {\n\tif (first === second) {\n\t\treturn true;\n\t}\n\n\tif (!first || !second) {\n\t\treturn false;\n\t}\n\n\tif (first.scheme !== second.scheme || !isEqualAuthority(first.authority, second.authority)) {\n\t\treturn false;\n\t}\n\n\tconst p1 = first.path || '/', p2 = second.path || '/';\n\treturn p1 === p2 || ignoreCase && equalsIgnoreCase(p1 || '/', p2 || '/');\n}\n\nexport function basename(resource: URI): string {\n\treturn paths.posix.basename(resource.path);\n}\n\nexport function extname(resource: URI): string {\n\treturn paths.posix.extname(resource.path);\n}\n\n/**\n * Return a URI representing the directory of a URI path.\n *\n * @param resource The input URI.\n * @returns The URI representing the directory of the input URI.\n */\nexport function dirname(resource: URI): URI {\n\tif (resource.path.length === 0) {\n\t\treturn resource;\n\t}\n\tif (resource.scheme === Schemas.file) {\n\t\treturn URI.file(paths.dirname(originalFSPath(resource)));\n\t}\n\tlet dirname = paths.posix.dirname(resource.path);\n\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t}\n\treturn resource.with({\n\t\tpath: dirname\n\t});\n}\n\n/**\n * Join a URI path with path fragments and normalizes the resulting path.\n *\n * @param resource The input URI.\n * @param pathFragment The path fragment to add to the URI path.\n * @returns The resulting URI.\n */\nexport function joinPath(resource: URI, ...pathFragment: string[]): URI {\n\tlet joinedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tjoinedPath = URI.file(paths.join(originalFSPath(resource), ...pathFragment)).path;\n\t} else {\n\t\tjoinedPath = paths.posix.join(resource.path || '/', ...pathFragment);\n\t}\n\treturn resource.with({\n\t\tpath: joinedPath\n\t});\n}\n\n/**\n * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n *\n * @param resource The URI to normalize the path.\n * @returns The URI with the normalized path.\n */\nexport function normalizePath(resource: URI): URI {\n\tif (!resource.path.length) {\n\t\treturn resource;\n\t}\n\tlet normalizedPath: string;\n\tif (resource.scheme === Schemas.file) {\n\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t} else {\n\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t}\n\treturn resource.with({\n\t\tpath: normalizedPath\n\t});\n}\n\n/**\n * Returns the fsPath of an URI where the drive letter is not normalized.\n * See #56403.\n */\nexport function originalFSPath(uri: URI): string {\n\tlet value: string;\n\tconst uriPath = uri.path;\n\tif (uri.authority && uriPath.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uriPath}`;\n\t} else if (\n\t\tisWindows\n\t\t&& uriPath.charCodeAt(0) === CharCode.Slash\n\t\t&& extpath.isWindowsDriveLetter(uriPath.charCodeAt(1))\n\t\t&& uriPath.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tvalue = uriPath.substr(1);\n\t} else {\n\t\t// other path\n\t\tvalue = uriPath;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Returns true if the URI path is absolute.\n */\nexport function isAbsolutePath(resource: URI): boolean {\n\treturn !!resource.path && resource.path[0] === '/';\n}\n\n/**\n * Returns true if the URI path has a trailing path separator\n */\nexport function hasTrailingPathSeparator(resource: URI): boolean {\n\tif (resource.scheme === Schemas.file) {\n\t\tconst fsp = originalFSPath(resource);\n\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === paths.sep;\n\t} else {\n\t\tconst p = resource.path;\n\t\treturn p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash; // ignore the slash at offset 0\n\t}\n}\n\n\n/**\n * Removes a trailing path seperator, if theres one.\n * Important: Doesn't remove the first slash, it would make the URI invalid\n */\nexport function removeTrailingPathSeparator(resource: URI): URI {\n\tif (hasTrailingPathSeparator(resource)) {\n\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t}\n\treturn resource;\n}\n\n\n/**\n * Returns a relative path between two URIs. If the URIs don't have the same schema or authority, `undefined` is returned.\n * The returned relative path always uses forward slashes.\n */\nexport function relativePath(from: URI, to: URI): string | undefined {\n\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\treturn undefined;\n\t}\n\tif (from.scheme === Schemas.file) {\n\t\tconst relativePath = paths.relative(from.path, to.path);\n\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t}\n\treturn paths.posix.relative(from.path || '/', to.path || '/');\n}\n\n/**\n * Resolves a absolute or relative path against a base URI.\n */\nexport function resolvePath(base: URI, path: string): URI {\n\tif (base.scheme === Schemas.file) {\n\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\treturn base.with({\n\t\t\tauthority: newURI.authority,\n\t\t\tpath: newURI.path\n\t\t});\n\t}\n\treturn base.with({\n\t\tpath: paths.posix.resolve(base.path, path)\n\t});\n}\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\n\nexport class ResourceGlobMatcher {\n\n\tprivate readonly globalExpression: ParsedExpression;\n\tprivate readonly expressionsByRoot: TernarySearchTree<{ root: URI, expression: ParsedExpression }> = TernarySearchTree.forPaths<{ root: URI, expression: ParsedExpression }>();\n\n\tconstructor(\n\t\tglobalExpression: IExpression,\n\t\trootExpressions: { root: URI, expression: IExpression }[]\n\t) {\n\t\tthis.globalExpression = parse(globalExpression);\n\t\tfor (const expression of rootExpressions) {\n\t\t\tthis.expressionsByRoot.set(expression.root.toString(), { root: expression.root, expression: parse(expression.expression) });\n\t\t}\n\t}\n\n\tmatches(resource: URI): boolean {\n\t\tconst rootExpression = this.expressionsByRoot.findSubstr(resource.toString());\n\t\tif (rootExpression) {\n\t\t\tconst path = relativePath(rootExpression.root, resource);\n\t\t\tif (path && !!rootExpression.expression(path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn !!this.globalExpression(resource.path);\n\t}\n}\n"]}]}