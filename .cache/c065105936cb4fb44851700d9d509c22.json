{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/search/node/ripgrepTextSearchEngine.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"child_process\", \"events\", \"vs/base/common/path\", \"string_decoder\", \"vs/base/common/strings\", \"vs/base/common/uri\", \"vs/workbench/services/search/common/search\", \"vscode-ripgrep\", \"./ripgrepSearchUtils\", \"vs/base/common/arrays\", \"vs/base/common/glob\", \"vs/base/common/collections\"], function (require, exports, cp, events_1, path, string_decoder_1, strings_1, uri_1, search_1, vscode_ripgrep_1, ripgrepSearchUtils_1, arrays_1, glob_1, collections_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // If vscode-ripgrep is in an .asar file, then the binary is unpacked.\n    const rgDiskPath = vscode_ripgrep_1.rgPath.replace(/\\bnode_modules\\.asar\\b/, 'node_modules.asar.unpacked');\n    class RipgrepTextSearchEngine {\n        constructor(outputChannel) {\n            this.outputChannel = outputChannel;\n        }\n        provideTextSearchResults(query, options, progress, token) {\n            this.outputChannel.appendLine(`provideTextSearchResults ${query.pattern}, ${JSON.stringify(Object.assign({}, options, {\n                folder: options.folder.toString()\n            }))}`);\n            return new Promise((resolve, reject) => {\n                token.onCancellationRequested(() => cancel());\n                const rgArgs = getRgArgs(query, options);\n                const cwd = options.folder.fsPath;\n                const escapedArgs = rgArgs\n                    .map(arg => arg.match(/^-/) ? arg : `'${arg}'`)\n                    .join(' ');\n                this.outputChannel.appendLine(`rg ${escapedArgs}\\n - cwd: ${cwd}`);\n                let rgProc = cp.spawn(rgDiskPath, rgArgs, { cwd });\n                rgProc.on('error', e => {\n                    console.error(e);\n                    this.outputChannel.appendLine('Error: ' + (e && e.message));\n                    reject(search_1.serializeSearchError(new search_1.SearchError(e && e.message, search_1.SearchErrorCode.rgProcessError)));\n                });\n                let gotResult = false;\n                const ripgrepParser = new RipgrepParser(options.maxResults, cwd, options.previewOptions);\n                ripgrepParser.on('result', (match) => {\n                    gotResult = true;\n                    progress.report(match);\n                });\n                let isDone = false;\n                const cancel = () => {\n                    isDone = true;\n                    if (rgProc) {\n                        rgProc.kill();\n                    }\n                    if (ripgrepParser) {\n                        ripgrepParser.cancel();\n                    }\n                };\n                let limitHit = false;\n                ripgrepParser.on('hitLimit', () => {\n                    limitHit = true;\n                    cancel();\n                });\n                rgProc.stdout.on('data', data => {\n                    ripgrepParser.handleData(data);\n                });\n                let gotData = false;\n                rgProc.stdout.once('data', () => gotData = true);\n                let stderr = '';\n                rgProc.stderr.on('data', data => {\n                    const message = data.toString();\n                    this.outputChannel.appendLine(message);\n                    stderr += message;\n                });\n                rgProc.on('close', () => {\n                    this.outputChannel.appendLine(gotData ? 'Got data from stdout' : 'No data from stdout');\n                    this.outputChannel.appendLine(gotResult ? 'Got result from parser' : 'No result from parser');\n                    this.outputChannel.appendLine('');\n                    if (isDone) {\n                        resolve({ limitHit });\n                    }\n                    else {\n                        // Trigger last result\n                        ripgrepParser.flush();\n                        rgProc = null;\n                        let searchError;\n                        if (stderr && !gotData && (searchError = rgErrorMsgForDisplay(stderr))) {\n                            reject(search_1.serializeSearchError(new search_1.SearchError(searchError.message, searchError.code)));\n                        }\n                        else {\n                            resolve({ limitHit });\n                        }\n                    }\n                });\n            });\n        }\n    }\n    exports.RipgrepTextSearchEngine = RipgrepTextSearchEngine;\n    /**\n     * Read the first line of stderr and return an error for display or undefined, based on a whitelist.\n     * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be\n     * \"failed\" when a fatal error was produced.\n     */\n    function rgErrorMsgForDisplay(msg) {\n        const firstLine = msg.split('\\n')[0].trim();\n        if (strings_1.startsWith(firstLine, 'regex parse error')) {\n            return new search_1.SearchError('Regex parse error', search_1.SearchErrorCode.regexParseError);\n        }\n        const match = firstLine.match(/grep config error: unknown encoding: (.*)/);\n        if (match) {\n            return new search_1.SearchError(`Unknown encoding: ${match[1]}`, search_1.SearchErrorCode.unknownEncoding);\n        }\n        if (strings_1.startsWith(firstLine, 'error parsing glob')) {\n            // Uppercase first letter\n            return new search_1.SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), search_1.SearchErrorCode.globParseError);\n        }\n        if (strings_1.startsWith(firstLine, 'the literal')) {\n            // Uppercase first letter\n            return new search_1.SearchError(firstLine.charAt(0).toUpperCase() + firstLine.substr(1), search_1.SearchErrorCode.invalidLiteral);\n        }\n        if (strings_1.startsWith(firstLine, 'PCRE2: error compiling pattern')) {\n            return new search_1.SearchError(firstLine, search_1.SearchErrorCode.regexParseError);\n        }\n        return undefined;\n    }\n    exports.rgErrorMsgForDisplay = rgErrorMsgForDisplay;\n    class RipgrepParser extends events_1.EventEmitter {\n        constructor(maxResults, rootFolder, previewOptions) {\n            super();\n            this.maxResults = maxResults;\n            this.rootFolder = rootFolder;\n            this.previewOptions = previewOptions;\n            this.remainder = '';\n            this.isDone = false;\n            this.hitLimit = false;\n            this.numResults = 0;\n            this.stringDecoder = new string_decoder_1.StringDecoder();\n        }\n        cancel() {\n            this.isDone = true;\n        }\n        flush() {\n            this.handleDecodedData(this.stringDecoder.end());\n        }\n        on(event, listener) {\n            super.on(event, listener);\n            return this;\n        }\n        handleData(data) {\n            if (this.isDone) {\n                return;\n            }\n            const dataStr = typeof data === 'string' ? data : this.stringDecoder.write(data);\n            this.handleDecodedData(dataStr);\n        }\n        handleDecodedData(decodedData) {\n            // check for newline before appending to remainder\n            let newlineIdx = decodedData.indexOf('\\n');\n            // If the previous data chunk didn't end in a newline, prepend it to this chunk\n            const dataStr = this.remainder + decodedData;\n            if (newlineIdx >= 0) {\n                newlineIdx += this.remainder.length;\n            }\n            else {\n                // Shortcut\n                this.remainder = dataStr;\n                return;\n            }\n            let prevIdx = 0;\n            while (newlineIdx >= 0) {\n                this.handleLine(dataStr.substring(prevIdx, newlineIdx).trim());\n                prevIdx = newlineIdx + 1;\n                newlineIdx = dataStr.indexOf('\\n', prevIdx);\n            }\n            this.remainder = dataStr.substring(prevIdx).trim();\n        }\n        handleLine(outputLine) {\n            if (this.isDone || !outputLine) {\n                return;\n            }\n            let parsedLine;\n            try {\n                parsedLine = JSON.parse(outputLine);\n            }\n            catch (e) {\n                throw new Error(`malformed line from rg: ${outputLine}`);\n            }\n            if (parsedLine.type === 'match') {\n                const matchPath = bytesOrTextToString(parsedLine.data.path);\n                const uri = uri_1.URI.file(path.join(this.rootFolder, matchPath));\n                const result = this.createTextSearchMatch(parsedLine.data, uri);\n                this.onResult(result);\n                if (this.hitLimit) {\n                    this.cancel();\n                    this.emit('hitLimit');\n                }\n            }\n            else if (parsedLine.type === 'context') {\n                const contextPath = bytesOrTextToString(parsedLine.data.path);\n                const uri = uri_1.URI.file(path.join(this.rootFolder, contextPath));\n                const result = this.createTextSearchContext(parsedLine.data, uri);\n                result.forEach(r => this.onResult(r));\n            }\n        }\n        createTextSearchMatch(data, uri) {\n            const lineNumber = data.line_number - 1;\n            let isBOMStripped = false;\n            let fullText = bytesOrTextToString(data.lines);\n            if (lineNumber === 0 && strings_1.startsWithUTF8BOM(fullText)) {\n                isBOMStripped = true;\n                fullText = strings_1.stripUTF8BOM(fullText);\n            }\n            const fullTextBytes = Buffer.from(fullText);\n            let prevMatchEnd = 0;\n            let prevMatchEndCol = 0;\n            let prevMatchEndLine = lineNumber;\n            const ranges = arrays_1.coalesce(data.submatches.map((match, i) => {\n                if (this.hitLimit) {\n                    return null;\n                }\n                this.numResults++;\n                if (this.numResults >= this.maxResults) {\n                    // Finish the line, then report the result below\n                    this.hitLimit = true;\n                }\n                let matchText = bytesOrTextToString(match.match);\n                if (lineNumber === 0 && i === 0 && isBOMStripped) {\n                    matchText = strings_1.stripUTF8BOM(matchText);\n                    match.start = match.start <= 3 ? 0 : match.start - 3;\n                    match.end = match.end <= 3 ? 0 : match.end - 3;\n                }\n                const inBetweenChars = fullTextBytes.slice(prevMatchEnd, match.start).toString().length;\n                let startCol = prevMatchEndCol + inBetweenChars;\n                const stats = getNumLinesAndLastNewlineLength(matchText);\n                const startLineNumber = prevMatchEndLine;\n                const endLineNumber = stats.numLines + startLineNumber;\n                let endCol = stats.numLines > 0 ?\n                    stats.lastLineLength :\n                    stats.lastLineLength + startCol;\n                prevMatchEnd = match.end;\n                prevMatchEndCol = endCol;\n                prevMatchEndLine = endLineNumber;\n                return new ripgrepSearchUtils_1.Range(startLineNumber, startCol, endLineNumber, endCol);\n            }));\n            return ripgrepSearchUtils_1.createTextSearchResult(uri, fullText, ranges, this.previewOptions);\n        }\n        createTextSearchContext(data, uri) {\n            const text = bytesOrTextToString(data.lines);\n            const startLine = data.line_number;\n            return text\n                .replace(/\\r?\\n$/, '')\n                .split('\\n')\n                .map((line, i) => {\n                return {\n                    text: line,\n                    uri,\n                    lineNumber: startLine + i\n                };\n            });\n        }\n        onResult(match) {\n            this.emit('result', match);\n        }\n    }\n    exports.RipgrepParser = RipgrepParser;\n    function bytesOrTextToString(obj) {\n        return obj.bytes ?\n            Buffer.from(obj.bytes, 'base64').toString() :\n            obj.text;\n    }\n    function getNumLinesAndLastNewlineLength(text) {\n        const re = /\\n/g;\n        let numLines = 0;\n        let lastNewlineIdx = -1;\n        let match;\n        while (match = re.exec(text)) {\n            numLines++;\n            lastNewlineIdx = match.index;\n        }\n        const lastLineLength = lastNewlineIdx >= 0 ?\n            text.length - lastNewlineIdx - 1 :\n            text.length;\n        return { numLines, lastLineLength };\n    }\n    function getRgArgs(query, options) {\n        const args = ['--hidden'];\n        args.push(query.isCaseSensitive ? '--case-sensitive' : '--ignore-case');\n        const { doubleStarIncludes, otherIncludes } = collections_1.groupBy(options.includes, (include) => strings_1.startsWith(include, '**') ? 'doubleStarIncludes' : 'otherIncludes');\n        if (otherIncludes && otherIncludes.length) {\n            const uniqueOthers = new Set();\n            otherIncludes.forEach(other => {\n                if (!strings_1.endsWith(other, '/**')) {\n                    other += '/**';\n                }\n                uniqueOthers.add(other);\n            });\n            args.push('-g', '!*');\n            uniqueOthers\n                .forEach(otherIncude => {\n                spreadGlobComponents(otherIncude)\n                    .map(ripgrepSearchUtils_1.anchorGlob)\n                    .forEach(globArg => {\n                    args.push('-g', globArg);\n                });\n            });\n        }\n        if (doubleStarIncludes && doubleStarIncludes.length) {\n            doubleStarIncludes.forEach(globArg => {\n                args.push('-g', globArg);\n            });\n        }\n        options.excludes\n            .map(ripgrepSearchUtils_1.anchorGlob)\n            .forEach(rgGlob => args.push('-g', `!${rgGlob}`));\n        if (options.maxFileSize) {\n            args.push('--max-filesize', options.maxFileSize + '');\n        }\n        if (options.useIgnoreFiles) {\n            args.push('--no-ignore-parent');\n        }\n        else {\n            // Don't use .gitignore or .ignore\n            args.push('--no-ignore');\n        }\n        if (options.followSymlinks) {\n            args.push('--follow');\n        }\n        if (options.encoding && options.encoding !== 'utf8') {\n            args.push('--encoding', options.encoding);\n        }\n        let pattern = query.pattern;\n        // Ripgrep handles -- as a -- arg separator. Only --.\n        // - is ok, --- is ok, --some-flag is also ok. Need to special case.\n        if (pattern === '--') {\n            query.isRegExp = true;\n            pattern = '\\\\-\\\\-';\n        }\n        if (query.isMultiline && !query.isRegExp) {\n            query.pattern = strings_1.escapeRegExpCharacters(query.pattern);\n            query.isRegExp = true;\n        }\n        if (options.usePCRE2) {\n            args.push('--pcre2');\n            if (query.isRegExp) {\n                pattern = unicodeEscapesToPCRE2(pattern);\n            }\n        }\n        let searchPatternAfterDoubleDashes;\n        if (query.isWordMatch) {\n            const regexp = strings_1.createRegExp(pattern, !!query.isRegExp, { wholeWord: query.isWordMatch });\n            const regexpStr = regexp.source.replace(/\\\\\\//g, '/'); // RegExp.source arbitrarily returns escaped slashes. Search and destroy.\n            args.push('--regexp', regexpStr);\n        }\n        else if (query.isRegExp) {\n            let fixedRegexpQuery = fixRegexEndingPattern(query.pattern);\n            fixedRegexpQuery = fixRegexNewline(fixedRegexpQuery);\n            fixedRegexpQuery = fixNewline(fixedRegexpQuery);\n            fixedRegexpQuery = fixRegexCRMatchingNonWordClass(fixedRegexpQuery, !!query.isMultiline);\n            fixedRegexpQuery = fixRegexCRMatchingWhitespaceClass(fixedRegexpQuery, !!query.isMultiline);\n            args.push('--regexp', fixedRegexpQuery);\n        }\n        else {\n            searchPatternAfterDoubleDashes = pattern;\n            args.push('--fixed-strings');\n        }\n        args.push('--no-config');\n        if (!options.useGlobalIgnoreFiles) {\n            args.push('--no-ignore-global');\n        }\n        args.push('--json');\n        if (query.isMultiline) {\n            args.push('--multiline');\n        }\n        if (options.beforeContext) {\n            args.push('--before-context', options.beforeContext + '');\n        }\n        if (options.afterContext) {\n            args.push('--after-context', options.afterContext + '');\n        }\n        // Folder to search\n        args.push('--');\n        if (searchPatternAfterDoubleDashes) {\n            // Put the query after --, in case the query starts with a dash\n            args.push(searchPatternAfterDoubleDashes);\n        }\n        args.push('.');\n        return args;\n    }\n    /**\n     * `\"foo/*bar/something\"` -> `[\"foo\", \"foo/*bar\", \"foo/*bar/something\", \"foo/*bar/something/**\"]`\n     */\n    function spreadGlobComponents(globArg) {\n        const components = glob_1.splitGlobAware(globArg, '/');\n        if (components[components.length - 1] !== '**') {\n            components.push('**');\n        }\n        return components.map((_, i) => components.slice(0, i + 1).join('/'));\n    }\n    exports.spreadGlobComponents = spreadGlobComponents;\n    function unicodeEscapesToPCRE2(pattern) {\n        const reg = /((?:[^\\\\]|^)(?:\\\\\\\\)*)\\\\u([a-z0-9]{4})(?!\\d)/g;\n        // Replace an unescaped $ at the end of the pattern with \\r?$\n        // Match $ preceeded by none or even number of literal \\\n        while (pattern.match(reg)) {\n            pattern = pattern.replace(reg, `$1\\\\x{$2}`);\n        }\n        return pattern;\n    }\n    exports.unicodeEscapesToPCRE2 = unicodeEscapesToPCRE2;\n    function fixRegexEndingPattern(pattern) {\n        // Replace an unescaped $ at the end of the pattern with \\r?$\n        // Match $ preceeded by none or even number of literal \\\n        return pattern.match(/([^\\\\]|^)(\\\\\\\\)*\\$$/) ?\n            pattern.replace(/\\$$/, '\\\\r?$') :\n            pattern;\n    }\n    exports.fixRegexEndingPattern = fixRegexEndingPattern;\n    function fixRegexNewline(pattern) {\n        // Replace an unescaped $ at the end of the pattern with \\r?$\n        // Match $ preceeded by none or even number of literal \\\n        return pattern.replace(/([^\\\\]|^)(\\\\\\\\)*\\\\n/g, '$1$2\\\\r?\\\\n');\n    }\n    exports.fixRegexNewline = fixRegexNewline;\n    function fixRegexCRMatchingWhitespaceClass(pattern, isMultiline) {\n        return isMultiline ?\n            pattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\s/g, '$1$2(\\\\r?\\\\n|[^\\\\S\\\\r])') :\n            pattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\s/g, '$1$2[ \\\\t\\\\f]');\n    }\n    exports.fixRegexCRMatchingWhitespaceClass = fixRegexCRMatchingWhitespaceClass;\n    function fixRegexCRMatchingNonWordClass(pattern, isMultiline) {\n        return isMultiline ?\n            pattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\W/g, '$1$2(\\\\r?\\\\n|[^\\\\w\\\\r])') :\n            pattern.replace(/([^\\\\]|^)((?:\\\\\\\\)*)\\\\W/g, '$1$2[^\\\\w\\\\r]');\n    }\n    exports.fixRegexCRMatchingNonWordClass = fixRegexCRMatchingNonWordClass;\n    function fixNewline(pattern) {\n        return pattern.replace(/\\n/g, '\\\\r?\\\\n');\n    }\n    exports.fixNewline = fixNewline;\n});\n",null]}