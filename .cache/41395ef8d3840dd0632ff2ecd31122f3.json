{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorWordOperations.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/editor/common/controller/cursorWordOperations.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/charCode\", \"vs/base/common/strings\", \"vs/editor/common/controller/cursorCommon\", \"vs/editor/common/controller/wordCharacterClassifier\", \"vs/editor/common/core/position\", \"vs/editor/common/core/range\"], function (require, exports, charCode_1, strings, cursorCommon_1, wordCharacterClassifier_1, position_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var WordType;\n    (function (WordType) {\n        WordType[WordType[\"None\"] = 0] = \"None\";\n        WordType[WordType[\"Regular\"] = 1] = \"Regular\";\n        WordType[WordType[\"Separator\"] = 2] = \"Separator\";\n    })(WordType || (WordType = {}));\n    var WordNavigationType;\n    (function (WordNavigationType) {\n        WordNavigationType[WordNavigationType[\"WordStart\"] = 0] = \"WordStart\";\n        WordNavigationType[WordNavigationType[\"WordStartFast\"] = 1] = \"WordStartFast\";\n        WordNavigationType[WordNavigationType[\"WordEnd\"] = 2] = \"WordEnd\";\n    })(WordNavigationType = exports.WordNavigationType || (exports.WordNavigationType = {}));\n    class WordOperations {\n        static _createWord(lineContent, wordType, nextCharClass, start, end) {\n            // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n            return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n        }\n        static _findPreviousWordOnLine(wordSeparators, model, position) {\n            let lineContent = model.getLineContent(position.lineNumber);\n            return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n        }\n        static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n            let wordType = WordType.None;\n            for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n                let chCode = lineContent.charCodeAt(chIndex);\n                let chClass = wordSeparators.get(chCode);\n                if (chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    if (wordType === WordType.Separator) {\n                        return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                    }\n                    wordType = WordType.Regular;\n                }\n                else if (chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                    if (wordType === WordType.Regular) {\n                        return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                    }\n                    wordType = WordType.Separator;\n                }\n                else if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                    if (wordType !== WordType.None) {\n                        return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                    }\n                }\n            }\n            if (wordType !== WordType.None) {\n                return this._createWord(lineContent, wordType, wordCharacterClassifier_1.WordCharacterClass.Whitespace, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n            }\n            return null;\n        }\n        static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n            let len = lineContent.length;\n            for (let chIndex = startIndex; chIndex < len; chIndex++) {\n                let chCode = lineContent.charCodeAt(chIndex);\n                let chClass = wordSeparators.get(chCode);\n                if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                    return chIndex;\n                }\n                if (wordType === WordType.Regular && chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                    return chIndex;\n                }\n                if (wordType === WordType.Separator && chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    return chIndex;\n                }\n            }\n            return len;\n        }\n        static _findNextWordOnLine(wordSeparators, model, position) {\n            let lineContent = model.getLineContent(position.lineNumber);\n            return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n        }\n        static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n            let wordType = WordType.None;\n            let len = lineContent.length;\n            for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n                let chCode = lineContent.charCodeAt(chIndex);\n                let chClass = wordSeparators.get(chCode);\n                if (chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    if (wordType === WordType.Separator) {\n                        return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                    }\n                    wordType = WordType.Regular;\n                }\n                else if (chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                    if (wordType === WordType.Regular) {\n                        return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                    }\n                    wordType = WordType.Separator;\n                }\n                else if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                    if (wordType !== WordType.None) {\n                        return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                    }\n                }\n            }\n            if (wordType !== WordType.None) {\n                return this._createWord(lineContent, wordType, wordCharacterClassifier_1.WordCharacterClass.Whitespace, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n            }\n            return null;\n        }\n        static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n            for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n                let chCode = lineContent.charCodeAt(chIndex);\n                let chClass = wordSeparators.get(chCode);\n                if (chClass === wordCharacterClassifier_1.WordCharacterClass.Whitespace) {\n                    return chIndex + 1;\n                }\n                if (wordType === WordType.Regular && chClass === wordCharacterClassifier_1.WordCharacterClass.WordSeparator) {\n                    return chIndex + 1;\n                }\n                if (wordType === WordType.Separator && chClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    return chIndex + 1;\n                }\n            }\n            return 0;\n        }\n        static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n            let lineNumber = position.lineNumber;\n            let column = position.column;\n            let movedToPreviousLine = false;\n            if (column === 1) {\n                if (lineNumber > 1) {\n                    movedToPreviousLine = true;\n                    lineNumber = lineNumber - 1;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n            let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, column));\n            if (wordNavigationType === WordNavigationType.WordStart) {\n                if (prevWordOnLine && !movedToPreviousLine) {\n                    // Special case for Visual Studio compatibility:\n                    // when starting in the trim whitespace at the end of a line,\n                    // go to the end of the last word\n                    const lastWhitespaceColumn = model.getLineLastNonWhitespaceColumn(lineNumber);\n                    if (lastWhitespaceColumn < column) {\n                        return new position_1.Position(lineNumber, prevWordOnLine.end + 1);\n                    }\n                }\n                return new position_1.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n            }\n            if (wordNavigationType === WordNavigationType.WordStartFast) {\n                if (prevWordOnLine\n                    && prevWordOnLine.wordType === WordType.Separator\n                    && prevWordOnLine.end - prevWordOnLine.start === 1\n                    && prevWordOnLine.nextCharClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));\n                }\n                return new position_1.Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n            }\n            // We are stopping at the ending of words\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new position_1.Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n        }\n        static _moveWordPartLeft(model, position) {\n            const lineNumber = position.lineNumber;\n            const maxColumn = model.getLineMaxColumn(lineNumber);\n            if (position.column === 1) {\n                return (lineNumber > 1 ? new position_1.Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            for (let column = position.column - 1; column > 1; column--) {\n                const left = lineContent.charCodeAt(column - 2);\n                const right = lineContent.charCodeAt(column - 1);\n                if (left !== charCode_1.CharCode.Underline && right === charCode_1.CharCode.Underline) {\n                    // snake_case_variables\n                    return new position_1.Position(lineNumber, column);\n                }\n                if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                    // camelCaseVariables\n                    return new position_1.Position(lineNumber, column);\n                }\n                if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                    // thisIsACamelCaseWithOneLetterWords\n                    if (column + 1 < maxColumn) {\n                        const rightRight = lineContent.charCodeAt(column);\n                        if (strings.isLowerAsciiLetter(rightRight)) {\n                            return new position_1.Position(lineNumber, column);\n                        }\n                    }\n                }\n            }\n            return new position_1.Position(lineNumber, 1);\n        }\n        static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n            let lineNumber = position.lineNumber;\n            let column = position.column;\n            let movedDown = false;\n            if (column === model.getLineMaxColumn(lineNumber)) {\n                if (lineNumber < model.getLineCount()) {\n                    movedDown = true;\n                    lineNumber = lineNumber + 1;\n                    column = 1;\n                }\n            }\n            let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, column));\n            if (wordNavigationType === WordNavigationType.WordEnd) {\n                if (nextWordOnLine && nextWordOnLine.wordType === WordType.Separator) {\n                    if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === wordCharacterClassifier_1.WordCharacterClass.Regular) {\n                        // Skip over a word made up of one single separator and followed by a regular character\n                        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));\n                    }\n                }\n                if (nextWordOnLine) {\n                    column = nextWordOnLine.end + 1;\n                }\n                else {\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n            else {\n                if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));\n                }\n                if (nextWordOnLine) {\n                    column = nextWordOnLine.start + 1;\n                }\n                else {\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n            return new position_1.Position(lineNumber, column);\n        }\n        static _moveWordPartRight(model, position) {\n            const lineNumber = position.lineNumber;\n            const maxColumn = model.getLineMaxColumn(lineNumber);\n            if (position.column === maxColumn) {\n                return (lineNumber < model.getLineCount() ? new position_1.Position(lineNumber + 1, 1) : position);\n            }\n            const lineContent = model.getLineContent(lineNumber);\n            for (let column = position.column + 1; column < maxColumn; column++) {\n                const left = lineContent.charCodeAt(column - 2);\n                const right = lineContent.charCodeAt(column - 1);\n                if (left === charCode_1.CharCode.Underline && right !== charCode_1.CharCode.Underline) {\n                    // snake_case_variables\n                    return new position_1.Position(lineNumber, column);\n                }\n                if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                    // camelCaseVariables\n                    return new position_1.Position(lineNumber, column);\n                }\n                if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                    // thisIsACamelCaseWithOneLetterWords\n                    if (column + 1 < maxColumn) {\n                        const rightRight = lineContent.charCodeAt(column);\n                        if (strings.isLowerAsciiLetter(rightRight)) {\n                            return new position_1.Position(lineNumber, column);\n                        }\n                    }\n                }\n            }\n            return new position_1.Position(lineNumber, maxColumn);\n        }\n        static _deleteWordLeftWhitespace(model, position) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const startIndex = position.column - 2;\n            const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n            if (lastNonWhitespace + 1 < startIndex) {\n                return new range_1.Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n            }\n            return null;\n        }\n        static deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {\n            if (!selection.isEmpty()) {\n                return selection;\n            }\n            const position = new position_1.Position(selection.positionLineNumber, selection.positionColumn);\n            let lineNumber = position.lineNumber;\n            let column = position.column;\n            if (lineNumber === 1 && column === 1) {\n                // Ignore deleting at beginning of file\n                return null;\n            }\n            if (whitespaceHeuristics) {\n                let r = this._deleteWordLeftWhitespace(model, position);\n                if (r) {\n                    return r;\n                }\n            }\n            let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n            if (wordNavigationType === WordNavigationType.WordStart) {\n                if (prevWordOnLine) {\n                    column = prevWordOnLine.start + 1;\n                }\n                else {\n                    if (column > 1) {\n                        column = 1;\n                    }\n                    else {\n                        lineNumber--;\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n            else {\n                if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                    prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));\n                }\n                if (prevWordOnLine) {\n                    column = prevWordOnLine.end + 1;\n                }\n                else {\n                    if (column > 1) {\n                        column = 1;\n                    }\n                    else {\n                        lineNumber--;\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n            return new range_1.Range(lineNumber, column, position.lineNumber, position.column);\n        }\n        static _deleteWordPartLeft(model, selection) {\n            if (!selection.isEmpty()) {\n                return selection;\n            }\n            const pos = selection.getPosition();\n            const toPosition = WordOperations._moveWordPartLeft(model, pos);\n            return new range_1.Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n        }\n        static _findFirstNonWhitespaceChar(str, startIndex) {\n            let len = str.length;\n            for (let chIndex = startIndex; chIndex < len; chIndex++) {\n                let ch = str.charAt(chIndex);\n                if (ch !== ' ' && ch !== '\\t') {\n                    return chIndex;\n                }\n            }\n            return len;\n        }\n        static _deleteWordRightWhitespace(model, position) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const startIndex = position.column - 1;\n            const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n            if (startIndex + 1 < firstNonWhitespace) {\n                // bingo\n                return new range_1.Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n            }\n            return null;\n        }\n        static deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, wordNavigationType) {\n            if (!selection.isEmpty()) {\n                return selection;\n            }\n            const position = new position_1.Position(selection.positionLineNumber, selection.positionColumn);\n            let lineNumber = position.lineNumber;\n            let column = position.column;\n            const lineCount = model.getLineCount();\n            const maxColumn = model.getLineMaxColumn(lineNumber);\n            if (lineNumber === lineCount && column === maxColumn) {\n                // Ignore deleting at end of file\n                return null;\n            }\n            if (whitespaceHeuristics) {\n                let r = this._deleteWordRightWhitespace(model, position);\n                if (r) {\n                    return r;\n                }\n            }\n            let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n            if (wordNavigationType === WordNavigationType.WordEnd) {\n                if (nextWordOnLine) {\n                    column = nextWordOnLine.end + 1;\n                }\n                else {\n                    if (column < maxColumn || lineNumber === lineCount) {\n                        column = maxColumn;\n                    }\n                    else {\n                        lineNumber++;\n                        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, 1));\n                        if (nextWordOnLine) {\n                            column = nextWordOnLine.start + 1;\n                        }\n                        else {\n                            column = model.getLineMaxColumn(lineNumber);\n                        }\n                    }\n                }\n            }\n            else {\n                if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));\n                }\n                if (nextWordOnLine) {\n                    column = nextWordOnLine.start + 1;\n                }\n                else {\n                    if (column < maxColumn || lineNumber === lineCount) {\n                        column = maxColumn;\n                    }\n                    else {\n                        lineNumber++;\n                        nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new position_1.Position(lineNumber, 1));\n                        if (nextWordOnLine) {\n                            column = nextWordOnLine.start + 1;\n                        }\n                        else {\n                            column = model.getLineMaxColumn(lineNumber);\n                        }\n                    }\n                }\n            }\n            return new range_1.Range(lineNumber, column, position.lineNumber, position.column);\n        }\n        static _deleteWordPartRight(model, selection) {\n            if (!selection.isEmpty()) {\n                return selection;\n            }\n            const pos = selection.getPosition();\n            const toPosition = WordOperations._moveWordPartRight(model, pos);\n            return new range_1.Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n        }\n        static word(config, model, cursor, inSelectionMode, position) {\n            const wordSeparators = wordCharacterClassifier_1.getMapForWordSeparators(config.wordSeparators);\n            let prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n            let nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n            if (!inSelectionMode) {\n                // Entering word selection for the first time\n                let startColumn;\n                let endColumn;\n                if (prevWord && prevWord.wordType === WordType.Regular && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                    // isTouchingPrevWord\n                    startColumn = prevWord.start + 1;\n                    endColumn = prevWord.end + 1;\n                }\n                else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                    // isTouchingNextWord\n                    startColumn = nextWord.start + 1;\n                    endColumn = nextWord.end + 1;\n                }\n                else {\n                    if (prevWord) {\n                        startColumn = prevWord.end + 1;\n                    }\n                    else {\n                        startColumn = 1;\n                    }\n                    if (nextWord) {\n                        endColumn = nextWord.start + 1;\n                    }\n                    else {\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                }\n                return new cursorCommon_1.SingleCursorState(new range_1.Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new position_1.Position(position.lineNumber, endColumn), 0);\n            }\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n                // isInsidePrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n                // isInsideNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                startColumn = position.column;\n                endColumn = position.column;\n            }\n            let lineNumber = position.lineNumber;\n            let column;\n            if (cursor.selectionStart.containsPosition(position)) {\n                column = cursor.selectionStart.endColumn;\n            }\n            else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n                column = startColumn;\n                let possiblePosition = new position_1.Position(lineNumber, column);\n                if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                    column = cursor.selectionStart.endColumn;\n                }\n            }\n            else {\n                column = endColumn;\n                let possiblePosition = new position_1.Position(lineNumber, column);\n                if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                    column = cursor.selectionStart.startColumn;\n                }\n            }\n            return cursor.move(true, lineNumber, column, 0);\n        }\n    }\n    exports.WordOperations = WordOperations;\n    class WordPartOperations extends WordOperations {\n        static deleteWordPartLeft(wordSeparators, model, selection, whitespaceHeuristics) {\n            const candidates = enforceDefined([\n                WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordStart),\n                WordOperations.deleteWordLeft(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordEnd),\n                WordOperations._deleteWordPartLeft(model, selection)\n            ]);\n            candidates.sort(range_1.Range.compareRangesUsingEnds);\n            return candidates[2];\n        }\n        static deleteWordPartRight(wordSeparators, model, selection, whitespaceHeuristics) {\n            const candidates = enforceDefined([\n                WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordStart),\n                WordOperations.deleteWordRight(wordSeparators, model, selection, whitespaceHeuristics, WordNavigationType.WordEnd),\n                WordOperations._deleteWordPartRight(model, selection)\n            ]);\n            candidates.sort(range_1.Range.compareRangesUsingStarts);\n            return candidates[0];\n        }\n        static moveWordPartLeft(wordSeparators, model, position) {\n            const candidates = enforceDefined([\n                WordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordStart),\n                WordOperations.moveWordLeft(wordSeparators, model, position, WordNavigationType.WordEnd),\n                WordOperations._moveWordPartLeft(model, position)\n            ]);\n            candidates.sort(position_1.Position.compare);\n            return candidates[2];\n        }\n        static moveWordPartRight(wordSeparators, model, position) {\n            const candidates = enforceDefined([\n                WordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordStart),\n                WordOperations.moveWordRight(wordSeparators, model, position, WordNavigationType.WordEnd),\n                WordOperations._moveWordPartRight(model, position)\n            ]);\n            candidates.sort(position_1.Position.compare);\n            return candidates[0];\n        }\n    }\n    exports.WordPartOperations = WordPartOperations;\n    function enforceDefined(arr) {\n        return arr.filter(el => Boolean(el));\n    }\n});\n",null]}