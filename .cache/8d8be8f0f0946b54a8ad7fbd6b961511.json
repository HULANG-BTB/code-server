{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar paths = require(\"vs/base/common/path\");\nvar process = require(\"vs/base/common/process\");\nvar types = require(\"vs/base/common/types\");\nvar objects = require(\"vs/base/common/objects\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar labels_1 = require(\"vs/base/common/labels\");\nvar nls_1 = require(\"vs/nls\");\nvar AbstractVariableResolverService = /** @class */ (function () {\n    function AbstractVariableResolverService(_context, _envVariables) {\n        var _this = this;\n        this._context = _context;\n        this._envVariables = _envVariables;\n        if (platform_1.isWindows) {\n            this._envVariables = Object.create(null);\n            Object.keys(_envVariables).forEach(function (key) {\n                _this._envVariables[key.toLowerCase()] = _envVariables[key];\n            });\n        }\n    }\n    AbstractVariableResolverService.prototype.resolve = function (root, value) {\n        return this.recursiveResolve(root ? root.uri : undefined, value);\n    };\n    AbstractVariableResolverService.prototype.resolveAnyBase = function (workspaceFolder, config, commandValueMapping, resolvedVariables) {\n        var result = objects.deepClone(config);\n        // hoist platform specific attributes to top level\n        if (platform_1.isWindows && result.windows) {\n            Object.keys(result.windows).forEach(function (key) { return result[key] = result.windows[key]; });\n        }\n        else if (platform_1.isMacintosh && result.osx) {\n            Object.keys(result.osx).forEach(function (key) { return result[key] = result.osx[key]; });\n        }\n        else if (platform_1.isLinux && result.linux) {\n            Object.keys(result.linux).forEach(function (key) { return result[key] = result.linux[key]; });\n        }\n        // delete all platform specific sections\n        delete result.windows;\n        delete result.osx;\n        delete result.linux;\n        // substitute all variables recursively in string values\n        return this.recursiveResolve(workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping, resolvedVariables);\n    };\n    AbstractVariableResolverService.prototype.resolveAny = function (workspaceFolder, config, commandValueMapping) {\n        return this.resolveAnyBase(workspaceFolder, config, commandValueMapping);\n    };\n    AbstractVariableResolverService.prototype.resolveAnyMap = function (workspaceFolder, config, commandValueMapping) {\n        var resolvedVariables = new Map();\n        var newConfig = this.resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables);\n        return { newConfig: newConfig, resolvedVariables: resolvedVariables };\n    };\n    AbstractVariableResolverService.prototype.resolveWithInteractionReplace = function (folder, config, section, variables) {\n        throw new Error('resolveWithInteractionReplace not implemented.');\n    };\n    AbstractVariableResolverService.prototype.resolveWithInteraction = function (folder, config, section, variables) {\n        throw new Error('resolveWithInteraction not implemented.');\n    };\n    AbstractVariableResolverService.prototype.recursiveResolve = function (folderUri, value, commandValueMapping, resolvedVariables) {\n        var _this = this;\n        if (types.isString(value)) {\n            return this.resolveString(folderUri, value, commandValueMapping, resolvedVariables);\n        }\n        else if (types.isArray(value)) {\n            return value.map(function (s) { return _this.recursiveResolve(folderUri, s, commandValueMapping, resolvedVariables); });\n        }\n        else if (types.isObject(value)) {\n            var result_1 = Object.create(null);\n            Object.keys(value).forEach(function (key) {\n                var replaced = _this.resolveString(folderUri, key, commandValueMapping, resolvedVariables);\n                result_1[replaced] = _this.recursiveResolve(folderUri, value[key], commandValueMapping, resolvedVariables);\n            });\n            return result_1;\n        }\n        return value;\n    };\n    AbstractVariableResolverService.prototype.resolveString = function (folderUri, value, commandValueMapping, resolvedVariables) {\n        var _this = this;\n        // loop through all variables occurrences in 'value'\n        var replaced = value.replace(AbstractVariableResolverService.VARIABLE_REGEXP, function (match, variable) {\n            var resolvedValue = _this.evaluateSingleVariable(match, variable, folderUri, commandValueMapping);\n            if (resolvedVariables) {\n                resolvedVariables.set(variable, resolvedValue);\n            }\n            return resolvedValue;\n        });\n        return replaced;\n    };\n    AbstractVariableResolverService.prototype.evaluateSingleVariable = function (match, variable, folderUri, commandValueMapping) {\n        var _this = this;\n        // try to separate variable arguments from variable name\n        var argument;\n        var parts = variable.split(':');\n        if (parts.length > 1) {\n            variable = parts[0];\n            argument = parts[1];\n        }\n        // common error handling for all variables that require an open editor\n        var getFilePath = function () {\n            var filePath = _this._context.getFilePath();\n            if (filePath) {\n                return filePath;\n            }\n            throw new Error(nls_1.localize('canNotResolveFile', \"'{0}' can not be resolved. Please open an editor.\", match));\n        };\n        // common error handling for all variables that require an open folder and accept a folder name argument\n        var getFolderUri = function (withArg) {\n            if (withArg === void 0) { withArg = true; }\n            if (withArg && argument) {\n                var folder = _this._context.getFolderUri(argument);\n                if (folder) {\n                    return folder;\n                }\n                throw new Error(nls_1.localize('canNotFindFolder', \"'{0}' can not be resolved. No such folder '{1}'.\", match, argument));\n            }\n            if (folderUri) {\n                return folderUri;\n            }\n            if (_this._context.getWorkspaceFolderCount() > 1) {\n                throw new Error(nls_1.localize('canNotResolveWorkspaceFolderMultiRoot', \"'{0}' can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.\", match));\n            }\n            throw new Error(nls_1.localize('canNotResolveWorkspaceFolder', \"'{0}' can not be resolved. Please open a folder.\", match));\n        };\n        switch (variable) {\n            case 'env':\n                if (argument) {\n                    if (platform_1.isWindows) {\n                        argument = argument.toLowerCase();\n                    }\n                    var env = this._envVariables[argument];\n                    if (types.isString(env)) {\n                        return env;\n                    }\n                    // For `env` we should do the same as a normal shell does - evaluates missing envs to an empty string #46436\n                    return '';\n                }\n                throw new Error(nls_1.localize('missingEnvVarName', \"'{0}' can not be resolved because no environment variable name is given.\", match));\n            case 'config':\n                if (argument) {\n                    var config = this._context.getConfigurationValue(getFolderUri(false), argument);\n                    if (types.isUndefinedOrNull(config)) {\n                        throw new Error(nls_1.localize('configNotFound', \"'{0}' can not be resolved because setting '{1}' not found.\", match, argument));\n                    }\n                    if (types.isObject(config)) {\n                        throw new Error(nls_1.localize('configNoString', \"'{0}' can not be resolved because '{1}' is a structured value.\", match, argument));\n                    }\n                    return config;\n                }\n                throw new Error(nls_1.localize('missingConfigName', \"'{0}' can not be resolved because no settings name is given.\", match));\n            case 'command':\n                return this.resolveFromMap(match, argument, commandValueMapping, 'command');\n            case 'input':\n                return this.resolveFromMap(match, argument, commandValueMapping, 'input');\n            default: {\n                switch (variable) {\n                    case 'workspaceRoot':\n                    case 'workspaceFolder':\n                        return labels_1.normalizeDriveLetter(getFolderUri().fsPath);\n                    case 'cwd':\n                        return (folderUri ? labels_1.normalizeDriveLetter(getFolderUri().fsPath) : process.cwd());\n                    case 'workspaceRootFolderName':\n                    case 'workspaceFolderBasename':\n                        return paths.basename(getFolderUri().fsPath);\n                    case 'lineNumber':\n                        var lineNumber = this._context.getLineNumber();\n                        if (lineNumber) {\n                            return lineNumber;\n                        }\n                        throw new Error(nls_1.localize('canNotResolveLineNumber', \"'{0}' can not be resolved. Make sure to have a line selected in the active editor.\", match));\n                    case 'selectedText':\n                        var selectedText = this._context.getSelectedText();\n                        if (selectedText) {\n                            return selectedText;\n                        }\n                        throw new Error(nls_1.localize('canNotResolveSelectedText', \"'{0}' can not be resolved. Make sure to have some text selected in the active editor.\", match));\n                    case 'file':\n                        return getFilePath();\n                    case 'relativeFile':\n                        if (folderUri) {\n                            return paths.normalize(paths.relative(getFolderUri().fsPath, getFilePath()));\n                        }\n                        return getFilePath();\n                    case 'fileDirname':\n                        return paths.dirname(getFilePath());\n                    case 'fileExtname':\n                        return paths.extname(getFilePath());\n                    case 'fileBasename':\n                        return paths.basename(getFilePath());\n                    case 'fileBasenameNoExtension':\n                        var basename = paths.basename(getFilePath());\n                        return (basename.slice(0, basename.length - paths.extname(basename).length));\n                    case 'execPath':\n                        var ep = this._context.getExecPath();\n                        if (ep) {\n                            return ep;\n                        }\n                        return match;\n                    default:\n                        return match;\n                }\n            }\n        }\n    };\n    AbstractVariableResolverService.prototype.resolveFromMap = function (match, argument, commandValueMapping, prefix) {\n        if (argument && commandValueMapping) {\n            var v = commandValueMapping[prefix + ':' + argument];\n            if (typeof v === 'string') {\n                return v;\n            }\n            throw new Error(nls_1.localize('noValueForCommand', \"'{0}' can not be resolved because the command has no value.\", match));\n        }\n        return match;\n    };\n    AbstractVariableResolverService.VARIABLE_REGEXP = /\\$\\{(.*?)\\}/g;\n    return AbstractVariableResolverService;\n}());\nexports.AbstractVariableResolverService = AbstractVariableResolverService;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/workbench/services/configurationResolver/common/variableResolver.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as paths from 'vs/base/common/path';\nimport * as process from 'vs/base/common/process';\nimport * as types from 'vs/base/common/types';\nimport * as objects from 'vs/base/common/objects';\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport { IProcessEnvironment, isWindows, isMacintosh, isLinux } from 'vs/base/common/platform';\nimport { normalizeDriveLetter } from 'vs/base/common/labels';\nimport { localize } from 'vs/nls';\nimport { URI as uri } from 'vs/base/common/uri';\nimport { IConfigurationResolverService } from 'vs/workbench/services/configurationResolver/common/configurationResolver';\nimport { IWorkspaceFolder } from 'vs/platform/workspace/common/workspace';\n\nexport interface IVariableResolveContext {\n\tgetFolderUri(folderName: string): uri | undefined;\n\tgetWorkspaceFolderCount(): number;\n\tgetConfigurationValue(folderUri: uri, section: string): string | undefined;\n\tgetExecPath(): string | undefined;\n\tgetFilePath(): string | undefined;\n\tgetSelectedText(): string | undefined;\n\tgetLineNumber(): string | undefined;\n}\n\nexport class AbstractVariableResolverService implements IConfigurationResolverService {\n\n\tstatic VARIABLE_REGEXP = /\\$\\{(.*?)\\}/g;\n\n\t_serviceBrand: any;\n\n\tconstructor(\n\t\tprivate _context: IVariableResolveContext,\n\t\tprivate _envVariables: IProcessEnvironment\n\t) {\n\t\tif (isWindows) {\n\t\t\tthis._envVariables = Object.create(null);\n\t\t\tObject.keys(_envVariables).forEach(key => {\n\t\t\t\tthis._envVariables[key.toLowerCase()] = _envVariables[key];\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic resolve(root: IWorkspaceFolder | undefined, value: string): string;\n\tpublic resolve(root: IWorkspaceFolder | undefined, value: string[]): string[];\n\tpublic resolve(root: IWorkspaceFolder | undefined, value: IStringDictionary<string>): IStringDictionary<string>;\n\tpublic resolve(root: IWorkspaceFolder | undefined, value: any): any {\n\t\treturn this.recursiveResolve(root ? root.uri : undefined, value);\n\t}\n\n\tpublic resolveAnyBase(workspaceFolder: IWorkspaceFolder | undefined, config: any, commandValueMapping?: IStringDictionary<string>, resolvedVariables?: Map<string, string>): any {\n\n\t\tconst result = objects.deepClone(config) as any;\n\n\t\t// hoist platform specific attributes to top level\n\t\tif (isWindows && result.windows) {\n\t\t\tObject.keys(result.windows).forEach(key => result[key] = result.windows[key]);\n\t\t} else if (isMacintosh && result.osx) {\n\t\t\tObject.keys(result.osx).forEach(key => result[key] = result.osx[key]);\n\t\t} else if (isLinux && result.linux) {\n\t\t\tObject.keys(result.linux).forEach(key => result[key] = result.linux[key]);\n\t\t}\n\n\t\t// delete all platform specific sections\n\t\tdelete result.windows;\n\t\tdelete result.osx;\n\t\tdelete result.linux;\n\n\t\t// substitute all variables recursively in string values\n\t\treturn this.recursiveResolve(workspaceFolder ? workspaceFolder.uri : undefined, result, commandValueMapping, resolvedVariables);\n\t}\n\n\tpublic resolveAny(workspaceFolder: IWorkspaceFolder | undefined, config: any, commandValueMapping?: IStringDictionary<string>): any {\n\t\treturn this.resolveAnyBase(workspaceFolder, config, commandValueMapping);\n\t}\n\n\tpublic resolveAnyMap(workspaceFolder: IWorkspaceFolder | undefined, config: any, commandValueMapping?: IStringDictionary<string>): { newConfig: any, resolvedVariables: Map<string, string> } {\n\t\tconst resolvedVariables = new Map<string, string>();\n\t\tconst newConfig = this.resolveAnyBase(workspaceFolder, config, commandValueMapping, resolvedVariables);\n\t\treturn { newConfig, resolvedVariables };\n\t}\n\n\tpublic resolveWithInteractionReplace(folder: IWorkspaceFolder | undefined, config: any, section?: string, variables?: IStringDictionary<string>): Promise<any> {\n\t\tthrow new Error('resolveWithInteractionReplace not implemented.');\n\t}\n\n\tpublic resolveWithInteraction(folder: IWorkspaceFolder | undefined, config: any, section?: string, variables?: IStringDictionary<string>): Promise<Map<string, string> | undefined> {\n\t\tthrow new Error('resolveWithInteraction not implemented.');\n\t}\n\n\tprivate recursiveResolve(folderUri: uri | undefined, value: any, commandValueMapping?: IStringDictionary<string>, resolvedVariables?: Map<string, string>): any {\n\t\tif (types.isString(value)) {\n\t\t\treturn this.resolveString(folderUri, value, commandValueMapping, resolvedVariables);\n\t\t} else if (types.isArray(value)) {\n\t\t\treturn value.map(s => this.recursiveResolve(folderUri, s, commandValueMapping, resolvedVariables));\n\t\t} else if (types.isObject(value)) {\n\t\t\tlet result: IStringDictionary<string | IStringDictionary<string> | string[]> = Object.create(null);\n\t\t\tObject.keys(value).forEach(key => {\n\t\t\t\tconst replaced = this.resolveString(folderUri, key, commandValueMapping, resolvedVariables);\n\t\t\t\tresult[replaced] = this.recursiveResolve(folderUri, value[key], commandValueMapping, resolvedVariables);\n\t\t\t});\n\t\t\treturn result;\n\t\t}\n\t\treturn value;\n\t}\n\n\tprivate resolveString(folderUri: uri | undefined, value: string, commandValueMapping: IStringDictionary<string> | undefined, resolvedVariables?: Map<string, string>): string {\n\n\t\t// loop through all variables occurrences in 'value'\n\t\tconst replaced = value.replace(AbstractVariableResolverService.VARIABLE_REGEXP, (match: string, variable: string) => {\n\n\t\t\tlet resolvedValue = this.evaluateSingleVariable(match, variable, folderUri, commandValueMapping);\n\n\t\t\tif (resolvedVariables) {\n\t\t\t\tresolvedVariables.set(variable, resolvedValue);\n\t\t\t}\n\n\t\t\treturn resolvedValue;\n\t\t});\n\n\t\treturn replaced;\n\t}\n\n\tprivate evaluateSingleVariable(match: string, variable: string, folderUri: uri | undefined, commandValueMapping: IStringDictionary<string> | undefined): string {\n\n\t\t// try to separate variable arguments from variable name\n\t\tlet argument: string | undefined;\n\t\tconst parts = variable.split(':');\n\t\tif (parts.length > 1) {\n\t\t\tvariable = parts[0];\n\t\t\targument = parts[1];\n\t\t}\n\n\t\t// common error handling for all variables that require an open editor\n\t\tconst getFilePath = (): string => {\n\n\t\t\tconst filePath = this._context.getFilePath();\n\t\t\tif (filePath) {\n\t\t\t\treturn filePath;\n\t\t\t}\n\t\t\tthrow new Error(localize('canNotResolveFile', \"'{0}' can not be resolved. Please open an editor.\", match));\n\t\t};\n\n\t\t// common error handling for all variables that require an open folder and accept a folder name argument\n\t\tconst getFolderUri = (withArg = true): uri => {\n\n\t\t\tif (withArg && argument) {\n\t\t\t\tconst folder = this._context.getFolderUri(argument);\n\t\t\t\tif (folder) {\n\t\t\t\t\treturn folder;\n\t\t\t\t}\n\t\t\t\tthrow new Error(localize('canNotFindFolder', \"'{0}' can not be resolved. No such folder '{1}'.\", match, argument));\n\t\t\t}\n\n\t\t\tif (folderUri) {\n\t\t\t\treturn folderUri;\n\t\t\t}\n\n\t\t\tif (this._context.getWorkspaceFolderCount() > 1) {\n\t\t\t\tthrow new Error(localize('canNotResolveWorkspaceFolderMultiRoot', \"'{0}' can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.\", match));\n\t\t\t}\n\t\t\tthrow new Error(localize('canNotResolveWorkspaceFolder', \"'{0}' can not be resolved. Please open a folder.\", match));\n\t\t};\n\n\n\t\tswitch (variable) {\n\n\t\t\tcase 'env':\n\t\t\t\tif (argument) {\n\t\t\t\t\tif (isWindows) {\n\t\t\t\t\t\targument = argument.toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\tconst env = this._envVariables[argument];\n\t\t\t\t\tif (types.isString(env)) {\n\t\t\t\t\t\treturn env;\n\t\t\t\t\t}\n\t\t\t\t\t// For `env` we should do the same as a normal shell does - evaluates missing envs to an empty string #46436\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\tthrow new Error(localize('missingEnvVarName', \"'{0}' can not be resolved because no environment variable name is given.\", match));\n\n\t\t\tcase 'config':\n\t\t\t\tif (argument) {\n\t\t\t\t\tconst config = this._context.getConfigurationValue(getFolderUri(false), argument);\n\t\t\t\t\tif (types.isUndefinedOrNull(config)) {\n\t\t\t\t\t\tthrow new Error(localize('configNotFound', \"'{0}' can not be resolved because setting '{1}' not found.\", match, argument));\n\t\t\t\t\t}\n\t\t\t\t\tif (types.isObject(config)) {\n\t\t\t\t\t\tthrow new Error(localize('configNoString', \"'{0}' can not be resolved because '{1}' is a structured value.\", match, argument));\n\t\t\t\t\t}\n\t\t\t\t\treturn config;\n\t\t\t\t}\n\t\t\t\tthrow new Error(localize('missingConfigName', \"'{0}' can not be resolved because no settings name is given.\", match));\n\n\t\t\tcase 'command':\n\t\t\t\treturn this.resolveFromMap(match, argument, commandValueMapping, 'command');\n\n\t\t\tcase 'input':\n\t\t\t\treturn this.resolveFromMap(match, argument, commandValueMapping, 'input');\n\n\t\t\tdefault: {\n\n\t\t\t\tswitch (variable) {\n\t\t\t\t\tcase 'workspaceRoot':\n\t\t\t\t\tcase 'workspaceFolder':\n\t\t\t\t\t\treturn normalizeDriveLetter(getFolderUri().fsPath);\n\n\t\t\t\t\tcase 'cwd':\n\t\t\t\t\t\treturn (folderUri ? normalizeDriveLetter(getFolderUri().fsPath) : process.cwd());\n\n\t\t\t\t\tcase 'workspaceRootFolderName':\n\t\t\t\t\tcase 'workspaceFolderBasename':\n\t\t\t\t\t\treturn paths.basename(getFolderUri().fsPath);\n\n\t\t\t\t\tcase 'lineNumber':\n\t\t\t\t\t\tconst lineNumber = this._context.getLineNumber();\n\t\t\t\t\t\tif (lineNumber) {\n\t\t\t\t\t\t\treturn lineNumber;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error(localize('canNotResolveLineNumber', \"'{0}' can not be resolved. Make sure to have a line selected in the active editor.\", match));\n\n\t\t\t\t\tcase 'selectedText':\n\t\t\t\t\t\tconst selectedText = this._context.getSelectedText();\n\t\t\t\t\t\tif (selectedText) {\n\t\t\t\t\t\t\treturn selectedText;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error(localize('canNotResolveSelectedText', \"'{0}' can not be resolved. Make sure to have some text selected in the active editor.\", match));\n\n\t\t\t\t\tcase 'file':\n\t\t\t\t\t\treturn getFilePath();\n\n\t\t\t\t\tcase 'relativeFile':\n\t\t\t\t\t\tif (folderUri) {\n\t\t\t\t\t\t\treturn paths.normalize(paths.relative(getFolderUri().fsPath, getFilePath()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn getFilePath();\n\n\t\t\t\t\tcase 'fileDirname':\n\t\t\t\t\t\treturn paths.dirname(getFilePath());\n\n\t\t\t\t\tcase 'fileExtname':\n\t\t\t\t\t\treturn paths.extname(getFilePath());\n\n\t\t\t\t\tcase 'fileBasename':\n\t\t\t\t\t\treturn paths.basename(getFilePath());\n\n\t\t\t\t\tcase 'fileBasenameNoExtension':\n\t\t\t\t\t\tconst basename = paths.basename(getFilePath());\n\t\t\t\t\t\treturn (basename.slice(0, basename.length - paths.extname(basename).length));\n\n\t\t\t\t\tcase 'execPath':\n\t\t\t\t\t\tconst ep = this._context.getExecPath();\n\t\t\t\t\t\tif (ep) {\n\t\t\t\t\t\t\treturn ep;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn match;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate resolveFromMap(match: string, argument: string | undefined, commandValueMapping: IStringDictionary<string> | undefined, prefix: string): string {\n\t\tif (argument && commandValueMapping) {\n\t\t\tconst v = commandValueMapping[prefix + ':' + argument];\n\t\t\tif (typeof v === 'string') {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tthrow new Error(localize('noValueForCommand', \"'{0}' can not be resolved because the command has no value.\", match));\n\t\t}\n\t\treturn match;\n\t}\n}\n"]}]}