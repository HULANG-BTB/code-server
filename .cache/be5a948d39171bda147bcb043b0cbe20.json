{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es5\",\"lib\":[\"dom\",\"esnext\"]}}!/home/coding/workspace/lib/vscode/src/vs/base/parts/quickopen/common/quickOpenScorer.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/parts/quickopen/common/quickOpenScorer.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar comparers_1 = require(\"vs/base/common/comparers\");\nvar filters_1 = require(\"vs/base/common/filters\");\nvar path_1 = require(\"vs/base/common/path\");\nvar platform_1 = require(\"vs/base/common/platform\");\nvar strings_1 = require(\"vs/base/common/strings\");\nvar charCode_1 = require(\"vs/base/common/charCode\");\nvar NO_MATCH = 0;\nvar NO_SCORE = [NO_MATCH, []];\n// const DEBUG = false;\n// const DEBUG_MATRIX = false;\nfunction score(target, query, queryLower, fuzzy) {\n    if (!target || !query) {\n        return NO_SCORE; // return early if target or query are undefined\n    }\n    var targetLength = target.length;\n    var queryLength = query.length;\n    if (targetLength < queryLength) {\n        return NO_SCORE; // impossible for query to be contained in target\n    }\n    // if (DEBUG) {\n    // \tconsole.group(`Target: ${target}, Query: ${query}`);\n    // }\n    var targetLower = target.toLowerCase();\n    // When not searching fuzzy, we require the query to be contained fully\n    // in the target string contiguously.\n    if (!fuzzy) {\n        var indexOfQueryInTarget = targetLower.indexOf(queryLower);\n        if (indexOfQueryInTarget === -1) {\n            // if (DEBUG) {\n            // \tconsole.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);\n            // }\n            return NO_SCORE;\n        }\n    }\n    var res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);\n    // if (DEBUG) {\n    // \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n    // \tconsole.groupEnd();\n    // }\n    return res;\n}\nexports.score = score;\nfunction doScore(query, queryLower, queryLength, target, targetLower, targetLength) {\n    var scores = [];\n    var matches = [];\n    //\n    // Build Scorer Matrix:\n    //\n    // The matrix is composed of query q and target t. For each index we score\n    // q[i] with t[i] and compare that with the previous score. If the score is\n    // equal or larger, we keep the match. In addition to the score, we also keep\n    // the length of the consecutive matches to use as boost for the score.\n    //\n    //      t   a   r   g   e   t\n    //  q\n    //  u\n    //  e\n    //  r\n    //  y\n    //\n    for (var queryIndex_1 = 0; queryIndex_1 < queryLength; queryIndex_1++) {\n        var queryIndexOffset = queryIndex_1 * targetLength;\n        var queryIndexPreviousOffset = queryIndexOffset - targetLength;\n        var queryIndexGtNull = queryIndex_1 > 0;\n        var queryCharAtIndex = query[queryIndex_1];\n        var queryLowerCharAtIndex = queryLower[queryIndex_1];\n        for (var targetIndex_1 = 0; targetIndex_1 < targetLength; targetIndex_1++) {\n            var targetIndexGtNull = targetIndex_1 > 0;\n            var currentIndex = queryIndexOffset + targetIndex_1;\n            var leftIndex = currentIndex - 1;\n            var diagIndex = queryIndexPreviousOffset + targetIndex_1 - 1;\n            var leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n            var diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n            var matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n            // If we are not matching on the first query character any more, we only produce a\n            // score if we had a score previously for the last query index (by looking at the diagScore).\n            // This makes sure that the query always matches in sequence on the target. For example\n            // given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n            // for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n            var score_1 = void 0;\n            if (!diagScore && queryIndexGtNull) {\n                score_1 = 0;\n            }\n            else {\n                score_1 = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex_1, matchesSequenceLength);\n            }\n            // We have a score and its equal or larger than the left score\n            // Match: sequence continues growing from previous diag value\n            // Score: increases by diag score value\n            if (score_1 && diagScore + score_1 >= leftScore) {\n                matches[currentIndex] = matchesSequenceLength + 1;\n                scores[currentIndex] = diagScore + score_1;\n            }\n            // We either have no score or the score is lower than the left score\n            // Match: reset to 0\n            // Score: pick up from left hand side\n            else {\n                matches[currentIndex] = NO_MATCH;\n                scores[currentIndex] = leftScore;\n            }\n        }\n    }\n    // Restore Positions (starting from bottom right of matrix)\n    var positions = [];\n    var queryIndex = queryLength - 1;\n    var targetIndex = targetLength - 1;\n    while (queryIndex >= 0 && targetIndex >= 0) {\n        var currentIndex = queryIndex * targetLength + targetIndex;\n        var match = matches[currentIndex];\n        if (match === NO_MATCH) {\n            targetIndex--; // go left\n        }\n        else {\n            positions.push(targetIndex);\n            // go up and left\n            queryIndex--;\n            targetIndex--;\n        }\n    }\n    // Print matrix\n    // if (DEBUG_MATRIX) {\n    // printMatrix(query, target, matches, scores);\n    // }\n    return [scores[queryLength * targetLength - 1], positions.reverse()];\n}\nfunction computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength) {\n    var score = 0;\n    if (queryLowerCharAtIndex !== targetLower[targetIndex]) {\n        return score; // no match of characters\n    }\n    // Character match bonus\n    score += 1;\n    // if (DEBUG) {\n    // \tconsole.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');\n    // }\n    // Consecutive match bonus\n    if (matchesSequenceLength > 0) {\n        score += (matchesSequenceLength * 5);\n        // if (DEBUG) {\n        // \tconsole.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));\n        // }\n    }\n    // Same case bonus\n    if (queryCharAtIndex === target[targetIndex]) {\n        score += 1;\n        // if (DEBUG) {\n        // \tconsole.log('Same case bonus: +1');\n        // }\n    }\n    // Start of word bonus\n    if (targetIndex === 0) {\n        score += 8;\n        // if (DEBUG) {\n        // \tconsole.log('Start of word bonus: +8');\n        // }\n    }\n    else {\n        // After separator bonus\n        var separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n        if (separatorBonus) {\n            score += separatorBonus;\n            // if (DEBUG) {\n            // \tconsole.log('After separtor bonus: +4');\n            // }\n        }\n        // Inside word upper case bonus (camel case)\n        else if (filters_1.isUpper(target.charCodeAt(targetIndex))) {\n            score += 1;\n            // if (DEBUG) {\n            // \tconsole.log('Inside word upper case bonus: +1');\n            // }\n        }\n    }\n    // if (DEBUG) {\n    // \tconsole.groupEnd();\n    // }\n    return score;\n}\nfunction scoreSeparatorAtPos(charCode) {\n    switch (charCode) {\n        case charCode_1.CharCode.Slash:\n        case charCode_1.CharCode.Backslash:\n            return 5; // prefer path separators...\n        case charCode_1.CharCode.Underline:\n        case charCode_1.CharCode.Dash:\n        case charCode_1.CharCode.Period:\n        case charCode_1.CharCode.Space:\n        case charCode_1.CharCode.SingleQuote:\n        case charCode_1.CharCode.DoubleQuote:\n        case charCode_1.CharCode.Colon:\n            return 4; // ...over other separators\n        default:\n            return 0;\n    }\n}\nvar NO_ITEM_SCORE = Object.freeze({ score: 0 });\nvar PATH_IDENTITY_SCORE = 1 << 18;\nvar LABEL_PREFIX_SCORE = 1 << 17;\nvar LABEL_CAMELCASE_SCORE = 1 << 16;\nvar LABEL_SCORE_THRESHOLD = 1 << 15;\n/**\n * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.\n */\nfunction prepareQuery(original) {\n    if (!original) {\n        original = '';\n    }\n    var value = strings_1.stripWildcards(original).replace(/\\s/g, ''); // get rid of all wildcards and whitespace\n    if (platform_1.isWindows) {\n        value = value.replace(/\\//g, path_1.sep); // Help Windows users to search for paths when using slash\n    }\n    var lowercase = value.toLowerCase();\n    var containsPathSeparator = value.indexOf(path_1.sep) >= 0;\n    return { original: original, value: value, lowercase: lowercase, containsPathSeparator: containsPathSeparator };\n}\nexports.prepareQuery = prepareQuery;\nfunction scoreItem(item, query, fuzzy, accessor, cache) {\n    if (!item || !query.value) {\n        return NO_ITEM_SCORE; // we need an item and query to score on at least\n    }\n    var label = accessor.getItemLabel(item);\n    if (!label) {\n        return NO_ITEM_SCORE; // we need a label at least\n    }\n    var description = accessor.getItemDescription(item);\n    var cacheHash;\n    if (description) {\n        cacheHash = \"\" + label + description + query.value + fuzzy;\n    }\n    else {\n        cacheHash = \"\" + label + query.value + fuzzy;\n    }\n    var cached = cache[cacheHash];\n    if (cached) {\n        return cached;\n    }\n    var itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);\n    cache[cacheHash] = itemScore;\n    return itemScore;\n}\nexports.scoreItem = scoreItem;\nfunction createMatches(offsets) {\n    var ret = [];\n    if (!offsets) {\n        return ret;\n    }\n    var last;\n    for (var _i = 0, offsets_1 = offsets; _i < offsets_1.length; _i++) {\n        var pos = offsets_1[_i];\n        if (last && last.end === pos) {\n            last.end += 1;\n        }\n        else {\n            last = { start: pos, end: pos + 1 };\n            ret.push(last);\n        }\n    }\n    return ret;\n}\nfunction doScoreItem(label, description, path, query, fuzzy) {\n    // 1.) treat identity matches on full path highest\n    if (path && (platform_1.isLinux ? query.original === path : strings_1.equalsIgnoreCase(query.original, path))) {\n        return { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n    }\n    // We only consider label matches if the query is not including file path separators\n    var preferLabelMatches = !path || !query.containsPathSeparator;\n    if (preferLabelMatches) {\n        // 2.) treat prefix matches on the label second highest\n        var prefixLabelMatch = filters_1.matchesPrefix(query.value, label);\n        if (prefixLabelMatch) {\n            return { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };\n        }\n        // 3.) treat camelcase matches on the label third highest\n        var camelcaseLabelMatch = filters_1.matchesCamelCase(query.value, label);\n        if (camelcaseLabelMatch) {\n            return { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };\n        }\n        // 4.) prefer scores on the label if any\n        var _a = score(label, query.value, query.lowercase, fuzzy), labelScore = _a[0], labelPositions = _a[1];\n        if (labelScore) {\n            return { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: createMatches(labelPositions) };\n        }\n    }\n    // 5.) finally compute description + label scores if we have a description\n    if (description) {\n        var descriptionPrefix = description;\n        if (!!path) {\n            descriptionPrefix = \"\" + description + path_1.sep; // assume this is a file path\n        }\n        var descriptionPrefixLength_1 = descriptionPrefix.length;\n        var descriptionAndLabel = \"\" + descriptionPrefix + label;\n        var _b = score(descriptionAndLabel, query.value, query.lowercase, fuzzy), labelDescriptionScore = _b[0], labelDescriptionPositions = _b[1];\n        if (labelDescriptionScore) {\n            var labelDescriptionMatches = createMatches(labelDescriptionPositions);\n            var labelMatch_1 = [];\n            var descriptionMatch_1 = [];\n            // We have to split the matches back onto the label and description portions\n            labelDescriptionMatches.forEach(function (h) {\n                // Match overlaps label and description part, we need to split it up\n                if (h.start < descriptionPrefixLength_1 && h.end > descriptionPrefixLength_1) {\n                    labelMatch_1.push({ start: 0, end: h.end - descriptionPrefixLength_1 });\n                    descriptionMatch_1.push({ start: h.start, end: descriptionPrefixLength_1 });\n                }\n                // Match on label part\n                else if (h.start >= descriptionPrefixLength_1) {\n                    labelMatch_1.push({ start: h.start - descriptionPrefixLength_1, end: h.end - descriptionPrefixLength_1 });\n                }\n                // Match on description part\n                else {\n                    descriptionMatch_1.push(h);\n                }\n            });\n            return { score: labelDescriptionScore, labelMatch: labelMatch_1, descriptionMatch: descriptionMatch_1 };\n        }\n    }\n    return NO_ITEM_SCORE;\n}\nfunction compareItemsByScore(itemA, itemB, query, fuzzy, accessor, cache, fallbackComparer) {\n    if (fallbackComparer === void 0) { fallbackComparer = fallbackCompare; }\n    var itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);\n    var itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);\n    var scoreA = itemScoreA.score;\n    var scoreB = itemScoreB.score;\n    // 1.) prefer identity matches\n    if (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n        if (scoreA !== scoreB) {\n            return scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n        }\n    }\n    // 2.) prefer label prefix matches\n    if (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {\n        if (scoreA !== scoreB) {\n            return scoreA === LABEL_PREFIX_SCORE ? -1 : 1;\n        }\n        var labelA = accessor.getItemLabel(itemA) || '';\n        var labelB = accessor.getItemLabel(itemB) || '';\n        // prefer shorter names when both match on label prefix\n        if (labelA.length !== labelB.length) {\n            return labelA.length - labelB.length;\n        }\n    }\n    // 3.) prefer camelcase matches\n    if (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {\n        if (scoreA !== scoreB) {\n            return scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;\n        }\n        var labelA = accessor.getItemLabel(itemA) || '';\n        var labelB = accessor.getItemLabel(itemB) || '';\n        // prefer more compact camel case matches over longer\n        var comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n        if (comparedByMatchLength !== 0) {\n            return comparedByMatchLength;\n        }\n        // prefer shorter names when both match on label camelcase\n        if (labelA.length !== labelB.length) {\n            return labelA.length - labelB.length;\n        }\n    }\n    // 4.) prefer label scores\n    if (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n        if (scoreB < LABEL_SCORE_THRESHOLD) {\n            return -1;\n        }\n        if (scoreA < LABEL_SCORE_THRESHOLD) {\n            return 1;\n        }\n    }\n    // 5.) compare by score\n    if (scoreA !== scoreB) {\n        return scoreA > scoreB ? -1 : 1;\n    }\n    // 6.) scores are identical, prefer more compact matches (label and description)\n    var itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n    var itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n    if (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n        return itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n    }\n    // 7.) at this point, scores are identical and match compactness as well\n    // for both items so we start to use the fallback compare\n    return fallbackComparer(itemA, itemB, query, accessor);\n}\nexports.compareItemsByScore = compareItemsByScore;\nfunction computeLabelAndDescriptionMatchDistance(item, score, accessor) {\n    var matchStart = -1;\n    var matchEnd = -1;\n    // If we have description matches, the start is first of description match\n    if (score.descriptionMatch && score.descriptionMatch.length) {\n        matchStart = score.descriptionMatch[0].start;\n    }\n    // Otherwise, the start is the first label match\n    else if (score.labelMatch && score.labelMatch.length) {\n        matchStart = score.labelMatch[0].start;\n    }\n    // If we have label match, the end is the last label match\n    // If we had a description match, we add the length of the description\n    // as offset to the end to indicate this.\n    if (score.labelMatch && score.labelMatch.length) {\n        matchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n        if (score.descriptionMatch && score.descriptionMatch.length) {\n            var itemDescription = accessor.getItemDescription(item);\n            if (itemDescription) {\n                matchEnd += itemDescription.length;\n            }\n        }\n    }\n    // If we have just a description match, the end is the last description match\n    else if (score.descriptionMatch && score.descriptionMatch.length) {\n        matchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n    }\n    return matchEnd - matchStart;\n}\nfunction compareByMatchLength(matchesA, matchesB) {\n    if ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n        return 0; // make sure to not cause bad comparing when matches are not provided\n    }\n    if (!matchesB || !matchesB.length) {\n        return -1;\n    }\n    if (!matchesA || !matchesA.length) {\n        return 1;\n    }\n    // Compute match length of A (first to last match)\n    var matchStartA = matchesA[0].start;\n    var matchEndA = matchesA[matchesA.length - 1].end;\n    var matchLengthA = matchEndA - matchStartA;\n    // Compute match length of B (first to last match)\n    var matchStartB = matchesB[0].start;\n    var matchEndB = matchesB[matchesB.length - 1].end;\n    var matchLengthB = matchEndB - matchStartB;\n    // Prefer shorter match length\n    return matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\nfunction fallbackCompare(itemA, itemB, query, accessor) {\n    // check for label + description length and prefer shorter\n    var labelA = accessor.getItemLabel(itemA) || '';\n    var labelB = accessor.getItemLabel(itemB) || '';\n    var descriptionA = accessor.getItemDescription(itemA);\n    var descriptionB = accessor.getItemDescription(itemB);\n    var labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n    var labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n    if (labelDescriptionALength !== labelDescriptionBLength) {\n        return labelDescriptionALength - labelDescriptionBLength;\n    }\n    // check for path length and prefer shorter\n    var pathA = accessor.getItemPath(itemA);\n    var pathB = accessor.getItemPath(itemB);\n    if (pathA && pathB && pathA.length !== pathB.length) {\n        return pathA.length - pathB.length;\n    }\n    // 7.) finally we have equal scores and equal length, we fallback to comparer\n    // compare by label\n    if (labelA !== labelB) {\n        return comparers_1.compareAnything(labelA, labelB, query.value);\n    }\n    // compare by description\n    if (descriptionA && descriptionB && descriptionA !== descriptionB) {\n        return comparers_1.compareAnything(descriptionA, descriptionB, query.value);\n    }\n    // compare by path\n    if (pathA && pathB && pathA !== pathB) {\n        return comparers_1.compareAnything(pathA, pathB, query.value);\n    }\n    // equal\n    return 0;\n}\nexports.fallbackCompare = fallbackCompare;\n",{"version":3,"file":"/home/coding/workspace/lib/vscode/src/vs/base/parts/quickopen/common/quickOpenScorer.ts","sourceRoot":"","sources":["/home/coding/workspace/lib/vscode/src/vs/base/parts/quickopen/common/quickOpenScorer.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareAnything } from 'vs/base/common/comparers';\nimport { matchesPrefix, IMatch, matchesCamelCase, isUpper } from 'vs/base/common/filters';\nimport { sep } from 'vs/base/common/path';\nimport { isWindows, isLinux } from 'vs/base/common/platform';\nimport { stripWildcards, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport type Score = [number /* score */, number[] /* match positions */];\nexport type ScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: Score = [NO_MATCH, []];\n\n// const DEBUG = false;\n// const DEBUG_MATRIX = false;\n\nexport function score(target: string, query: string, queryLower: string, fuzzy: boolean): Score {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\n\t// When not searching fuzzy, we require the query to be contained fully\n\t// in the target string contiguously.\n\tif (!fuzzy) {\n\t\tconst indexOfQueryInTarget = targetLower.indexOf(queryLower);\n\t\tif (indexOfQueryInTarget === -1) {\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`Characters not matching consecutively ${queryLower} within ${targetLower}`);\n\t\t\t// }\n\n\t\t\treturn NO_SCORE;\n\t\t}\n\t}\n\n\tconst res = doScore(query, queryLower, queryLength, target, targetLower, targetLength);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScore(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number): Score {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tif (score && diagScore + score >= leftScore) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// printMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (queryLowerCharAtIndex !== targetLower[targetIndex]) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cCharacter match bonus: +1 (char: ${queryLower[queryIndex]} at index ${targetIndex}, total score: ${score})`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (matchesSequenceLength * 5);\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Consecutive match bonus: ' + (matchesSequenceLength * 5));\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('After separtor bonus: +4');\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case)\n\t\telse if (isUpper(target.charCodeAt(targetIndex))) {\n\t\t\tscore += 1;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +1');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE: IItemScore = Object.freeze({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | null;\n\n\t/**\n\t * The optional description of the item to score on. Can be null.\n\t */\n\tgetItemDescription(item: T): string | null;\n\n\t/**\n\t * If the item is a file, the path of the file to score on. Can be null.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE = 1 << 17;\nconst LABEL_CAMELCASE_SCORE = 1 << 16;\nconst LABEL_SCORE_THRESHOLD = 1 << 15;\n\nexport interface IPreparedQuery {\n\toriginal: string;\n\tvalue: string;\n\tlowercase: string;\n\tcontainsPathSeparator: boolean;\n}\n\n/**\n * Helper function to prepare a search value for scoring in quick open by removing unwanted characters.\n */\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (!original) {\n\t\toriginal = '';\n\t}\n\n\tlet value = stripWildcards(original).replace(/\\s/g, ''); // get rid of all wildcards and whitespace\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t}\n\n\tconst lowercase = value.toLowerCase();\n\tconst containsPathSeparator = value.indexOf(sep) >= 0;\n\n\treturn { original, value, lowercase, containsPathSeparator };\n}\n\nexport function scoreItem<T>(item: T, query: IPreparedQuery, fuzzy: boolean, accessor: IItemAccessor<T>, cache: ScorerCache): IItemScore {\n\tif (!item || !query.value) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\tlet cacheHash: string;\n\tif (description) {\n\t\tcacheHash = `${label}${description}${query.value}${fuzzy}`;\n\t} else {\n\t\tcacheHash = `${label}${query.value}${fuzzy}`;\n\t}\n\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItem(label, description, accessor.getItemPath(item), query, fuzzy);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction createMatches(offsets: undefined | number[]): IMatch[] {\n\tlet ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\treturn ret;\n}\n\nfunction doScoreItem(label: string, description: string | null, path: string | undefined, query: IPreparedQuery, fuzzy: boolean): IItemScore {\n\n\t// 1.) treat identity matches on full path highest\n\tif (path && (isLinux ? query.original === path : equalsIgnoreCase(query.original, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// We only consider label matches if the query is not including file path separators\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\tif (preferLabelMatches) {\n\n\t\t// 2.) treat prefix matches on the label second highest\n\t\tconst prefixLabelMatch = matchesPrefix(query.value, label);\n\t\tif (prefixLabelMatch) {\n\t\t\treturn { score: LABEL_PREFIX_SCORE, labelMatch: prefixLabelMatch };\n\t\t}\n\n\t\t// 3.) treat camelcase matches on the label third highest\n\t\tconst camelcaseLabelMatch = matchesCamelCase(query.value, label);\n\t\tif (camelcaseLabelMatch) {\n\t\t\treturn { score: LABEL_CAMELCASE_SCORE, labelMatch: camelcaseLabelMatch };\n\t\t}\n\n\t\t// 4.) prefer scores on the label if any\n\t\tconst [labelScore, labelPositions] = score(label, query.value, query.lowercase, fuzzy);\n\t\tif (labelScore) {\n\t\t\treturn { score: labelScore + LABEL_SCORE_THRESHOLD, labelMatch: createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// 5.) finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = score(descriptionAndLabel, query.value, query.lowercase, fuzzy);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nexport function compareItemsByScore<T>(itemA: T, itemB: T, query: IPreparedQuery, fuzzy: boolean, accessor: IItemAccessor<T>, cache: ScorerCache, fallbackComparer = fallbackCompare): number {\n\tconst itemScoreA = scoreItem(itemA, query, fuzzy, accessor, cache);\n\tconst itemScoreB = scoreItem(itemB, query, fuzzy, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) prefer identity matches\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) prefer label prefix matches\n\tif (scoreA === LABEL_PREFIX_SCORE || scoreB === LABEL_PREFIX_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === LABEL_PREFIX_SCORE ? -1 : 1;\n\t\t}\n\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\t\t// prefer shorter names when both match on label prefix\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) prefer camelcase matches\n\tif (scoreA === LABEL_CAMELCASE_SCORE || scoreB === LABEL_CAMELCASE_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === LABEL_CAMELCASE_SCORE ? -1 : 1;\n\t\t}\n\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\t\t// prefer more compact camel case matches over longer\n\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\tif (comparedByMatchLength !== 0) {\n\t\t\treturn comparedByMatchLength;\n\t\t}\n\n\t\t// prefer shorter names when both match on label camelcase\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 4.) prefer label scores\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreB < LABEL_SCORE_THRESHOLD) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (scoreA < LABEL_SCORE_THRESHOLD) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t// 5.) compare by score\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical, prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 7.) at this point, scores are identical and match compactness as well\n\t// for both items so we start to use the fallback compare\n\treturn fallbackComparer(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart: number = -1;\n\tlet matchEnd: number = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch && score.labelMatch.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch && score.labelMatch.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB || !matchesB.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA || !matchesA.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nexport function fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.value);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.value);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.value);\n\t}\n\n\t// equal\n\treturn 0;\n}\n"]}]}