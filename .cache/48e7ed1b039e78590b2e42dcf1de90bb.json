{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/services/label/common/labelService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/services/label/common/labelService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/base/common/uri\", \"vs/base/common/event\", \"vs/workbench/common/contributions\", \"vs/platform/registry/common/platform\", \"vs/platform/environment/common/environment\", \"vs/platform/workspace/common/workspace\", \"vs/base/common/resources\", \"vs/base/common/platform\", \"vs/base/common/labels\", \"vs/base/common/strings\", \"vs/platform/workspaces/common/workspaces\", \"vs/base/common/network\", \"vs/platform/label/common/label\", \"vs/workbench/services/extensions/common/extensionsRegistry\", \"vs/base/common/glob\", \"vs/platform/lifecycle/common/lifecycle\", \"vs/platform/instantiation/common/extensions\"], function (require, exports, nls_1, uri_1, event_1, contributions_1, platform_1, environment_1, workspace_1, resources_1, platform_2, labels_1, strings_1, workspaces_1, network_1, label_1, extensionsRegistry_1, glob_1, lifecycle_1, extensions_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const resourceLabelFormattersExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint({\n        extensionPoint: 'resourceLabelFormatters',\n        jsonSchema: {\n            description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters', 'Contributes resource label formatting rules.'),\n            type: 'array',\n            items: {\n                type: 'object',\n                required: ['scheme', 'formatting'],\n                properties: {\n                    scheme: {\n                        type: 'string',\n                        description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.scheme', 'URI scheme on which to match the formatter on. For example \"file\". Simple glob patterns are supported.'),\n                    },\n                    authority: {\n                        type: 'string',\n                        description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.authority', 'URI authority on which to match the formatter on. Simple glob patterns are supported.'),\n                    },\n                    formatting: {\n                        description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.formatting', \"Rules for formatting uri resource labels.\"),\n                        type: 'object',\n                        properties: {\n                            label: {\n                                type: 'string',\n                                description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.label', \"Label rules to display. For example: myLabel:/${path}. ${path}, ${scheme} and ${authority} are supported as variables.\")\n                            },\n                            separator: {\n                                type: 'string',\n                                description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.separator', \"Separator to be used in the uri label display. '/' or '\\' as an example.\")\n                            },\n                            tildify: {\n                                type: 'boolean',\n                                description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.tildify', \"Controls if the start of the uri label should be tildified when possible.\")\n                            },\n                            workspaceSuffix: {\n                                type: 'string',\n                                description: nls_1.localize('vscode.extension.contributes.resourceLabelFormatters.formatting.workspaceSuffix', \"Suffix appended to the workspace label.\")\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    });\n    const sepRegexp = /\\//g;\n    const labelMatchingRegexp = /\\$\\{scheme\\}|\\$\\{authority\\}|\\$\\{path\\}/g;\n    function hasDriveLetter(path) {\n        return !!(platform_2.isWindows && path && path[2] === ':');\n    }\n    let ResourceLabelFormattersHandler = class ResourceLabelFormattersHandler {\n        constructor(labelService) {\n            this.formattersDisposables = new Map();\n            resourceLabelFormattersExtPoint.setHandler((extensions, delta) => {\n                delta.added.forEach(added => added.value.forEach(formatter => {\n                    this.formattersDisposables.set(formatter, labelService.registerFormatter(formatter));\n                }));\n                delta.removed.forEach(removed => removed.value.forEach(formatter => {\n                    this.formattersDisposables.get(formatter).dispose();\n                }));\n            });\n        }\n    };\n    ResourceLabelFormattersHandler = __decorate([\n        __param(0, label_1.ILabelService)\n    ], ResourceLabelFormattersHandler);\n    platform_1.Registry.as(contributions_1.Extensions.Workbench).registerWorkbenchContribution(ResourceLabelFormattersHandler, lifecycle_1.LifecyclePhase.Restored);\n    let LabelService = class LabelService {\n        constructor(environmentService, contextService) {\n            this.environmentService = environmentService;\n            this.contextService = contextService;\n            this.formatters = [];\n            this._onDidChangeFormatters = new event_1.Emitter();\n        }\n        get onDidChangeFormatters() {\n            return this._onDidChangeFormatters.event;\n        }\n        findFormatting(resource) {\n            let bestResult;\n            this.formatters.forEach(formatter => {\n                if (formatter.scheme === resource.scheme) {\n                    if (!bestResult && !formatter.authority) {\n                        bestResult = formatter;\n                        return;\n                    }\n                    if (!formatter.authority) {\n                        return;\n                    }\n                    if (glob_1.match(formatter.authority, resource.authority) && (!bestResult || !bestResult.authority || formatter.authority.length > bestResult.authority.length || ((formatter.authority.length === bestResult.authority.length) && formatter.priority))) {\n                        bestResult = formatter;\n                    }\n                }\n            });\n            return bestResult ? bestResult.formatting : undefined;\n        }\n        getUriLabel(resource, options = {}) {\n            const formatting = this.findFormatting(resource);\n            if (!formatting) {\n                return labels_1.getPathLabel(resource.path, this.environmentService, options.relative ? this.contextService : undefined);\n            }\n            let label;\n            const baseResource = this.contextService && this.contextService.getWorkspaceFolder(resource);\n            if (options.relative && baseResource) {\n                let relativeLabel;\n                if (resources_1.isEqual(baseResource.uri, resource)) {\n                    relativeLabel = ''; // no label if resources are identical\n                }\n                else {\n                    const baseResourceLabel = this.formatUri(baseResource.uri, formatting, options.noPrefix);\n                    relativeLabel = strings_1.ltrim(this.formatUri(resource, formatting, options.noPrefix).substring(baseResourceLabel.length), formatting.separator);\n                }\n                const hasMultipleRoots = this.contextService.getWorkspace().folders.length > 1;\n                if (hasMultipleRoots && !options.noPrefix) {\n                    const rootName = (baseResource && baseResource.name) ? baseResource.name : resources_1.basenameOrAuthority(baseResource.uri);\n                    relativeLabel = relativeLabel ? (rootName + ' â€¢ ' + relativeLabel) : rootName; // always show root basename if there are multiple\n                }\n                label = relativeLabel;\n            }\n            else {\n                label = this.formatUri(resource, formatting, options.noPrefix);\n            }\n            return options.endWithSeparator ? this.appendSeparatorIfMissing(label, formatting) : label;\n        }\n        getWorkspaceLabel(workspace, options) {\n            if (!workspaces_1.isWorkspaceIdentifier(workspace) && !workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {\n                const identifier = workspaces_1.toWorkspaceIdentifier(workspace);\n                if (!identifier) {\n                    return '';\n                }\n                workspace = identifier;\n            }\n            // Workspace: Single Folder\n            if (workspaces_1.isSingleFolderWorkspaceIdentifier(workspace)) {\n                // Folder on disk\n                const label = options && options.verbose ? this.getUriLabel(workspace) : resources_1.basename(workspace) || '/';\n                return this.appendWorkspaceSuffix(label, workspace);\n            }\n            // Workspace: Untitled\n            if (resources_1.isEqualOrParent(workspace.configPath, this.environmentService.untitledWorkspacesHome)) {\n                return nls_1.localize('untitledWorkspace', \"Untitled (Workspace)\");\n            }\n            // Workspace: Saved\n            const filename = resources_1.basename(workspace.configPath);\n            const workspaceName = filename.substr(0, filename.length - workspaces_1.WORKSPACE_EXTENSION.length - 1);\n            let label;\n            if (options && options.verbose) {\n                label = nls_1.localize('workspaceNameVerbose', \"{0} (Workspace)\", this.getUriLabel(resources_1.joinPath(resources_1.dirname(workspace.configPath), workspaceName)));\n            }\n            else {\n                label = nls_1.localize('workspaceName', \"{0} (Workspace)\", workspaceName);\n            }\n            return this.appendWorkspaceSuffix(label, workspace.configPath);\n        }\n        getSeparator(scheme, authority) {\n            const formatter = this.findFormatting(uri_1.URI.from({ scheme, authority }));\n            return formatter && formatter.separator || '/';\n        }\n        getHostLabel(scheme, authority) {\n            const formatter = this.findFormatting(uri_1.URI.from({ scheme, authority }));\n            return formatter && formatter.workspaceSuffix || '';\n        }\n        registerFormatter(formatter) {\n            this.formatters.push(formatter);\n            this._onDidChangeFormatters.fire();\n            return {\n                dispose: () => {\n                    this.formatters = this.formatters.filter(f => f !== formatter);\n                    this._onDidChangeFormatters.fire();\n                }\n            };\n        }\n        formatUri(resource, formatting, forceNoTildify) {\n            let label = formatting.label.replace(labelMatchingRegexp, match => {\n                switch (match) {\n                    case '${scheme}': return resource.scheme;\n                    case '${authority}': return resource.authority;\n                    case '${path}': return resource.path;\n                    default: return '';\n                }\n            });\n            // convert \\c:\\something => C:\\something\n            if (formatting.normalizeDriveLetter && hasDriveLetter(label)) {\n                label = label.charAt(1).toUpperCase() + label.substr(2);\n            }\n            if (formatting.tildify && !forceNoTildify) {\n                label = labels_1.tildify(label, this.environmentService.userHome);\n            }\n            if (formatting.authorityPrefix && resource.authority) {\n                label = formatting.authorityPrefix + label;\n            }\n            return label.replace(sepRegexp, formatting.separator);\n        }\n        appendSeparatorIfMissing(label, formatting) {\n            let appendedLabel = label;\n            if (!strings_1.endsWith(label, formatting.separator)) {\n                appendedLabel += formatting.separator;\n            }\n            return appendedLabel;\n        }\n        appendWorkspaceSuffix(label, uri) {\n            if (uri.scheme === network_1.Schemas.file) {\n                return label;\n            }\n            const formatting = this.findFormatting(uri);\n            const suffix = formatting && (typeof formatting.workspaceSuffix === 'string') ? formatting.workspaceSuffix : uri.scheme;\n            return suffix ? `${label} [${suffix}]` : label;\n        }\n    };\n    LabelService = __decorate([\n        __param(0, environment_1.IEnvironmentService),\n        __param(1, workspace_1.IWorkspaceContextService)\n    ], LabelService);\n    exports.LabelService = LabelService;\n    extensions_1.registerSingleton(label_1.ILabelService, LabelService, true);\n});\n",null]}