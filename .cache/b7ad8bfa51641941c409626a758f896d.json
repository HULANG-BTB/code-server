{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/base/node/processes.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/base/node/processes.ts","mtime":1555102316000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/base/common/path\", \"fs\", \"child_process\", \"vs/nls\", \"vs/base/common/types\", \"vs/base/common/objects\", \"vs/base/common/extpath\", \"vs/base/common/platform\", \"vs/base/node/decoder\", \"vs/base/common/processes\", \"vs/base/common/amd\"], function (require, exports, path, fs, cp, nls, Types, Objects, extpath, Platform, decoder_1, processes_1, amd_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.CommandOptions = processes_1.CommandOptions;\n    exports.ForkOptions = processes_1.ForkOptions;\n    exports.SuccessData = processes_1.SuccessData;\n    exports.Source = processes_1.Source;\n    exports.TerminateResponse = processes_1.TerminateResponse;\n    exports.TerminateResponseCode = processes_1.TerminateResponseCode;\n    function getWindowsCode(status) {\n        switch (status) {\n            case 0:\n                return processes_1.TerminateResponseCode.Success;\n            case 1:\n                return processes_1.TerminateResponseCode.AccessDenied;\n            case 128:\n                return processes_1.TerminateResponseCode.ProcessNotFound;\n            default:\n                return processes_1.TerminateResponseCode.Unknown;\n        }\n    }\n    function terminateProcess(process, cwd) {\n        if (Platform.isWindows) {\n            try {\n                const options = {\n                    stdio: ['pipe', 'pipe', 'ignore']\n                };\n                if (cwd) {\n                    options.cwd = cwd;\n                }\n                cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);\n            }\n            catch (err) {\n                return { success: false, error: err, code: err.status ? getWindowsCode(err.status) : processes_1.TerminateResponseCode.Unknown };\n            }\n        }\n        else if (Platform.isLinux || Platform.isMacintosh) {\n            try {\n                const cmd = amd_1.getPathFromAmdModule(require, 'vs/base/node/terminateProcess.sh');\n                const result = cp.spawnSync(cmd, [process.pid.toString()]);\n                if (result.error) {\n                    return { success: false, error: result.error };\n                }\n            }\n            catch (err) {\n                return { success: false, error: err };\n            }\n        }\n        else {\n            process.kill('SIGKILL');\n        }\n        return { success: true };\n    }\n    exports.terminateProcess = terminateProcess;\n    function getWindowsShell() {\n        return process.env['comspec'] || 'cmd.exe';\n    }\n    exports.getWindowsShell = getWindowsShell;\n    class AbstractProcess {\n        constructor(arg1, arg2, arg3, arg4) {\n            if (arg2 !== undefined && arg3 !== undefined && arg4 !== undefined) {\n                this.cmd = arg1;\n                this.args = arg2;\n                this.shell = arg3;\n                this.options = arg4;\n            }\n            else {\n                const executable = arg1;\n                this.cmd = executable.command;\n                this.shell = executable.isShellCommand;\n                this.args = executable.args.slice(0);\n                this.options = executable.options || {};\n            }\n            this.childProcess = null;\n            this.terminateRequested = false;\n            if (this.options.env) {\n                const newEnv = Object.create(null);\n                Object.keys(process.env).forEach((key) => {\n                    newEnv[key] = process.env[key];\n                });\n                Object.keys(this.options.env).forEach((key) => {\n                    newEnv[key] = this.options.env[key];\n                });\n                this.options.env = newEnv;\n            }\n        }\n        getSanitizedCommand() {\n            let result = this.cmd.toLowerCase();\n            const index = result.lastIndexOf(path.sep);\n            if (index !== -1) {\n                result = result.substring(index + 1);\n            }\n            if (AbstractProcess.WellKnowCommands[result]) {\n                return result;\n            }\n            return 'other';\n        }\n        start(pp) {\n            if (Platform.isWindows && ((this.options && this.options.cwd && extpath.isUNC(this.options.cwd)) || !this.options && extpath.isUNC(process.cwd()))) {\n                return Promise.reject(new Error(nls.localize('TaskRunner.UNC', 'Can\\'t execute a shell command on a UNC drive.')));\n            }\n            return this.useExec().then((useExec) => {\n                let cc;\n                let ee;\n                const result = new Promise((c, e) => {\n                    cc = c;\n                    ee = e;\n                });\n                if (useExec) {\n                    let cmd = this.cmd;\n                    if (this.args) {\n                        cmd = cmd + ' ' + this.args.join(' ');\n                    }\n                    this.childProcess = cp.exec(cmd, this.options, (error, stdout, stderr) => {\n                        this.childProcess = null;\n                        const err = error;\n                        // This is tricky since executing a command shell reports error back in case the executed command return an\n                        // error or the command didn't exist at all. So we can't blindly treat an error as a failed command. So we\n                        // always parse the output and report success unless the job got killed.\n                        if (err && err.killed) {\n                            ee({ killed: this.terminateRequested, stdout: stdout.toString(), stderr: stderr.toString() });\n                        }\n                        else {\n                            this.handleExec(cc, pp, error, stdout, stderr);\n                        }\n                    });\n                }\n                else {\n                    let childProcess = null;\n                    const closeHandler = (data) => {\n                        this.childProcess = null;\n                        this.childProcessPromise = null;\n                        this.handleClose(data, cc, pp, ee);\n                        const result = {\n                            terminated: this.terminateRequested\n                        };\n                        if (Types.isNumber(data)) {\n                            result.cmdCode = data;\n                        }\n                        cc(result);\n                    };\n                    if (this.shell && Platform.isWindows) {\n                        const options = Objects.deepClone(this.options);\n                        options.windowsVerbatimArguments = true;\n                        options.detached = false;\n                        let quotedCommand = false;\n                        let quotedArg = false;\n                        const commandLine = [];\n                        let quoted = this.ensureQuotes(this.cmd);\n                        commandLine.push(quoted.value);\n                        quotedCommand = quoted.quoted;\n                        if (this.args) {\n                            this.args.forEach((elem) => {\n                                quoted = this.ensureQuotes(elem);\n                                commandLine.push(quoted.value);\n                                quotedArg = quotedArg && quoted.quoted;\n                            });\n                        }\n                        const args = [\n                            '/s',\n                            '/c',\n                        ];\n                        if (quotedCommand) {\n                            if (quotedArg) {\n                                args.push('\"' + commandLine.join(' ') + '\"');\n                            }\n                            else if (commandLine.length > 1) {\n                                args.push('\"' + commandLine[0] + '\"' + ' ' + commandLine.slice(1).join(' '));\n                            }\n                            else {\n                                args.push('\"' + commandLine[0] + '\"');\n                            }\n                        }\n                        else {\n                            args.push(commandLine.join(' '));\n                        }\n                        childProcess = cp.spawn(getWindowsShell(), args, options);\n                    }\n                    else {\n                        if (this.cmd) {\n                            childProcess = cp.spawn(this.cmd, this.args, this.options);\n                        }\n                    }\n                    if (childProcess) {\n                        this.childProcess = childProcess;\n                        this.childProcessPromise = Promise.resolve(childProcess);\n                        if (this.pidResolve) {\n                            this.pidResolve(Types.isNumber(childProcess.pid) ? childProcess.pid : -1);\n                            this.pidResolve = undefined;\n                        }\n                        childProcess.on('error', (error) => {\n                            this.childProcess = null;\n                            ee({ terminated: this.terminateRequested, error: error });\n                        });\n                        if (childProcess.pid) {\n                            this.childProcess.on('close', closeHandler);\n                            this.handleSpawn(childProcess, cc, pp, ee, true);\n                        }\n                    }\n                }\n                return result;\n            });\n        }\n        handleClose(data, cc, pp, ee) {\n            // Default is to do nothing.\n        }\n        ensureQuotes(value) {\n            if (AbstractProcess.regexp.test(value)) {\n                return {\n                    value: '\"' + value + '\"',\n                    quoted: true\n                };\n            }\n            else {\n                return {\n                    value: value,\n                    quoted: value.length > 0 && value[0] === '\"' && value[value.length - 1] === '\"'\n                };\n            }\n        }\n        get pid() {\n            if (this.childProcessPromise) {\n                return this.childProcessPromise.then(childProcess => childProcess.pid, err => -1);\n            }\n            else {\n                return new Promise((resolve) => {\n                    this.pidResolve = resolve;\n                });\n            }\n        }\n        terminate() {\n            if (!this.childProcessPromise) {\n                return Promise.resolve({ success: true });\n            }\n            return this.childProcessPromise.then((childProcess) => {\n                this.terminateRequested = true;\n                const result = terminateProcess(childProcess, this.options.cwd);\n                if (result.success) {\n                    this.childProcess = null;\n                }\n                return result;\n            }, (err) => {\n                return { success: true };\n            });\n        }\n        useExec() {\n            return new Promise((c, e) => {\n                if (!this.shell || !Platform.isWindows) {\n                    return c(false);\n                }\n                const cmdShell = cp.spawn(getWindowsShell(), ['/s', '/c']);\n                cmdShell.on('error', (error) => {\n                    return c(true);\n                });\n                cmdShell.on('exit', (data) => {\n                    return c(false);\n                });\n            });\n        }\n    }\n    AbstractProcess.WellKnowCommands = {\n        'ant': true,\n        'cmake': true,\n        'eslint': true,\n        'gradle': true,\n        'grunt': true,\n        'gulp': true,\n        'jake': true,\n        'jenkins': true,\n        'jshint': true,\n        'make': true,\n        'maven': true,\n        'msbuild': true,\n        'msc': true,\n        'nmake': true,\n        'npm': true,\n        'rake': true,\n        'tsc': true,\n        'xbuild': true\n    };\n    AbstractProcess.regexp = /^[^\"].* .*[^\"]/;\n    exports.AbstractProcess = AbstractProcess;\n    class LineProcess extends AbstractProcess {\n        constructor(arg1, arg2, arg3, arg4) {\n            super(arg1, arg2, arg3, arg4);\n        }\n        handleExec(cc, pp, error, stdout, stderr) {\n            [stdout, stderr].forEach((buffer, index) => {\n                const lineDecoder = new decoder_1.LineDecoder();\n                const lines = lineDecoder.write(buffer);\n                lines.forEach((line) => {\n                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });\n                });\n                const line = lineDecoder.end();\n                if (line) {\n                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });\n                }\n            });\n            cc({ terminated: this.terminateRequested, error: error });\n        }\n        handleSpawn(childProcess, cc, pp, ee, sync) {\n            this.stdoutLineDecoder = new decoder_1.LineDecoder();\n            this.stderrLineDecoder = new decoder_1.LineDecoder();\n            childProcess.stdout.on('data', (data) => {\n                const lines = this.stdoutLineDecoder.write(data);\n                lines.forEach(line => pp({ line: line, source: processes_1.Source.stdout }));\n            });\n            childProcess.stderr.on('data', (data) => {\n                const lines = this.stderrLineDecoder.write(data);\n                lines.forEach(line => pp({ line: line, source: processes_1.Source.stderr }));\n            });\n        }\n        handleClose(data, cc, pp, ee) {\n            [this.stdoutLineDecoder.end(), this.stderrLineDecoder.end()].forEach((line, index) => {\n                if (line) {\n                    pp({ line: line, source: index === 0 ? processes_1.Source.stdout : processes_1.Source.stderr });\n                }\n            });\n        }\n    }\n    exports.LineProcess = LineProcess;\n    // Wrapper around process.send() that will queue any messages if the internal node.js\n    // queue is filled with messages and only continue sending messages when the internal\n    // queue is free again to consume messages.\n    // On Windows we always wait for the send() method to return before sending the next message\n    // to workaround https://github.com/nodejs/node/issues/7657 (IPC can freeze process)\n    function createQueuedSender(childProcess) {\n        let msgQueue = [];\n        let useQueue = false;\n        const send = function (msg) {\n            if (useQueue) {\n                msgQueue.push(msg); // add to the queue if the process cannot handle more messages\n                return;\n            }\n            const result = childProcess.send(msg, (error) => {\n                if (error) {\n                    console.error(error); // unlikely to happen, best we can do is log this error\n                }\n                useQueue = false; // we are good again to send directly without queue\n                // now send all the messages that we have in our queue and did not send yet\n                if (msgQueue.length > 0) {\n                    const msgQueueCopy = msgQueue.slice(0);\n                    msgQueue = [];\n                    msgQueueCopy.forEach(entry => send(entry));\n                }\n            });\n            if (!result || Platform.isWindows /* workaround https://github.com/nodejs/node/issues/7657 */) {\n                useQueue = true;\n            }\n        };\n        return { send };\n    }\n    exports.createQueuedSender = createQueuedSender;\n    var win32;\n    (function (win32) {\n        function findExecutable(command, cwd, paths) {\n            // If we have an absolute path then we take it.\n            if (path.isAbsolute(command)) {\n                return command;\n            }\n            if (cwd === undefined) {\n                cwd = process.cwd();\n            }\n            const dir = path.dirname(command);\n            if (dir !== '.') {\n                // We have a directory and the directory is relative (see above). Make the path absolute\n                // to the current working directory.\n                return path.join(cwd, command);\n            }\n            if (paths === undefined && Types.isString(process.env.PATH)) {\n                paths = process.env.PATH.split(path.delimiter);\n            }\n            // No PATH environment. Make path absolute to the cwd.\n            if (paths === undefined || paths.length === 0) {\n                return path.join(cwd, command);\n            }\n            // We have a simple file name. We get the path variable from the env\n            // and try to find the executable on the path.\n            for (let pathEntry of paths) {\n                // The path entry is absolute.\n                let fullPath;\n                if (path.isAbsolute(pathEntry)) {\n                    fullPath = path.join(pathEntry, command);\n                }\n                else {\n                    fullPath = path.join(cwd, pathEntry, command);\n                }\n                if (fs.existsSync(fullPath)) {\n                    return fullPath;\n                }\n                let withExtension = fullPath + '.com';\n                if (fs.existsSync(withExtension)) {\n                    return withExtension;\n                }\n                withExtension = fullPath + '.exe';\n                if (fs.existsSync(withExtension)) {\n                    return withExtension;\n                }\n            }\n            return path.join(cwd, command);\n        }\n        win32.findExecutable = findExecutable;\n    })(win32 = exports.win32 || (exports.win32 = {}));\n});\n",null]}