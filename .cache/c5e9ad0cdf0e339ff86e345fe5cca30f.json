{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/webview/electron-browser/webviewEditorService.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/contrib/webview/electron-browser/webviewEditorService.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\ndefine([\"require\", \"exports\", \"vs/base/common/arrays\", \"vs/base/common/lifecycle\", \"vs/base/common/map\", \"vs/platform/instantiation/common/instantiation\", \"vs/workbench/services/editor/common/editorGroupsService\", \"vs/workbench/services/editor/common/editorService\", \"./webviewEditorInput\"], function (require, exports, arrays_1, lifecycle_1, map_1, instantiation_1, editorGroupsService_1, editorService_1, webviewEditorInput_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.IWebviewEditorService = instantiation_1.createDecorator('webviewEditorService');\n    function areWebviewInputOptionsEqual(a, b) {\n        return a.enableCommandUris === b.enableCommandUris\n            && a.enableFindWidget === b.enableFindWidget\n            && a.enableScripts === b.enableScripts\n            && a.retainContextWhenHidden === b.retainContextWhenHidden\n            && a.tryRestoreScrollPosition === b.tryRestoreScrollPosition\n            && (a.localResourceRoots === b.localResourceRoots || (Array.isArray(a.localResourceRoots) && Array.isArray(b.localResourceRoots) && arrays_1.equals(a.localResourceRoots, b.localResourceRoots, (a, b) => a.toString() === b.toString())))\n            && (a.portMapping === b.portMapping || (Array.isArray(a.portMapping) && Array.isArray(b.portMapping) && arrays_1.equals(a.portMapping, b.portMapping, (a, b) => a.from === b.from && a.to === b.to)));\n    }\n    exports.areWebviewInputOptionsEqual = areWebviewInputOptionsEqual;\n    function canRevive(reviver, webview) {\n        if (webview.isDisposed()) {\n            return false;\n        }\n        return reviver.canRevive(webview);\n    }\n    class RevivalPool {\n        constructor() {\n            this._awaitingRevival = [];\n        }\n        add(input, resolve) {\n            this._awaitingRevival.push({ input, resolve });\n        }\n        reviveFor(reviver) {\n            const toRevive = this._awaitingRevival.filter(({ input }) => canRevive(reviver, input));\n            this._awaitingRevival = this._awaitingRevival.filter(({ input }) => !canRevive(reviver, input));\n            for (const { input, resolve } of toRevive) {\n                reviver.reviveWebview(input).then(resolve);\n            }\n        }\n    }\n    let WebviewEditorService = class WebviewEditorService {\n        constructor(_editorService, _instantiationService, _editorGroupService) {\n            this._editorService = _editorService;\n            this._instantiationService = _instantiationService;\n            this._editorGroupService = _editorGroupService;\n            this._revivers = new Set();\n            this._revivalPool = new RevivalPool();\n        }\n        createWebview(viewType, title, showOptions, options, extension, events) {\n            const webviewInput = this._instantiationService.createInstance(webviewEditorInput_1.WebviewEditorInput, viewType, undefined, title, options, {}, events, extension);\n            this._editorService.openEditor(webviewInput, { pinned: true, preserveFocus: showOptions.preserveFocus }, showOptions.group);\n            return webviewInput;\n        }\n        revealWebview(webview, group, preserveFocus) {\n            if (webview.group === group.id) {\n                this._editorService.openEditor(webview, { preserveFocus }, webview.group);\n            }\n            else {\n                const groupView = this._editorGroupService.getGroup(webview.group);\n                if (groupView) {\n                    groupView.moveEditor(webview, group, { preserveFocus });\n                }\n            }\n        }\n        reviveWebview(viewType, id, title, iconPath, state, options, extension, group) {\n            const webviewInput = this._instantiationService.createInstance(webviewEditorInput_1.RevivedWebviewEditorInput, viewType, id, title, options, state, {}, extension, (webview) => __awaiter(this, void 0, void 0, function* () {\n                const didRevive = yield this.tryRevive(webview);\n                if (didRevive) {\n                    return Promise.resolve(undefined);\n                }\n                // A reviver may not be registered yet. Put into pool and resolve promise when we can revive\n                let resolve;\n                const promise = new Promise(r => { resolve = r; });\n                this._revivalPool.add(webview, resolve);\n                return promise;\n            }));\n            webviewInput.iconPath = iconPath;\n            if (typeof group === 'number') {\n                webviewInput.updateGroup(group);\n            }\n            return webviewInput;\n        }\n        registerReviver(reviver) {\n            this._revivers.add(reviver);\n            this._revivalPool.reviveFor(reviver);\n            return lifecycle_1.toDisposable(() => {\n                this._revivers.delete(reviver);\n            });\n        }\n        shouldPersist(webview) {\n            // Has no state, don't persist\n            if (!webview.state) {\n                return false;\n            }\n            if (map_1.values(this._revivers).some(reviver => canRevive(reviver, webview))) {\n                return true;\n            }\n            // Revived webviews may not have an actively registered reviver but we still want to presist them\n            // since a reviver should exist when it is actually needed.\n            return webview instanceof webviewEditorInput_1.RevivedWebviewEditorInput;\n        }\n        tryRevive(webview) {\n            return __awaiter(this, void 0, void 0, function* () {\n                for (const reviver of map_1.values(this._revivers)) {\n                    if (canRevive(reviver, webview)) {\n                        yield reviver.reviveWebview(webview);\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n    };\n    WebviewEditorService = __decorate([\n        __param(0, editorService_1.IEditorService),\n        __param(1, instantiation_1.IInstantiationService),\n        __param(2, editorGroupsService_1.IEditorGroupsService)\n    ], WebviewEditorService);\n    exports.WebviewEditorService = WebviewEditorService;\n});\n",null]}