{"remainingRequest":"/home/coding/workspace/node_modules/ts-loader/index.js?{\"happyPackMode\":true,\"compilerOptions\":{\"target\":\"es6\"}}!/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostExtensionActivator.ts","dependencies":[{"path":"/home/coding/workspace/lib/vscode/src/vs/workbench/api/node/extHostExtensionActivator.ts","mtime":1555102317000},{"path":"/home/coding/workspace/node_modules/cache-loader/dist/cjs.js","mtime":1555844183884},{"path":"/home/coding/workspace/node_modules/ts-loader/index.js","mtime":1555844217316}],"contextDependencies":[],"result":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\ndefine([\"require\", \"exports\", \"vs/nls\", \"vs/platform/extensions/common/extensions\", \"vs/workbench/services/extensions/common/extensions\"], function (require, exports, nls, extensions_1, extensions_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    const NO_OP_VOID_PROMISE = Promise.resolve(undefined);\n    /* __GDPR__FRAGMENT__\n        \"ExtensionActivationTimes\" : {\n            \"startup\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n            \"codeLoadingTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n            \"activateCallTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true },\n            \"activateResolvedTime\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n        }\n    */\n    class ExtensionActivationTimes {\n        constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {\n            this.startup = startup;\n            this.codeLoadingTime = codeLoadingTime;\n            this.activateCallTime = activateCallTime;\n            this.activateResolvedTime = activateResolvedTime;\n        }\n    }\n    ExtensionActivationTimes.NONE = new ExtensionActivationTimes(false, -1, -1, -1);\n    exports.ExtensionActivationTimes = ExtensionActivationTimes;\n    class ExtensionActivationTimesBuilder {\n        constructor(startup) {\n            this._startup = startup;\n            this._codeLoadingStart = -1;\n            this._codeLoadingStop = -1;\n            this._activateCallStart = -1;\n            this._activateCallStop = -1;\n            this._activateResolveStart = -1;\n            this._activateResolveStop = -1;\n        }\n        _delta(start, stop) {\n            if (start === -1 || stop === -1) {\n                return -1;\n            }\n            return stop - start;\n        }\n        build() {\n            return new ExtensionActivationTimes(this._startup, this._delta(this._codeLoadingStart, this._codeLoadingStop), this._delta(this._activateCallStart, this._activateCallStop), this._delta(this._activateResolveStart, this._activateResolveStop));\n        }\n        codeLoadingStart() {\n            this._codeLoadingStart = Date.now();\n        }\n        codeLoadingStop() {\n            this._codeLoadingStop = Date.now();\n        }\n        activateCallStart() {\n            this._activateCallStart = Date.now();\n        }\n        activateCallStop() {\n            this._activateCallStop = Date.now();\n        }\n        activateResolveStart() {\n            this._activateResolveStart = Date.now();\n        }\n        activateResolveStop() {\n            this._activateResolveStop = Date.now();\n        }\n    }\n    exports.ExtensionActivationTimesBuilder = ExtensionActivationTimesBuilder;\n    class ActivatedExtension {\n        constructor(activationFailed, activationFailedError, activationTimes, module, exports, subscriptions) {\n            this.activationFailed = activationFailed;\n            this.activationFailedError = activationFailedError;\n            this.activationTimes = activationTimes;\n            this.module = module;\n            this.exports = exports;\n            this.subscriptions = subscriptions;\n        }\n    }\n    exports.ActivatedExtension = ActivatedExtension;\n    class EmptyExtension extends ActivatedExtension {\n        constructor(activationTimes) {\n            super(false, null, activationTimes, { activate: undefined, deactivate: undefined }, undefined, []);\n        }\n    }\n    exports.EmptyExtension = EmptyExtension;\n    class HostExtension extends ActivatedExtension {\n        constructor() {\n            super(false, null, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, []);\n        }\n    }\n    exports.HostExtension = HostExtension;\n    class FailedExtension extends ActivatedExtension {\n        constructor(activationError) {\n            super(true, activationError, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, []);\n        }\n    }\n    exports.FailedExtension = FailedExtension;\n    class ExtensionActivatedByEvent {\n        constructor(startup, activationEvent) {\n            this.startup = startup;\n            this.activationEvent = activationEvent;\n        }\n    }\n    exports.ExtensionActivatedByEvent = ExtensionActivatedByEvent;\n    class ExtensionActivatedByAPI {\n        constructor(startup) {\n            this.startup = startup;\n        }\n    }\n    exports.ExtensionActivatedByAPI = ExtensionActivatedByAPI;\n    class ExtensionsActivator {\n        constructor(registry, resolvedExtensions, hostExtensions, host) {\n            this._registry = registry;\n            this._resolvedExtensionsSet = new Set();\n            resolvedExtensions.forEach((extensionId) => this._resolvedExtensionsSet.add(extensions_1.ExtensionIdentifier.toKey(extensionId)));\n            this._hostExtensionsMap = new Map();\n            hostExtensions.forEach((extensionId) => this._hostExtensionsMap.set(extensions_1.ExtensionIdentifier.toKey(extensionId), extensionId));\n            this._host = host;\n            this._activatingExtensions = new Map();\n            this._activatedExtensions = new Map();\n            this._alreadyActivatedEvents = Object.create(null);\n        }\n        isActivated(extensionId) {\n            const extensionKey = extensions_1.ExtensionIdentifier.toKey(extensionId);\n            return this._activatedExtensions.has(extensionKey);\n        }\n        getActivatedExtension(extensionId) {\n            const extensionKey = extensions_1.ExtensionIdentifier.toKey(extensionId);\n            const activatedExtension = this._activatedExtensions.get(extensionKey);\n            if (!activatedExtension) {\n                throw new Error('Extension `' + extensionId.value + '` is not known or not activated');\n            }\n            return activatedExtension;\n        }\n        activateByEvent(activationEvent, reason) {\n            if (this._alreadyActivatedEvents[activationEvent]) {\n                return NO_OP_VOID_PROMISE;\n            }\n            const activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);\n            return this._activateExtensions(activateExtensions.map(e => e.identifier), reason).then(() => {\n                this._alreadyActivatedEvents[activationEvent] = true;\n            });\n        }\n        activateById(extensionId, reason) {\n            const desc = this._registry.getExtensionDescription(extensionId);\n            if (!desc) {\n                throw new Error('Extension `' + extensionId + '` is not known');\n            }\n            return this._activateExtensions([desc.identifier], reason);\n        }\n        /**\n         * Handle semantics related to dependencies for `currentExtension`.\n         * semantics: `redExtensions` must wait for `greenExtensions`.\n         */\n        _handleActivateRequest(currentExtensionId, greenExtensions, redExtensions) {\n            if (this._hostExtensionsMap.has(extensions_1.ExtensionIdentifier.toKey(currentExtensionId))) {\n                greenExtensions[extensions_1.ExtensionIdentifier.toKey(currentExtensionId)] = currentExtensionId;\n                return;\n            }\n            const currentExtension = this._registry.getExtensionDescription(currentExtensionId);\n            const depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);\n            let currentExtensionGetsGreenLight = true;\n            for (let j = 0, lenJ = depIds.length; j < lenJ; j++) {\n                const depId = depIds[j];\n                if (this._resolvedExtensionsSet.has(extensions_1.ExtensionIdentifier.toKey(depId))) {\n                    // This dependency is already resolved\n                    continue;\n                }\n                const dep = this._activatedExtensions.get(extensions_1.ExtensionIdentifier.toKey(depId));\n                if (dep && !dep.activationFailed) {\n                    // the dependency is already activated OK\n                    continue;\n                }\n                if (dep && dep.activationFailed) {\n                    // Error condition 2: a dependency has already failed activation\n                    this._host.onExtensionActivationError(currentExtension.identifier, nls.localize('failedDep1', \"Cannot activate extension '{0}' because it depends on extension '{1}', which failed to activate.\", currentExtension.displayName || currentExtension.identifier.value, depId));\n                    const error = new Error(`Dependency ${depId} failed to activate`);\n                    error.detail = dep.activationFailedError;\n                    this._activatedExtensions.set(extensions_1.ExtensionIdentifier.toKey(currentExtension.identifier), new FailedExtension(error));\n                    return;\n                }\n                if (this._hostExtensionsMap.has(extensions_1.ExtensionIdentifier.toKey(depId))) {\n                    // must first wait for the dependency to activate\n                    currentExtensionGetsGreenLight = false;\n                    greenExtensions[extensions_1.ExtensionIdentifier.toKey(depId)] = this._hostExtensionsMap.get(extensions_1.ExtensionIdentifier.toKey(depId));\n                    continue;\n                }\n                const depDesc = this._registry.getExtensionDescription(depId);\n                if (depDesc) {\n                    // must first wait for the dependency to activate\n                    currentExtensionGetsGreenLight = false;\n                    greenExtensions[extensions_1.ExtensionIdentifier.toKey(depId)] = depDesc.identifier;\n                    continue;\n                }\n                // Error condition 1: unknown dependency\n                this._host.onExtensionActivationError(currentExtension.identifier, new extensions_2.MissingDependencyError(depId));\n                const error = new Error(`Unknown dependency '${depId}'`);\n                this._activatedExtensions.set(extensions_1.ExtensionIdentifier.toKey(currentExtension.identifier), new FailedExtension(error));\n                return;\n            }\n            if (currentExtensionGetsGreenLight) {\n                greenExtensions[extensions_1.ExtensionIdentifier.toKey(currentExtension.identifier)] = currentExtensionId;\n            }\n            else {\n                redExtensions.push(currentExtensionId);\n            }\n        }\n        _activateExtensions(extensionIds, reason) {\n            // console.log('_activateExtensions: ', extensionIds.map(p => p.value));\n            if (extensionIds.length === 0) {\n                return Promise.resolve(undefined);\n            }\n            extensionIds = extensionIds.filter((p) => !this._activatedExtensions.has(extensions_1.ExtensionIdentifier.toKey(p)));\n            if (extensionIds.length === 0) {\n                return Promise.resolve(undefined);\n            }\n            const greenMap = Object.create(null), red = [];\n            for (let i = 0, len = extensionIds.length; i < len; i++) {\n                this._handleActivateRequest(extensionIds[i], greenMap, red);\n            }\n            // Make sure no red is also green\n            for (let i = 0, len = red.length; i < len; i++) {\n                const redExtensionKey = extensions_1.ExtensionIdentifier.toKey(red[i]);\n                if (greenMap[redExtensionKey]) {\n                    delete greenMap[redExtensionKey];\n                }\n            }\n            const green = Object.keys(greenMap).map(id => greenMap[id]);\n            // console.log('greenExtensions: ', green.map(p => p.id));\n            // console.log('redExtensions: ', red.map(p => p.id));\n            if (red.length === 0) {\n                // Finally reached only leafs!\n                return Promise.all(green.map((p) => this._activateExtension(p, reason))).then(_ => undefined);\n            }\n            return this._activateExtensions(green, reason).then(_ => {\n                return this._activateExtensions(red, reason);\n            });\n        }\n        _activateExtension(extensionId, reason) {\n            const extensionKey = extensions_1.ExtensionIdentifier.toKey(extensionId);\n            if (this._activatedExtensions.has(extensionKey)) {\n                return Promise.resolve(undefined);\n            }\n            const currentlyActivatingExtension = this._activatingExtensions.get(extensionKey);\n            if (currentlyActivatingExtension) {\n                return currentlyActivatingExtension;\n            }\n            const newlyActivatingExtension = this._host.actualActivateExtension(extensionId, reason).then(undefined, (err) => {\n                this._host.onExtensionActivationError(extensionId, nls.localize('activationError', \"Activating extension '{0}' failed: {1}.\", extensionId.value, err.message));\n                console.error('Activating extension `' + extensionId.value + '` failed: ', err.message);\n                console.log('Here is the error stack: ', err.stack);\n                // Treat the extension as being empty\n                return new FailedExtension(err);\n            }).then((x) => {\n                this._activatedExtensions.set(extensionKey, x);\n                this._activatingExtensions.delete(extensionKey);\n            });\n            this._activatingExtensions.set(extensionKey, newlyActivatingExtension);\n            return newlyActivatingExtension;\n        }\n    }\n    exports.ExtensionsActivator = ExtensionsActivator;\n});\n",null]}